
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: Unit-Analyzers / chuck update</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chuck update" href="/feeds/rss/book/chuck-update/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chuck update" href="/feeds/atom/book/chuck-update/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter Unit Analyzers" href="/feeds/rss/chapter/chuck-update/chuck-update/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter Unit Analyzers" href="/feeds/atom/chapter/chuck-update/chuck-update/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/chuck-update/_draft/_v/1.0/unit-analyzers/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>chuck update</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/introduction/">Introduction</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/places/">Places</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/authors/">Authors</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/installation/">Installation</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/tutorials/">Tutorials</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/hello-chuck/">Hello ChucK</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/conventions/">Conventions</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/on-the-fly-programming/">On-the-fly Programming</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/modifying-basic-patches/">Modifying Basic Patches</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/lfos-and-blackholes/">LFOs and Blackholes</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/working-with-midi/">Working with MIDI</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/writing-to-disk/">Writing to Disk</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/stereo/">Stereo</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/using-osc-in-chuck/">Using OSC in ChucK</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/reference/">Reference</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/overview/">Overview</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/the-chuck-compiler-and-virtual-machine/">The ChucK Compiler and Virtual Machine</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/on-the-fly-commands/">On-the-fly Commands</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/types-values-and-variables/">Types, Values and Variables</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/operators-and-operations/">Operators and Operations</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/time-and-timing/">Time and Timing</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/concurrency-and-shreds/">Concurrency and Shreds</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/events/">Events</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/control-structures/">Control Structures</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/functions/">Functions</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/objects/">Objects</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/arrays/">Arrays</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/unit-analyzers/">Unit Analyzers</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/standard-libraries/">Standard Libraries</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/event-reference/">Event Reference</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/other-objects-reference/">Other Objects Reference</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/ugenreference/">UgenReference</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/unit-generators/">Unit Generators</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/ugens-oscillators/">Ugens: Oscillators</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/ugens-stkinstruments/">Ugens: STKInstruments</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/unit-analyzer-reference/">Unit Analyzer Reference</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/extending-chuck/">Extending ChucK</a></li>
    
   
    
      <li><a href="/chuck-update/_draft/_v/1.0/lick-library-for-chuck/">LiCK: Library for ChucK</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <html lang="en"><head><title>Unit Analyzers</title></head><body><h1>Unit Analyzers
</h1>
<p>Unit Analyzers (UAnae) are analyis building blocks, similar in concept to unit generators. They perform analysis functions on audio signals and/or metadata input, and produce metadata analysis results as output. Unit analyzers can be linked together and with unit generators to form analysis/synthesis networks. Like unit generators, several unit analyzers may run concurrently, each dynamically controlled at different rates. Because data passed between UAnae is not necessarily audio samples, and the relationship of UAna computation to time is fundamentally different than that of UGens (e.g., UAnae might compute on blocks of samples, or on metadata), the connections between UAnae have a different meaning from the connections between UGens formed with the ChucK operator, =&gt; . This difference is reflected in the choice of a new connection operator, the upChucK operator: =^ . Another key difference between UGens and UAnae is that UAnae perform analysis (only) on demand, via the upchuck() function (see below). Some more quick facts about ChucK unit analyzers:
</p>
<ul><li>All ChucK unit analyzers are objects (not primitive types). (see objects)
  <br></li>
  <li>All ChucK unit analyzers inherit from the UAna class. The operation foo =^ yah, where foo and yah are UAnae, connects foo to yah.
  <br></li>
  <li>Unit analyzer parameters and behaviors are controlled by calling / chucking to member functions over time, just like unit generators.
  <br></li>
  <li>Analysis results are always stored in an object called a UAnaBlob. The UAnaBlob contains a time-stamp indicating when it was computed, and it may store an array of floats and/or complex values. Each UAna specifies what information is present in the UAnaBlob it produces.
  <br></li>
  <li>All unit analyzers have the function upchuck(), which when called issues a cascade of analysis computations for the unit analyzer and any "upstream" unit analyzers on which its analysis depends. In the example of foo yah, yah.upchuck() will result in foo first performing its analysis (possibly requesting analysis results from unit analyzers further upstream), then yah, using foo's analysis results in its computation. upchuck() returns the analysis results in the form of a UAnaBlob.
  <br></li>
  <li>Unit analyzers are specially integrated into the virtual machine such that each unit analyzer performs its analysis on its input whenever it or a downstream UAna is upchuck()-ed. Therefore, we have the ability to assert control over the analysis process at any point in time and at any desired control rate. </li>
</ul><h2>declaring
</h2>
<p>Unit analyzers (UAnae) are objects, and they need to be instantiated before they can be used. We declare unit analyzers the same way we declare UGens and other objects.
</p>
<pre>// instantiate an FFT, assign reference to variable f
FFT f; </pre>
<h2>connecting
</h2>
<p>The upChucK operator () is only meaningful for unit analyzers. Similar to the behavior of the ChucK operator between UGens, using to connect one UAna to another connects the analysis results of the first to the analysis input of the second.
</p>
<pre>// instantiate FFT and flux objects,
// connect to allow computation of spectrum and spectral flux on adc input
adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; </pre>
<p>Note that the last UAna in any chain must be chucked to the blackhole or dac to "pull" audio samples from the aaddcc or other unit generators upstream. It is also possible to linearly chain many UAnae together in a single statement. In the example below, the analysis of fluxcapacitor depends on the results of flux, so the flux object will always perform its analysis computation before the computation of fluxcapacitor.
</p>
<pre>// Set up analysis on adc, via an FFT object, a spectral flux object, and a
// made-up object called a FluxCapacitor that operates on the flux value.
adc =&gt; FFT f =^ Flux flux =^ FluxCapacitor flux_capacitor =&gt; blackhole; </pre>
<p>Very importantly, it is possible to create connection networks containing both UAane and UGens. In the example below, an FFT transforms two (added) sinusoidal inputs, one of which has reverb added. An IFFT transforms the spectrum back into the time domain, and the result is processed with a third sinusoid by a gain object before being played through the dac. (No, this example is not supposed to do anything musically interesting, only help you get a feel for the syntax. Notice that any connection through which audio samples are passed is denoted with the operator, and the connection through which spectral data is passed (from the FFT to the IFFT) is denoted with the operator.
</p>
<pre>//Chain a sine into a reverb, then perform FFT, then IFFT,
//then apply gain, then output
SinOsc s =&gt; JCRev r =&gt; FFT f =^ IFFT i =&gt; Gain g =&gt; dac;
// Chuck a second sine into the FFT
SinOsc s2 =&gt; f;
// Chuck a third sine into the final gain
SinOsc s3 =&gt; g; </pre>
<p>FFT, IFFT, and other UAnae that perform transforms between the audio domain and another domain play a special role, as illustrated above. FFT takes audio samples as input, so unit generators connect to it with the ChucK operator =&gt;. However, it outputs analysis results in the spectral domain, so it connects to other UAnae with the upChucK operator =^. Conversely, UAnae producing spectral domain output connect to the IFFT using =&gt;, and IFFT can connect to the dac or other UGens using =&gt;. This syntax allows the programmer to clearly reason about the expected behavior of an analysis/synthesis network, while it hides the internal mechanics of ChucK timing and sample buffering from the programmer. Finally, just as with unit generators, it is possible to dynamically disconnect unit analyzers, using the UnChucK operator (=&gt;or =&lt;).
</p>
<h2>controlling (over time)
</h2>
<p>In any ChucK program, it is necessary to advance time in order to pull audio samples through the UGen network and create sound. Additionally, it is necessary to trigger analysis computations explicitly in order for any analysis to be performed, and for sound synthesis that depends on analysis results (e.g., IFFT) to be performed. To explicitly trigger computation at a point in time, the UAna's upchuck() member function is called. In the example below, an FFT computation is triggered every 1024 samples.
</p>
<pre>adc =&gt; FFT fft =&gt; dac;
// set the FFT to be of of size 2048 samples
2048 =&gt; fft.size;
while (true)
{
     // let 1024 samples pass
     1024::samp =&gt; now;
     // trigger the FFT computation on the last 2048 samples (the FFT size)
     fft.upchuck();
}
</pre>
<p> In the example above, because the FFT size is 2048 samples, the while-loop causes a standard "sliding-window" FFT to be computed, where the hop size is equal to half a window. However, ChucK allows you to perform analysis using nonstandard, dynamically set, or even multiple hop sizes with the same object. For example, in the code below, the FFT object fft performs computation every 5 seconds as triggered by shred1, and it additionally performs computation at a variable rate as triggered by shred2.
</p>
<pre>adc =&gt; FFT fft =&gt; dac;
2048 =&gt; fft.size;
// spork two shreds: shred1 and shred2
spork ~ shred1();
spork ~ shred2();
// shred1 computes FFT every 5 seconds
shred1()
{
     while (true)
     {
          5::second =&gt; now;
          fft.upchuck();
     }
}
// shred2 computes FFT every n seconds, where n is a random number between 1 and 10
shred2()
{
     while (true)
     {
          Std.Rand2f(1, 10)::second =&gt; now;
          fft.upchuck();
     }
}
</pre>
<p>Parameters of unit analyzers may be controlled and altered at any point in time and at any control rate. We only have to assert control at the appropriate points as we move through time, by setting various parameters of the unit analyzer. To set the a value for a parameter of a UAna, a value of the proper type should be ChucKed to the corresponding control function.
</p>
<pre>// connect the input to an FFT
adc =&gt; FFT fft =&gt; blackhole;

//start with a size of 1024 and a Blackman-Harris window
1024 =&gt; fft.size;
Windowing.blackmanHarris(512) =&gt; fft.window;

//advance time and compute FFT
1::minute =&gt; now;
fft.upchuck();

// change window to Hamming
Windowing.hamming(512) =&gt; fft.window;

// let time pass... and carry on.
</pre>
<p>Since the control functions are member functions of the unit analyzer, the above syntax is equilavent to calling functions. For example, the line below could alternatively be used to change the FFT window to a Hamming window, as above.
</p>
<pre>fft.window(Windowing.hamming(512)); </pre>
<p>For a list of unit analyzers and their control methods, consult UAna reference. Just like unit generators, to read the current value of certain parameters of a Uana, we may call an overloaded function of the same name. Additionally, assignments can be chained together when assigning one value to multiple targets.
</p>
<pre>// connect adc to FFT
adc =&gt; FFT fft =&gt; blackhole;
// store the current value of the FFT size
fft.size() =&gt; int fft_size; </pre>
<p>What if a UAna that performs analysis on a group of audio samples is upchuck()- ed before its internal buffer is filled? This is possible if an FFT of size 1024 is instantiated, then upchuck()-ed after only 1000 samples, for example. In this case, the empty buffer slots are treated as 0's (that is, zero-padding is applied). This same behavior will occur if the FFT object's size is increased from 1024 to 2048, and then only 1023 samples pass after this change is applied; the last sample in the new (larger) buffer will be 0. Keep in mind, then, that certain analysis computations near the beginning of time and analysis computations after certain parameters have changed will logically involve a short "transient" period.
</p>
<pre>// connect adc to FFT to blackhole
adc =&gt; FFT fft =&gt; blackhole;
// set the FFT size to 1024 samples
1024 =&gt; fft.size;

// allow 1000 samples to pass
1000::samp =&gt; now;

// compute the FFT: the last 24 spots in the FFT buffer haven't been filled, so they are zero-ed out
// the computation is nevertheless valid and proceeds.
fft.upchuck();

1::minute =&gt; now; // let time pass for a while

// increase the size of the FFT, and therefore the size of the sample buffer it uses
2048 =&gt; fft.size;

// let 1023 samples pass
1023::samp =&gt; now;

// at this point, only 2047 of the 2048 buffer spots have been filled
// the following computation therefore zeros out the last audio buffer spot
fft.upchuck();

1::minute =&gt; now; //let time pass for a while

// now the buffer is happy and
full fft.upchuck(); // proceeds normally on a full buffer </pre>
<h2>representing metadata: the UAnaBlob
</h2>
<p>It is great to be able to trigger analysis computations like we've been doing above, but what if you want to actually use the analysis results? Luckily, calling the upchuck() function on a UAna returns a reference to an object that stores the results of any UAna analysis, called a UanaBlob. UanaBlobs can contain an array of floats, and/or an array of complex numbers (see the next section). The meaning and formatting of the UanaBlob fields is different for each UAna subtype. FFT, for example (see specification), fills in the complex array with the spectrum and the floating point array with the magnitude spectrum. Additionally, all UanaBlobs store the time when the blob was last computed.
</p>
<p>The example below demonstrates how one might access the results of an FFT:
</p>
<pre>adc =&gt; FFT fft =&gt; blackhole;
// ... set FFT parameters here ...

UAnaBlob blob;

while (true)
{
     50::ms =&gt; now; // use hop size of 50 ms
     fft.upchuck() @=&gt; blob; // store the result in blob.
     blob.fvals @=&gt; float mag_spec[]; // get the magnitude spectrum as float array
     blob.cvals @=&gt; complex spec[]; // get the whole spectrum as complex array
     mag_spec[0] =&gt; float first_mag; // get the first bin of the magnitude spectrum
     blob.fvals(0) =&gt; float first_mag2 // equivalent way to get first bin of mag spectrum
     fft.upchuck().fvals(0) =&gt; float first_mag3 // yet another equivalent way
     fft.upchuck().cvals(0) =&gt; float first_spec // similarly, get 1st spectrum bin

     blob.when =&gt; time when_computed; // get the time it was computed
}</pre>
<p>Beware: whenever a UAna is upchuck()-ed, the contents of its previous UAnaBlob are overwritten. In the following code, blob1 and blob2 refer to the same UAnaBlob. When fft.upchuck() is called the second time, the contents of the UAnaBlob referred to by blob1 are overwritten.
</p>
<p>
</p>
<pre>adc =&gt; FFT fft =&gt; blackhole;

UAnaBlob blob1, blob2;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob1; // blob1 points to the analysis results
1::minute =&gt; now; // let time pass again
fft.upchuck() @=&gt; blob2; // now both blob1 and blob2 refer to the same object: the new results! </pre>
<p>Also beware: if time is not advanced between subsequent upchuck()s of a UAna, any upchuck() after the first will not re-compute the analysis, even if UAna parameters have been changed. After the code below, blob refers to a UAnaBlob that is the result of computing the first (size 1024) FFT.
</p>
<pre>adc =&gt; FFT fft =&gt; blackhole;
1024 =&gt; fft.size;

UAnaBlob blob;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob; // blob holds the result of the FFT

512 =&gt; fft.size;
fft.upchuck() @=&gt; blob; // time hasn't advanced since the last computation,
//so no re-computation is done</pre>
<h2> representing complex data: the complex and polar types
</h2>
<p> In order to represent complex data, such as the output of an FFT, two new datatypes have been added to ChucK: complex and polar. These types are described with examples here.
  <br></p>
<h2>performing analysis in UAna networks
</h2>
<p>Often, the computation of one UAna will depend on the computation results of "upstream" UAnae. For example, in the UAna network below, the spectral flux is computed using the results of an FFT.
</p>
<pre>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; </pre>
<p>The flow of computation in UAna networks is set up so that every time a UAna aa is upchuck()-ed, each UAna whose output is connected to aa's input via is upchuck()-ed first, passing the results to aa for it to use. For example, a call to flux.upchuck() will first force fft to compute an FFT on the audio samples in its buffer, then flux will use the UanaBlob from fft to compute the spectral flux. This flow of computation is handled internally by ChucK; you should understand the flow of control, but you don't need to do fft.upchuck() explicitly. Just writing code like that below will do the trick:
</p>
<pre>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true)
{
      100::ms =&gt; now;
      flux.upchuck() @=&gt; blob;
      // causes fft to compute, then computes flux and stores result in blob
}</pre>
<p>Additionally, each time a UAna upchuck()s, its results are cached until time passes. This means that a UAna will only perform its computation once for a particular point in time.
</p>
<pre>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; fft =^ Centroid c =&gt; blackhole; UAnaBlob blob, blob2;
while (true)
{
     100::ms =&gt; now;
     flux.upchuck() @=&gt; blob; // causes fft to compute,
     //then computes flux and stores result in blob
     c.upchuck() @=&gt; blob2; // uses cached fft results from
     //previous line to compute centroid
}
</pre>
<p>When no upchuck() is performed on a UAna, or on UAnae that depend on it, it will not do computation. For example, in the network below, the flux is never computed.
</p>
<pre>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true)
{
     100::ms =&gt; now;
     fft.upchuck() @=&gt; blob; // compute fft only
} </pre>
<p>The combination of this "compute-on-demand" behavior and UAna caching means that different UAnae in a network can be upchuck()-ed at various/varying control rates, with maximum efficiency. In the example below, the FFT, centroid, and flux are all computed at different rates. When the analysis times for flux and fft or centroid and fft overlap, fft is computed just once due to its internal caching. When it is an analysis time point for fft but not for flux, flux will not be computed.
</p>
<pre>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
fft =^ Centroid c =&gt; blackhole;
UAnaBlob blob1, blob2, blob3;

spork do_fft();
spork do_flux();
spork do_centroid();

voi ddo_fft()
{
     while (true)
     {
          50::ms =&gt; now;
          fft.upchuck() @=&gt; blob1;
     }
}

void do_flux()
{
      while (true)
      {
           110::ms =&gt; now;
           flux.upchuck() @=&gt; blob2;
      }
}

void do_centroid()
{
     while (true)
     {
          250::ms =&gt; now;
          c.upchuck()
          @=&gt; blob3;
     }
}
</pre>
<p>An easy way to synchronize analysis of many UAnae is to upchuck() an "agglomerator" UAna. In the example below, agglom.upchuck() triggers analysis of all upstream UAnae in the network. Because agglom is only a member of the UAna base class, it does no computation of its own. However, after agglom.upcuck() all other UAnae will have up-to-date results that are synchronized, computed, and cached so that they are available to be accessed via upchuck()on each UAna (possibly by a different shred waiting for an event - see below).
</p>
<pre>adc =&gt; FFT fft =^ Flux flux =^ UAna agglom =&gt; blackhole;
fft =^ Centroid centroid =&gt; agglom;
// could add abitrarily many more UAnae that connect to agglom via =^

while (true)
{
     100::ms =&gt; now;
     agglom.upchuck();
     // forces computation of both centroid and flux (and therefore fft, too)
} </pre>
<p>Because of the dependency and caching behavior of upchuck()-ing in UAna networks, UAna feedback loops should be used with caution. In the network below, each time cc is upchuck()-ed, it forces bb to compute, which forces aa to compute, which then recognizes that bb has been traversed in this upChucK path but has not been able to complete its computation-- thereby recognizing a loop in the network. aa then uses bb's last computed UAnaBlob to perform its computation. This may or may not be desirable, so be careful.
</p>
<pre>adc =&gt; UAna a =^ UAna b =^ Uana c =&gt; blackhole;
b =^ a; // creates a feedback loop

while (true)
{
     100::ms =&gt; now;
     c.upchuck(); // involves a using b's analysis results from 100 ms ago
} </pre>
<h2>using events
</h2>
<p>When a UAna is upchuck()-ed, it triggers an event. In the example below, a separate shred prints the results of FFT whenever it is computed.
</p>
<pre>adc =&gt; FFT fft =&gt; blackhole;
spork ~printer(); // spork a printing shred

while (true)
{
     50::ms =&gt; now; // perform FFT every 50 ms
     fft.upchuck();
}

void printer()
{
     UAnaBlob blob;
     while (true)
     {
           // wait until fft has been computed
           fft =&gt; now;
           fft.upchuck() @=&gt; blob; // get (cached) fft result

           for (int i = 0; i &lt; blob.fvals().cap(); i++)
               &lt;&lt;&lt; blob.fvals(i) &gt;&gt;&gt;;
     }
} </pre>
<h2>built-in unit analyzers
</h2>
<p>ChucK has a number of built-in UAna classes. These classes perform many basic transform functions (FFT, IFFT) and feature extraction methods (both spectral and time-domain features). A list of built-in ChucK unit analyzers can be found here.
</p>
<h2>creating
</h2>
<p>( someday soon you will be able to implement your own unit analyzers! )
</p>
<p>
</p>

</body></html>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

