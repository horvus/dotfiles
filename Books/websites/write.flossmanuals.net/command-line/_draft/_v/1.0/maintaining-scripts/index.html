
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: Maintaining-Scripts / COMMAND LINE</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for COMMAND LINE" href="/feeds/rss/book/command-line/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for COMMAND LINE" href="/feeds/atom/book/command-line/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter MAINTAINING SCRIPTS" href="/feeds/rss/chapter/command-line/command-line/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter MAINTAINING SCRIPTS" href="/feeds/atom/chapter/command-line/command-line/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/command-line/_draft/_v/1.0/maintaining-scripts/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>COMMAND LINE</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCTION</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/introduction/">INTRODUCTION</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/about-this-manual/">ABOUT THIS  MANUAL</a></li>
    
   
    
      <li><b>BASICS</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/getting-started/">GETTING STARTED</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/beginning-syntax/">BEGINNING SYNTAX</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/moving-around/">MOVING AROUND</a></li>
    
   
    
      <li><b>COMMANDS</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/basic-commands/">BASIC COMMANDS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/standard-files/">STANDARD FILES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/cut-down-on-typing/">CUT DOWN ON TYPING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/superusers/">SUPERUSERS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/redirection/">REDIRECTION</a></li>
    
   
    
      <li><b>ADVANCED-ISH</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/multiple-files/">MULTIPLE FILES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/searching-for-files/">SEARCHING FOR FILES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/piping/">PIPING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/processes/">PROCESSES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/file-structure/">FILE STRUCTURE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/command-history/">COMMAND HISTORY</a></li>
    
   
    
      <li><b>ADVANCED</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/permissions/">PERMISSIONS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/interactive-editing/">INTERACTIVE EDITING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/checking-exit/">CHECKING EXIT</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/sub-commands/">SUB COMMANDS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/moving-again/">MOVING AGAIN</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/customisation/">CUSTOMISATION</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/parameter-substitution/">PARAMETER SUBSTITUTION</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/gnuscreen/">GNUSCREEN</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/ssh/">SSH</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/installing-software/">INSTALLING SOFTWARE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/making-your-own-interpreter/">MAKING YOUR OWN INTERPRETER</a></li>
    
   
    
      <li><b>TEXT EDITORS</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/text-editors/">TEXT EDITORS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/nano/">NANO</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/vim/">VIM</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/emacs/">EMACS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/kedit/">KEDIT</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/gedit/">GEDIT</a></li>
    
   
    
      <li><b>SCRIPTING</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/scripting/">SCRIPTING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/maintaining-scripts/">MAINTAINING SCRIPTS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/other-languages/">OTHER LANGUAGES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/sed/">SED</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/awk/">AWK</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/regular-expressions/">REGULAR EXPRESSIONS</a></li>
    
   
    
      <li><b>SCRIPTING LANGUAGES</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/perl/">PERL</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/python/">PYTHON</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/ruby/">RUBY</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/gnu-octave/">GNU OCTAVE</a></li>
    
   
    
      <li><b>APPENDICES</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/command-quickie/">COMMAND QUICKIE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/outline/">OUTLINE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/credits/">CREDITS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <html dir="LTR"><head><title>CommandLineIntro: MaintainableScripts</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head><body>
<h1>Maintainable Scripts
</h1>
<p>You are slowly delving into programming by the way of shell scripting.  Now it's the best time to start to learn about how to be a good programmer.  Since this book is just an introduction to the command line, we are only going to provide few but nevertheless very important hints centered around the idea of <em>maintainability</em>.
</p>
<p>When programmers talk about maintainability they are talking about the ease with which a program can be modified, whether it's to correct defects, add new functionality, or improve its performance.  Unmaintainable programs are very easy to spot: they lack structure, so functionality is spread all over the place. When you push <em>here</em> they break way over <em>there</em>, a real nightmare. In general, they are very hard to read.  Consider for example this:
</p>
<pre>#!/bin/sh
identify `find ~/Photos/Vacation/2008 -name \*.jpg` | cut -d ' ' -f 3 | sort | uniq -c</pre>
<p>use your favorite editor to save this file as <em>foo</em>, then:
</p>
<pre>$ <strong>chmod +x foo</strong>
$ <strong>./foo</strong>
     11 2304x3072
     12 3072x2304
</pre>
<p>What that small monster does is find files that ends with ".jpg" in a certain directory, run <code>identify</code> on all of them, and report some kind of information that someone at some time must have thought very useful. If the programmer would only have added some hints as to what the programs does...
</p>
<h2>Don't use long lines
</h2>
<p>The first thing you'll note is that our example of an unmaintainable program is one long line. There's really no need for that.  What if the program looked like this instead:
</p>
<pre>#!/bin/sh
identify `find ~/Photos/Vacation/2008 -name \*.jpg` |
cut -d ' ' -f 3 |
sort |
uniq -c
</pre>
<p>It becomes a little bit easier to spot where each command begins and ends.  It's still the same set of piped programs, only their presentation is different.  You can break long lines at pipes and the functionality will be the same.
</p>
<p>You can also split one command into several lines by using the <strong>\</strong> character at the end of a line to join it with the next:
</p>
<pre>#!/bin/sh
echo This \
     is \
     really \
     one \
     long \
     command.
</pre>
<h2> Use descriptive names for your scripts
  <br></h2>
<p>The second thing you might have noticed is that the script is called "foo".  It's short and convenient but it doesn't provide a clue as to what the program does.  What about this:
</p>
<pre>$ <strong>mv foo list_image_sizes</strong>
</pre>
<p>Now the name helps the user understand what the script does.  Much better, isn't it?
  <br></p>
<h2>Use variables
</h2>
<p>One bothersome thing about that program is its use of backticks.  Sure, it works, but it also has drawbacks.  Perhaps the biggest one is the least evident one, too: remember that backticks substitute the output of the command they contain in the position where they appear.  Some systems have a limit of the command line length they allow.  In this particular case, if the specified directory has lots and lots of pictures, the command line can become extraordinarily long, producing an obscure error when you call the program.  There are several methods that you can use to remedy this, but for the purpose of this explanation, let's try the following:
</p>
<pre>#!/bin/sh
find ~/Photos/Vacation/2008 -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c
</pre>
<p> Now <code>find</code> is running the same as before, but its output, the list of filenames, is piped into a while-loop.  The condition for the loop is <code>read image</code>.  <code>read</code> is a function that reads one line at a time, splits its input into fields and then assigns each field to a variable, <em>image</em> in this case.  Now <code>identify</code> works on one image at a time.
</p>
<p>Notice how introducing a variable makes the program a bit easier to read: it literally says that you wish to identify an image.  Also note how the effect on future programmers wouldn't have been the same if the variable was called something like <em>door</em> or <em>cdrom</em>.  Names are important!
  <br></p>
<p>But there's still something bothersome about the program: that directory name is glowing like a sore thumb.  What if we change the program like this:
</p>
<pre>#!/bin/sh
START_DIRECTORY=~/Photos/Vacation/2008

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c</pre>
<p>That's a little bit better: now you can edit your script and change the directory each time you wish to process a different one.
</p>
<h2>Use arguments
  <br></h2>
<p>That last bit didn't sound quite right, did it?  After all, you don't edit <code>ls</code> each time you wish to list the contents of a different directory, do you? Let's make our program just as adaptable:
  <br></p>
<pre>#!/bin/sh
START_DIRECTORY=$1

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c</pre>
<p>The <em>$1</em> variable is the first argument that you pass to your script ($0 is the name of the script you're running).  Now you can call your script like this:
</p>
<pre>$ <strong>./list_image_sizes ~/Photos/Vacation/2008</strong></pre>
<p>Or you can examine the 2007 pictures, if you wish:
</p>
<pre>$ <strong>./list_image_sizes ~/Photos/Vacation/2007</strong>
</pre>
<h2>Know where you begin
</h2>
<p>Consider what happens if you run the script like this:
</p>
<pre>$ <strong>./list_image_sizes</strong></pre>
<p>Maybe that's what you want, but maybe it isn't.  What happens is that <em>$1</em> is empty, so <em>$START_DIRECTORY</em> is empty as well and in turn the first argument to find is also empty.  That means that find will search your current working directory.  You might wish to make that behavior explicit:
  <br></p>
<pre>#!/bin/sh
if test -n "$1" ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c</pre>
<p>The program behaves exactly as before, with the only difference that in six months, when you come back and look at the program, you won't have to wonder why it's producing results even when you don't pass it a directory as argument.
</p>
<h2>Look before you leap
  <br></h2>
<p>Speaking of which, what happens if you do pass an argument to the script, but that argument isn't a directory or better yet, it doesn't even exist?  Try it.
</p>
<p>Not pretty, ah?
</p>
<p>What if we do this:
</p>
<p>
</p>
<pre>#!/bin/sh
if test -n "$1" ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    exit
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c</pre>
<p>That's better.  Now the script won't even attempt to run if the argument it receives isn't a directory.  It isn't very polite, though: <em>it silently exits</em> with no hint of what went wrong.
</p>
<h2>Complain if you must
  <br></h2>
<p>That's easily fixed:
</p>
<pre>#!/bin/sh
if test -n "$1" ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \"$START_DIRECTORY\" is not a directory or it does not exist.  Stop.
    exit
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c</pre>
<h2>Mind your exit
  <br></h2>
<p>The program now produces an error message if you don't pass it an existing directory as argument and it exits without further action.  It would be nice if you let other programs that might eventually call your script know that there was an error condition.  That is, it would be nice if your program exits with an error code.  Something like this:
</p>
<p>
</p>
<pre>#!/bin/sh
if test -n "$1" ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \"$START_DIRECTORY\" is not a directory or it does not exist.  Stop.
    exit 1
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c</pre>
<p>Now, if there's an error, your script's exit code is 1. If the program exits normally, the exit code is 0.
</p>
<h2>Use comments
</h2>
<p>Anything following a <strong>#</strong> symbol on a line will be ignored, allowing you to add notes about how your script works.  For example:
</p>
<pre>#!/bin/sh
# This script reports the sizes of all the JPEG files found under the current
# directory (or the directory passed as an argument) and the number of photos
# of each size.

if test -n "$1" ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \"$START_DIRECTORY\" is not a directory or it does not exist.  Stop.
    exit 1
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f 3 |
sort |
uniq -c
</pre>
<p>
</p>
<p>Comments are good, but don't fall prey to writing too many comments.  Try to construct your program so that the code itself is clear.  The reason behind this is simple: next year, when <em>someone else</em> changes your script, that other person could well change the commands and forget about the comments, making the later misleading.  Consider this:
</p>
<pre># count up to three
for n in `seq 1 4` ; do echo $n ; done
</pre>
<p>Which one is it?  Three or four?  Evidently the program is counting up to four, but the comment says it's up to three.  You could adopt the position that the program is right and the comment is wrong.  But what if the person who wrote this meant to count to three and that's the reason why the comment is there?  Let's try it like this:
</p>
<pre># There are three little pigs
for n in `seq 1 3` ; do echo $n ; done</pre>
<p>The comment documents the <em>reason</em> why the program is counting up to three: it is not describing what the program <em>does</em>, it's describing what the program <em>should do</em>.  Let's consider a different approach:
</p>
<pre>TOTAL_PIGS=3
for pig in `seq 1 $TOTAL_PIGS` ; do echo $pig ; done
</pre>
<p>Same result, slightly different program.  If you reformat your program, you can do without the comments (as a side note, the fancy word for the kinds of change we have been making is <em>refactoring</em>, but that goes outside the scope for this book).
</p>
<h2>Avoid magic numbers
  <br></h2>
<p>In our current example, there's a <em>magic number</em>, a number that makes the program work, but no one knows why it has to be <em>that</em> number.  It's magic!
</p>
<pre>...
cut -d ' ' -f 3 |
...
</pre>
<p>You have two choices: write a comment and document why it has to be "3" instead of "2" or "4" or introduce a variable that explains why by way of its name.  Let's try the latter:
  <br></p>
<pre>#!/bin/sh
# This script reports the sizes of all the JPEG files found under the current
# directory (or the directory passed as an argument) and the number of photos
# of each size.

if test -n "$1" ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \"$START_DIRECTORY\" is not a directory or it does not exist.  Stop.
    exit 1
fi

IMAGE_SIZE_FIELD=3

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d ' ' -f $IMAGE_SIZE_FIELD |
sort |
uniq -c</pre>
<p>It does improve things a little; at least now we know where the 3 comes from.  If ImageMagick ever changes the output format, we can update the script accordingly.
</p>
<h2>Did it work?
</h2>
<p>Last but not least, check the exit status of the commands you run.  As it stands right now, in our example there's not much that can fail.  So let's try one last example:
  <br></p>
<pre>#!/bin/sh
# Copy all the HTML and image files present in the source directory to the
# specified destination directory.

SRC=$1
DST=$2

if test -z "$SRC" -o -z "$DST" ; then
    cat&lt;&lt;EOT
Usage:

    $0 source_directory destination_directory
EOT
    exit 1
fi

if ! test -d "$SRC" ; then
    echo \"$SRC\" is not a directory or it does not exist.  Stop.
    exit 1
fi

if test -e "$DST" ; then
    echo \"$DST\" already exists.  Stop.
    exit 1
fi

if ! mkdir -p "$DST" ; then
    echo Can\'t create destination directory \"$DST\".  Stop.
    exit 1
fi

# Obtain the absolute path for $DST
cd "$DST"
DST=`pwd`
cd -

cd "$SRC"

find ! -type d \( -name \*.html -o -name \*.jpg -o -name \*.png \) |
while read filename ; do
    dir=`dirname "$filename"`
    mkdir -p "$DST/$dir" &amp;&amp; cp -a "$filename" "$DST/$filename"
    if test $? -ne 0 ; then
        echo Can\'t copy \"$filename\" to \"$DST/$filename\"
        echo Abort.
        exit 1
    fi
done
</pre>
<p>Note that this example makes use of many things you learned in this book. It does not try to be definitive; you can practice improving it!
</p>
<p>The thing you should note now is how the program pays attention to the error conditions that the different programs might produce.  For example, instead of just calling <code>mkdir</code> to check if a program worked, it does this:
</p>
<pre>if ! mkdir -p "$DST" ; then
    echo Can\'t create destination directory \"$DST\".  Stop.
    exit 1
fi
</pre>
<p>It calls <code>mkdir</code> as the condition for <code>if</code>.  If <code>mkdir</code> encounters an error, it will exit with a non-zero status and the <code>if</code> clause will interpret that as a false condition. The "!" is a negation operator that inverts false to true (or vice versa. So the line as a whole basically says "Run the <code>mkdir</code> command, turn an error into a true value with the "!" operator, and take action if it's true that there's an error." In short, if <code>mkdir</code> encounters an error, the flow will enter the body of the <code>if</code>.  This might happen, for example, if the user running the script doesn't have permissions to create the requested directory.
  <br></p>
<p>Note also the usage of "&amp;&amp;" to verify error conditions:
  <br></p>
<pre>mkdir -p "$DST/$dir" &amp;&amp; cp -a "$filename" "$DST/$filename"</pre>
<p>If <code>mkdir</code> fails, <code>cp</code> won't be called.  Furthermore, if either <code>mkdir</code> or <code>cp</code> fails, the exit status will be non-zero.  That condition is checked in the next line:
</p>
<pre>if test $? -ne 0 ; then</pre>
<p>Since this might indicate something going awfully wrong (e.g., is the disk full?), we had better give up and stop the program.
</p>
<h2>Wrapping up
</h2>
<p>Writing scripts is an art. You can become a better artist by looking at what others have done before you and doing a lot yourself. In other words: <em>read a lot of scripts and write a lot of scripts yourself</em>.
</p>
<p>Happy hacking!
  <br></p>
</body></html>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

