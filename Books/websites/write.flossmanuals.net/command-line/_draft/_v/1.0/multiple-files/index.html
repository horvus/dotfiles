
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: Multiple-Files / COMMAND LINE</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for COMMAND LINE" href="/feeds/rss/book/command-line/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for COMMAND LINE" href="/feeds/atom/book/command-line/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter MULTIPLE FILES" href="/feeds/rss/chapter/command-line/command-line/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter MULTIPLE FILES" href="/feeds/atom/chapter/command-line/command-line/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/command-line/_draft/_v/1.0/multiple-files/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>COMMAND LINE</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCTION</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/introduction/">INTRODUCTION</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/about-this-manual/">ABOUT THIS  MANUAL</a></li>
    
   
    
      <li><b>BASICS</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/getting-started/">GETTING STARTED</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/beginning-syntax/">BEGINNING SYNTAX</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/moving-around/">MOVING AROUND</a></li>
    
   
    
      <li><b>COMMANDS</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/basic-commands/">BASIC COMMANDS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/standard-files/">STANDARD FILES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/cut-down-on-typing/">CUT DOWN ON TYPING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/superusers/">SUPERUSERS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/redirection/">REDIRECTION</a></li>
    
   
    
      <li><b>ADVANCED-ISH</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/multiple-files/">MULTIPLE FILES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/searching-for-files/">SEARCHING FOR FILES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/piping/">PIPING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/processes/">PROCESSES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/file-structure/">FILE STRUCTURE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/command-history/">COMMAND HISTORY</a></li>
    
   
    
      <li><b>ADVANCED</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/permissions/">PERMISSIONS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/interactive-editing/">INTERACTIVE EDITING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/checking-exit/">CHECKING EXIT</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/sub-commands/">SUB COMMANDS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/moving-again/">MOVING AGAIN</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/customisation/">CUSTOMISATION</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/parameter-substitution/">PARAMETER SUBSTITUTION</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/gnuscreen/">GNUSCREEN</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/ssh/">SSH</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/installing-software/">INSTALLING SOFTWARE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/making-your-own-interpreter/">MAKING YOUR OWN INTERPRETER</a></li>
    
   
    
      <li><b>TEXT EDITORS</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/text-editors/">TEXT EDITORS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/nano/">NANO</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/vim/">VIM</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/emacs/">EMACS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/kedit/">KEDIT</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/gedit/">GEDIT</a></li>
    
   
    
      <li><b>SCRIPTING</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/scripting/">SCRIPTING</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/maintaining-scripts/">MAINTAINING SCRIPTS</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/other-languages/">OTHER LANGUAGES</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/sed/">SED</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/awk/">AWK</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/regular-expressions/">REGULAR EXPRESSIONS</a></li>
    
   
    
      <li><b>SCRIPTING LANGUAGES</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/perl/">PERL</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/python/">PYTHON</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/ruby/">RUBY</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/gnu-octave/">GNU OCTAVE</a></li>
    
   
    
      <li><b>APPENDICES</b></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/command-quickie/">COMMAND QUICKIE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/outline/">OUTLINE</a></li>
    
   
    
      <li><a href="/command-line/_draft/_v/1.0/credits/">CREDITS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <p>CommandLineIntro: MultipleFiles</p>
<h1>Multiple Files</h1>
<p>After getting used to the command line, you will start looking for ways to do more in less time.&nbsp; One of the easiest ways to achieve that is to work on multiple files at the same time, so that instead of:</p>
<pre>$ <strong>rm this</strong>
$ <strong>rm that</strong>
$ <strong>rm here</strong>
$ <strong>rm there</strong>
</pre>
<p>you just remove all those files with one command. Many commands, including <code>rm</code>, let you simply specify all the files you want to delete as arguments in one go:</p>
<pre>$ <strong>rm this that here there</strong><strong></strong>
</pre>
<p>Still, there has to be a better way! </p>
<h2>Globbing</h2>
<p>File globbing is the shell's way of dealing with multiple files with the fewest characters possible.&nbsp; The shell treats certain characters as codes that you can use to specify groups of things you want the commands to affect. These characters are commonly called "wildcards" because they're like a card in a game that the players have designated to represent anything you want.&nbsp; </p>
<h3><strong>The "*" Wildcard </strong></h3>
<p>&nbsp;</p>
<p>Imagine a directory of files:</p>
<pre>$<strong> ls</strong>
here  that  there  this
</pre>
<p>that you want to delete.&nbsp; A tedious job can be turned simple by using the * or asterisk wildcard.</p>
<pre>$<strong> rm *</strong>
</pre>
<p>When used by itself, the asterisk wildcard refers to all the items in the directory except for those with names starting with ".". We say that the shell <em>expands</em> the wildcard. Knowing what's in the directory, the shell substitutes those filenames for the asterisk and effectively executes the following command:</p>
<p>&nbsp;</p>
<pre>$<strong> rm here that there this</strong>
</pre>
<p>You can combine * with other characters, however, to make it selective.</p>
<pre>$<strong> rm t*</strong>
$<strong> ls</strong>
here</pre>
<p>What happened here? The shell looked at "t" first and then expanded the asterisk to cover all the files that begin with "t".&nbsp; If you had requested "h*" instead, the shell would have removed any file that started with an "h". Let's make the directory like it was and then remove the "h" files: </p>
<pre>$ <strong>touch that there this</strong>
<strong></strong>$<strong> rm h* </strong>$<strong> ls</strong>
that  there  this
</pre>
<p>The asterisk wildcard can be placed anywhere within a word. Let's switch to an <code>ls</code> command because it's easier to see what's happening with wildcards: </p>
<pre>$<strong> ls th*re </strong>there
</pre>
<p>By switching from <code>rm</code> to <code>ls</code> we see an important aspect of wildcard: you can use them with any command, because the shell interprets them before it even invokes the command. In fact, you can't issue a command <em>without</em> taking into account the behavior of wildcards, because they're a feature of the shell.&nbsp; (Luckily, you're not likely to ever have to deal with a filename that contains a real asterisk.) </p>
<p>Multiple asterisks can also be used together. For instance, in this way you can find filenames where the middle of a series is the same, but they start and end differently. Let's try it on the original four files: </p>
<pre>$<strong> ls *i*</strong>
this</pre>
<p>People often use the asterisk to remove files that are all of one type. For instance, if you've been working with a lot of photos and want to clean up files ending in <em>.jpg</em> when you're finished, you can remove all the ones in the current directly as follows:</p>
<p>&nbsp;</p>
<pre>$<strong> rm *.jpg</strong></pre>
<p>Suppose you have some files ending in&nbsp; <em>.jpg</em> and some ending in <em>.jpeg</em>. The asterisk still makes clean-up easy:</p>
<p>&nbsp;</p>
<pre>$<strong> ls *.jp*g</strong></pre>
<p>And suppose the JPEG files are scattered among several subdirectories. You have directories named photos1, photos2, photos3, and so forth, each containing JPEGs you want to remove. A wildcard can help you list all the contents of those subdirectories:</p>
<p>&nbsp;</p>
<pre>$ <strong>ls photos*</strong>
<strong></strong>photos1:
centraal_station.jpg    nieuwe_kerk.jpg

photos2:
ica.jpeg                sanders_theater.jpeg

photos3:
bayeux_cathedral.jpeg   rouen_cathedral.jpeg    travel.odt
</pre>
<p>And you can specify a directory along with the filenames you remove:</p>
<p>&nbsp;</p>
<pre>$ <strong>rm photos*/*.jp*g</strong>
$ <strong>ls photos*</strong>
photos1:

photos2:

photos3:
travel.odt</pre>
<p>Only the <em>travel.odt</em> file remains (because it doesn't match ".jp*g") as a record of all the trips you've taken. </p>
<p>There is, however, one limit to the asterisk wildcard.&nbsp; By default, it will not match any hidden files (those with filenames that start with a dot, you need to <code>ls -a</code> to see these).</p>
<pre>$<strong> ls -a</strong>
.
..
.hidden
this
that
here
there
$<strong> rm *</strong>
$<strong> ls -a </strong>
.
..
.hidden</pre>
<p>If you want those hidden files deleted by a wildcard it is necessary to append a dot to the front of the wildcard. Note that normal files (those that are not hidden/do not start with a dot) will not be deleted when you do this: </p>
<p>&nbsp;</p>
<pre>$<strong> ls -a</strong>
.
..
.hidden
here
$<strong> rm .*</strong>
$<strong> ls -a </strong>
.
..
here
</pre>
<p>Finally, it's important to note that the asterisk can also match nothing when appropriate, as seen in the following example:</p>
<pre>$ <strong>ls task*</strong>
task&nbsp; taskA&nbsp; taskB&nbsp; taskXY</pre>
<p>&nbsp;This is because the asterisk matches zero or more occurrences.&nbsp; So, as in this example, "task*" matches any filename that starts with "task" even if it only consists of just "task".</p>
<p><strong>CAUTION:</strong> When you use just an asterisk ("*") with <strong><code>rm</code></strong>, and basically any other command, it is always a good idea to put an option terminator ("--") before the wildcard like this:</p>
<p>&nbsp;</p>
<pre>$ <strong>rm -- *</strong></pre>
<p>Take this case for example: </p>
<p>&nbsp;</p>
<pre>$ <strong>ls</strong></pre>
<p>-r directory1 directory2 file1.txt</p>
<p><strong>$ rm *</strong></p>
<p>&nbsp;</p>
<p>Normally, <strong>rm</strong> will not remove sub-directories and their contents, however, in this case everything in the directory will be removed even the sub-directories. This is because the asterisk("*") is expanded to "-r directory1 directory2 file1.txt". Although "-r" is a filename, <strong><code>rm</code></strong> will confuse it as an option and think it has been told to delete the directories and their contents as well. Using an the option terminator ("--") will prevent <strong><code>rm</code></strong> from treating anything following the terminator as an option. Therefore, generally it is a good idea to always use an option terminator after typing a command and its options, if there is any, to prevent the command from treating a filename as an option. </p>
<h3><strong>The "?" Wildcard </strong> </h3>
<p>The "?" or question mark wildcard is very similar to the asterisk wildcard.&nbsp; The crucial difference is that the question mark wildcard takes the place of only one character.</p>
<pre>$ <strong>ls task*</strong>
task&nbsp; taskA&nbsp; taskB&nbsp; taskXY
$ <strong>ls task?</strong>
taskA&nbsp; taskB
$ <strong>ls task??</strong>
taskXY</pre>
<p>As we've already seen, the asterisk matches all the files beginning with "task". A single question mark matches files that have a single character after "task". The double question mark requires exactly two characters in that position. </p>
<h3><strong>The "[ ]" Wildcards </strong></h3>
<p>&nbsp;</p>
<p>The square brackets wildcards can get even more specific, denoting a ranges of characters.The following <code>ls</code> command includes a <code>-1</code> (the digit "one") option, which means "list one entry on each line." This makes it easier to see how the files in this example differ. </p>
<pre>$<strong> ls -1</strong>
file_1
file_2
file_3
file_a
file_b
file_c&nbsp;
</pre>
<p>By using the square brackets, you can remove specific files without typing every name completely.</p>
<pre>$<strong> rm file_[13ac]</strong>
$<strong> ls -1</strong>
file_2
file_b
</pre>
<p>Furthermore, within the square brackets, the order of the characters doesn't matter. </p>
<p>Combining square brackets with a hyphen, you can also do ranges of files. Let's start with a directory containing lots of files ending in numbers:</p>
<pre>$<strong> ls</strong>
file_1
file_2
file_3
...
file_9
</pre>
<p>At first it might be tempting to use the asterisk wildcard here.&nbsp; However, what if we need to remove only files 2-6? We could list each suffix in the brackets, but you would still have to type five numbers.&nbsp; Fortunately, there is a much easier way.</p>
<pre>$<strong> rm file_[2-6]</strong></pre>
<p>Now the only files left are files 1 and 7-9.&nbsp; By using the dash between a set of numerals in the square brackets, you make the shell expand the pattern by creating a name with every number between the starting value to the left of the dash and the end value to the right.</p>
<p>Ranges aren't just for numbers.&nbsp; They can also use letters.</p>
<pre>$<strong> ls -1</strong>
file_a
file_b
file_c
file_d<strong> </strong>$ <strong>rm file_[a-c] </strong>$ <strong>ls -1</strong>
file_d
</pre>
<p>Both letters and ranges can be combined into the same instance of square brackets.</p>
<pre>$<strong> ls -1</strong>
file_a
file_b
file_c
file_1
file_2<strong> </strong>$<strong> rm file_[a-c12] </strong>$<strong> ls</strong>
</pre>
<p>&nbsp;</p>
<p>&nbsp;Character groups can be inverted by prefixing them with the <strong>^</strong> (caret) character:</p>
<pre>$ <strong>ls -1 </strong>file_a
file_b
file_c
file_d
file_1
file_2
$ <strong>ls -1 file_[^c-z2-9]</strong>
file_a
file_b
file_1
</pre>
<p><strong>CAUTION:</strong> Ranges can, at times, be tricky things. For one, their order can be affected by the current locale settings (in some locales [A-C] could mean the same as [ABCabc], while in others it could be equivalent to [ABC]). A good rule of thumb is to always know which files you are working with. You can do this by simply substituting <strong>echo</strong> or <strong>ls</strong> for whatever command you intend to run, such as:</p>
<pre>$ <strong>ls -1 file[A-b]</strong>
fileA
fileB
filea
fileb</pre>
<p>This allows you to ensure the pattern matches the files you want to work with. </p>
<h2>Brace Expansion</h2>
<p>We've seen the ability to get a range of characters or letters that fall in a single digit range (0-9 in our examples) but what about when you need to match a range of files that uses double or even triple digits?</p>
<pre>$<strong> ls -1</strong>
file_1
file_2
file_3
...
file_78
$<strong> rm file_[1-20]</strong>
$<strong> ls -1</strong>
file_3
...
file_78</pre>
<p>Since the brackets glob can only interpret single character ranges it interprets, "1-20" not as a range but as the characters: "1", "-", "2", and "0". &nbsp; Causing only "file_1" and "file_2" to be deleted because they are the only ones that match.&nbsp; If you want to access ranges larger than 0-9, you have to using Bash's brace expansion, "{start..end}".</p>
<pre>$<strong> rm file_{1..20}</strong></pre>
<p>In a brace range the double dot is the delimiter instead of a dash.&nbsp;</p>
<p>Braces can also be used when you need to get a series of files that have a common pattern but subtle differences.&nbsp; Such as with:</p>
<pre>$<strong> ls</strong>
file.txt
file.pdf
file.pl
file.odf</pre>
<p>If you just wanted to delete the <em>pdf</em>, <em>odf</em>, and <em>txt</em> files you could specify a comma separated list of strings in a brace pair:</p>
<pre>$<strong> rm file.{txt,pdf,odf}</strong>
$<strong> ls</strong>
file.pl</pre>
<h2>Globbing When No File Matches</h2>
<p>Suppose you specify a wildcard and the shell can't find any matching filename:</p>
<pre>$<strong> ls -1</strong>
file_a
file_b
file_c
file_d<strong> </strong>$<strong> rm file?</strong>
rm: cannot remove `file?': No such file or directory
</pre>
<p>When there is no file to match a pattern, the shell passes the wildcard to the program unexpanded.&nbsp; That's why you get an error message from the <code>rm</code> program, not from the shell. </p>
<h2>Disabling A Wildcard</h2>
<p>Okay, we know the shell will pass a wildcard as an option to a program when it can't find a file, but what do we do when we want to send a character that also happens to be a wildcard to our program? Here's a common example: we want to search a file for every occurrence of an asterisk.</p>
<pre>$<strong> ls </strong>
2file
*file
*?****[a-b]
</pre>
<p>Now we happen to want *file, but we get:</p>
<pre>*file&nbsp;&nbsp; 2file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre>
<p>Why? Because the asterisk is a wildcard, the shell expanded it before sending it to <code>ls</code>.&nbsp; So after expansion, the command would look like:</p>
<p>&nbsp;</p>
<pre>$ <strong>ls *file 2file</strong></pre>
<p>&nbsp;</p>
<p>If we want <code>ls</code> to find an asterisk something different is in order.</p>
<p>The "\", or backslash, tells the shell to treat the following character as a normal character and do no expansion.</p>
<pre>$<strong> ls \*file</strong>
*file
</pre>
<p>&nbsp;</p>
<p>Because the asterisk is the next character after the backslash, the shell sends the asterisk to <code>ls</code> unmodified.&nbsp; In other words: the backslash <em>escapes</em> the asterisk. </p>
<p>The backslash modifier works well when we have only one wildcard character than we want to pass to a program, but what if we wanted to pass a string like <strong>*?****[a-b] </strong>with lots of characters that would normally be interpreted as wildcards?&nbsp; If we used backslashes to escape them, we'd have to mark every single character.&nbsp; A short string would end up turning into: <strong>\*\?\*\*\*\*\[a-b\]</strong>.&nbsp; Instead of doubling our amount of typing, we can use a pair of single quotes.</p>
<p>&nbsp;</p>
<pre>$<strong> ls '*?****[a-b]'</strong>
*?****[a-b]
</pre>
<p>Any string encased in single quotes will not be modified by the shell, even when it's filled with wildcards.&nbsp; However, you cannot type a single quote within the single quotes like this:</p>
<pre>$<strong> ls '*?***'*[a-b]'</strong>
</pre>
<p>So, if you happen to have a file whose name has some single quotes in it like this:</p>
<pre>*?*'**'*[a-b]
</pre>
<p>There is no other way but to escape the single quotes individually like this:</p>
<p>&nbsp;</p>
<pre>$<strong> ls '*?*'\''**'\''*[a-b]'</strong> </pre>
<p>Simply to say, replace any occurence of a single quote in the filename with '\''.</p>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

