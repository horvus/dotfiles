
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
<title>/chapter: Command-Quickie / COMMAND LINE</title>
<link type="text/css" href="/site_static/css/published.css" rel="Stylesheet" />

<link rel="alternate" type="application/rss+xml" title="RSS feed for COMMAND LINE" href="/feeds/rss/book/command-line/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for COMMAND LINE" href="/feeds/atom/book/command-line/" /> 

<link rel="alternate" type="application/rss+xml" title="RSS feed for chapter COMMAND QUICKIE" href="/feeds/rss/chapter/command-line/command-line/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for chapter COMMAND QUICKIE" href="/feeds/atom/chapter/command-line/command-line/" /> 


<style>
SPAN.bookicommentmarker {
  background-color: white;
}

SPAN.bookicommentmarker > IMG.markerimage { 
   display: none;
}


</style>



   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/command-line/command-quickie/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    
   <h2>COMMAND LINE</h2>

<div class="padded">
<div id="bookmenu">
<ul>

 
   <li><b>INTRODUCTION</b></li>
 

 
   <li><a href="/command-line/introduction/">INTRODUCTION</a></li>
 

 
   <li><a href="/command-line/about-this-manual/">ABOUT THIS  MANUAL</a></li>
 

 
   <li><b>BASICS</b></li>
 

 
   <li><a href="/command-line/getting-started/">GETTING STARTED</a></li>
 

 
   <li><a href="/command-line/beginning-syntax/">BEGINNING SYNTAX</a></li>
 

 
   <li><a href="/command-line/moving-around/">MOVING AROUND</a></li>
 

 
   <li><b>COMMANDS</b></li>
 

 
   <li><a href="/command-line/basic-commands/">BASIC COMMANDS</a></li>
 

 
   <li><a href="/command-line/standard-files/">STANDARD FILES</a></li>
 

 
   <li><a href="/command-line/cut-down-on-typing/">CUT DOWN ON TYPING</a></li>
 

 
   <li><a href="/command-line/superusers/">SUPERUSERS</a></li>
 

 
   <li><a href="/command-line/redirection/">REDIRECTION</a></li>
 

 
   <li><b>ADVANCED-ISH</b></li>
 

 
   <li><a href="/command-line/multiple-files/">MULTIPLE FILES</a></li>
 

 
   <li><a href="/command-line/searching-for-files/">SEARCHING FOR FILES</a></li>
 

 
   <li><a href="/command-line/piping/">PIPING</a></li>
 

 
   <li><a href="/command-line/processes/">PROCESSES</a></li>
 

 
   <li><a href="/command-line/file-structure/">FILE STRUCTURE</a></li>
 

 
   <li><a href="/command-line/command-history/">COMMAND HISTORY</a></li>
 

 
   <li><b>ADVANCED</b></li>
 

 
   <li><a href="/command-line/permissions/">PERMISSIONS</a></li>
 

 
   <li><a href="/command-line/interactive-editing/">INTERACTIVE EDITING</a></li>
 

 
   <li><a href="/command-line/checking-exit/">CHECKING EXIT</a></li>
 

 
   <li><a href="/command-line/sub-commands/">SUB COMMANDS</a></li>
 

 
   <li><a href="/command-line/moving-again/">MOVING AGAIN</a></li>
 

 
   <li><a href="/command-line/customisation/">CUSTOMISATION</a></li>
 

 
   <li><a href="/command-line/parameter-substitution/">PARAMETER SUBSTITUTION</a></li>
 

 
   <li><a href="/command-line/gnuscreen/">GNUSCREEN</a></li>
 

 
   <li><a href="/command-line/ssh/">SSH</a></li>
 

 
   <li><a href="/command-line/installing-software/">INSTALLING SOFTWARE</a></li>
 

 
   <li><a href="/command-line/making-your-own-interpreter/">MAKING YOUR OWN INTERPRETER</a></li>
 

 
   <li><b>TEXT EDITORS</b></li>
 

 
   <li><a href="/command-line/text-editors/">TEXT EDITORS</a></li>
 

 
   <li><a href="/command-line/nano/">NANO</a></li>
 

 
   <li><a href="/command-line/vim/">VIM</a></li>
 

 
   <li><a href="/command-line/emacs/">EMACS</a></li>
 

 
   <li><a href="/command-line/kedit/">KEDIT</a></li>
 

 
   <li><a href="/command-line/gedit/">GEDIT</a></li>
 

 
   <li><b>SCRIPTING</b></li>
 

 
   <li><a href="/command-line/scripting/">SCRIPTING</a></li>
 

 
   <li><a href="/command-line/maintaining-scripts/">MAINTAINING SCRIPTS</a></li>
 

 
   <li><a href="/command-line/other-languages/">OTHER LANGUAGES</a></li>
 

 
   <li><a href="/command-line/sed/">SED</a></li>
 

 
   <li><a href="/command-line/awk/">AWK</a></li>
 

 
   <li><a href="/command-line/regular-expressions/">REGULAR EXPRESSIONS</a></li>
 

 
   <li><b>SCRIPTING LANGUAGES</b></li>
 

 
   <li><a href="/command-line/perl/">PERL</a></li>
 

 
   <li><a href="/command-line/python/">PYTHON</a></li>
 

 
   <li><a href="/command-line/ruby/">RUBY</a></li>
 

 
   <li><a href="/command-line/gnu-octave/">GNU OCTAVE</a></li>
 

 
   <li><b>APPENDICES</b></li>
 

 
   <li><a href="/command-line/glossary/">GLOSSARY</a></li>
 

 
   <li><a href="/command-line/command-quickie/">COMMAND QUICKIE</a></li>
 

 
   <li><a href="/command-line/outline/">OUTLINE</a></li>
 

 
   <li><a href="/command-line/credits/">CREDITS</a></li>
 

</ul>
</div>
<div id="bookcontent">
   
<html dir="LTR"><head><title>CommandLineIntro: CommandQuickReference</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head><body>
<h1>Command Quick Survey
</h1>
<p>In each of the command examples in this chapter, the dollar sign ($) at the beginning of the line is a minimal GNU/Linux command prompt. (Your default prompt is usually more complex.)
</p>
<p>The rest of the line is the command, with options and arguments. We use the following conventions.
</p>
<ul><li>Lines that do not begin with "$ " are responses from the command execution. </li>
  <li>The "|" character pipes the output of any command to another command. </li>
  <li>The "&gt;" character redirects the output of any command to a file.</li>
  <li>To append output to a file, use "&gt;&gt;". </li>
  <li>Many commands have no output. They succeed or fail silently, but return an error code that a script can use to decide what to do next. </li>
  <li>The ";" character separates commands on the same line. They are executed in sequence, starting at the left. </li>
  <li>The "&amp;" character at the end of a command line says to execute the command in the background, and give the user prompt for the next command immediately.</li>
  <li>The "\" character at the end of a command line says that the command continues on the next line. Although the examples given in this manual are generally quite short, there are cases where commands span five or six lines in script files.
  <br></li>
  <li>In '<em>some text with spaces</em> ' and "<em>more text with spaces</em>", the single and double quotes indicate that the text inside is one argument, including the trailing space in the first example. Without them, the shell would interpret each word as a separate argument and discard whitespace.</li>
  <li>Backticks "``" mark commands to be executed. The result is substituted for the command. </li>
  <li>A number of commands have an option, usually written <code>-r</code> or <code>-R</code>, for applying the command to every file in every subdirectory of the location where the command starts its work. Since these options can be and are used for other functions, you should check the documentation on any command where you want to use this capability.
  <br></li>
</ul><p>A change that many people make is to put this command in their their startup file, <em>.bashrc</em> or <em>.profile</em>.
  <br></p>
<pre><font size="-1" face="Verdana, Arial, Helvetica, sans-serif">$<strong> PATH=$PATH:.</strong></font>
</pre>
<p>This adds the current directory (.) to the path, so that you can execute your own private commands from one of your directories by changing to the directory and typing the command name. Without this, you have to type <code>./command</code> to execute a command in the current directory. Some people consider this a security risk. Some prefer
  <br></p>
<p>
</p>
<pre><font><font size="-1" face="Verdana, Arial, Helvetica, sans-serif">$<strong> PATH=</strong></font></font><strong><font><font size="-1" face="Verdana, Arial, Helvetica, sans-serif">~/bin</font></font>:<font><font size="-1" face="Verdana, Arial, Helvetica, sans-serif">$PATH</font></font></strong>
</pre>
<p>so that they can execute scripts in a directory of their choosing that they own, and those scripts will take precedence over others of the same name. However they will not accidentally execute scripts randomly anywhere in the filesystem that they happen to be.
  <br></p>
<h2>ls
</h2>
<p>
</p>
<p><code>ls</code> is the command to list filenames.
</p>
<p>It can have options (Flags) added after the command with a minus sign "-".
  <br>Arguments (parameters) can also be added.
  <br></p>
<p>
  </p><table align="left" border="0" cellpadding="2" cellspacing="1"><tbody><tr><td>
      <p>$ ls
      </p></td>
      <td>ordinary file listing</td>
    </tr><tr><td>
      <p>$ ls | less
      </p></td>
      <td>pipe listing to less, which displays it a page at a time
      <br></td>
    </tr><tr><td>
      <p>$ ls &gt; filelist
      </p></td>
      <td>redirect listing to file named "filelist" </td>
    </tr><tr><td>
      <p>$ ls -l
      </p></td>
      <td>long file listing (file sizes, change times,..) </td>
    </tr><tr><td>
      <p>$ ls -a
      </p></td>
      <td>include filenames starting with ".", normally not listed </td>
    </tr><tr><td>
      <p>$ ls -l -a
      </p></td>
      <td>applies both the above options </td>
    </tr><tr><td>
      <p>$ ls -la
      </p></td>
      <td>equivalent to the previous command</td>
    </tr><tr><td>
      <p>$ ls *.fort
      </p></td>
      <td>list files called "ANYTHING.fort"</td>
    </tr><tr><td>
      <p>$ ls -lat *.fort
      </p></td>
      <td>the t means list them in time order, not alphabetically</td>
    </tr></tbody></table><p> 
</p>
<p>
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p>
  <br> 
  <br>These examples show the main points of all GNU/Linux commands.  They are short, they take options, they take parameters, you can user several options together, you can chain commands together with pipes, you can redirect the output of a command to a file.
</p>
<p>To list all files under a particular directory, use the <code>-R</code> option.
  <br></p>
<pre>$ <strong>ls -R</strong>
photos1 photos2 photos3

./photos1:
centraal_station.jpg    nieuwe_kerk.jpg

./photos2:
ica.jpeg                sanders_theater.jpeg

./photos3:
bayeux_cathedral.jpeg   rouen_cathedral.jpeg    travel.odt
</pre> The "R" stands for "recursive." Note that the recursive option is uppercase <code>-R</code> in the <code>ls</code> command (<code>-r</code> is used to reverse the ordering the directory contents), but can be either uppercase or lowercase in the <code>rm</code> command.
<h2>man, info
  <br></h2>
<p>Now that you know the basics of shell commands, use these often; you can learn almost anything you need from the ample (if terse) documentation they provide.
</p>
<p>You can get a summary of almost any GNU/Linux command with the <code>man</code> command or the more recently developed <code>info</code> command. If the <code>man</code> command doesn't work, it is probably because your shell can't find the manual pages. This requires you to set the variable MANPATH to the correct directories. To find the directories that contain manual pages, try the following command. It means "print directories that have the name <em>man</em>":
  <br></p>
<pre>$ <strong>find / -type d -name man -print </strong>
</pre>Manual pages follow a fairly rigid format. They start with a command synopsis, then list all the options and arguments to the command. Other sections that may be present include a short description; examples, overview, defaults, exit status, environment variables, and known bugs.
<p>Info presents similar material, but often with more detail, and split into several pages with navigation links.
</p>
<h2>apropos
</h2>
<p>The <code>apropos</code> command tells you about <code>man</code> files that contain any keyword you specify, including <code>man</code> pages about topics other than commands. You would have a hard time guessing the names of some of these topics without help from <code>apropos</code>.
</p>
<pre>$<strong> apropos -a samba password</strong>
smbpasswd (5)        - The Samba encrypted password file
</pre>
<h2>pwd
</h2>
<p>GNU/Linux has directories to help you organize your files. <code>pwd</code> tells you your "current working directory" or CWD. In directory specifications, "." stands for the current directory, and ".." for the parent directory. Paths starting with "/" are absolute, with no dependence on the current directory. Paths starting without a "/" are relative to the current directory.
  <br></p>
<p>An example directory name would be <em>/home/allen/handy/scripts</em>. The full name starts with a slash "/" and directory names are separated by slashes. This differs from Windows, which uses the backslash "\", and Macintosh, which uses ":".
</p>
<pre>$<strong> pwd</strong>
/home/myname
</pre>
<h2>cd
</h2>
<p>Changes your CWD.
</p>
<p>
  </p><table align="left" border="0" cellpadding="4" cellspacing="1" width="611" height="210"><tbody><tr><td>$ cd</td>
      <td>change to your "home directory"</td>
    </tr><tr><td>$ cd  ..</td>
      <td>takes you to the parent directory, for example from
      <br>/usr/lib to /usr</td>
    </tr><tr><td>$ cd Docs</td>
      <td>change to documents directory in current directory,
      <br>if there is one (uses relative path) </td>
    </tr><tr><td>$ cd  /usr/lib</td>
      <td>takes you to the dir "/usr/lib" from anywhere (uses absolute
      <br>path)</td>
    </tr><tr><td>$ cd /</td>
      <td>The root directory - there are none above this. </td>
    </tr></tbody></table><p> 
</p>
<p>
</p>
<p>Your "home directory" is the one you log in to. It is defined in the file <em>/etc/passwd</em> (unless some special network system is in use, in which case it is found in the output from <code>ypcat passwd</code>).
</p>
<h2>mkdir
</h2>
<p>Make a directory.
</p>
<pre>$<strong> mkdir mydirectory</strong>
</pre>
<h2>rmdir
</h2>
<p>Remove a directory.
</p>
<pre>$<strong> rmdir mydirectory</strong>
</pre>
<h2>touch
</h2>
<p>If a file exists, this updates its modification date and time. If there is no such file, it is created with nothing in it.
</p>
<pre>$<strong> touch newfile</strong>
</pre>
<h2>rm
</h2>
<p>This command removes files (and directories).
  <br></p>
<p><em>By default, you get no second chance, and once files are gone they are irretrievable.</em> A nasty joke sometimes played on Newbies is to suggest "<code>rm -r *</code>" as the remedy for whatever problem they have. Don't try this unless you want to install a new operating system from scratch anyway, and you have a complete, current backup.
  <br></p>
<p>
  </p><table align="left" border="0" cellpadding="2" cellspacing="1"><tbody><tr><td>$ rm     filename(s) </td>
      <td> </td>
    </tr><tr><td>$ rm -r  filename(s)</td>
      <td>Remove directories and all their contents.  </td>
    </tr><tr><td>$ rm -i  filename(s)</td>
      <td>Prompt for a y/n choice before each file (recommended!)</td>
    </tr><tr><td>$ rm -f  filename(s)</td>
      <td>
      <p>Do not complain if the file does not exist.
        <br>Also overrides the -i flag.
      </p></td>
    </tr></tbody></table><p>
  <br></p>
<p>
  <br><br><br><br><br> 
  <br></p>
<h2>ln
</h2>
<p>Make hard links or symbolic (aka "soft") links to files. Both hard links and soft links are references to other files. If you don't know what an "inode" is, stick with using soft links. (Even if you <em>do</em> know what an inode is, chances are good that you will use soft links the vast majority of the time).
</p>
<p>A soft link is a special type of file that serves as an alias to another file (or directory) -- same basic concept as "desktop shortcuts" in Windows, where you have a shortcut icon on your desktop that points to a program, file, or folder that is located elsewhere on your computer.  The file or directory that the link points to is called the "target" of the link.
</p>
<p>When using <code>ln</code>, remember to include the <code>-s</code> option to choose soft type of link, and put the path to the target <em>before</em> the destination path for the new link.
  <br></p>
<p>To create a soft link named "linkname" pointing to a target named "file":
  <br></p>
<pre>$<strong> ln -s file linkname
</strong></pre>
<p>To create links in the current directory (also known as ".") that point to files in ending in ".so" located in the <em>../lib</em> directory, giving the soft links the same names as the original files:
</p>
<pre>$<strong> ln -s ../lib/*.so .</strong>
</pre>
<h2>cp
</h2>
<p>This command copies files.
</p>
<p>
  </p><table align="left" border="0" cellpadding="4" cellspacing="1"><tbody><tr><td>$ cp file1 file2</td>
      <td>
      <p>Copies file1 over file2, if it exists.
        <br>Creates file2 if it did not exist.
        <br></p></td>
    </tr><tr><td>$ cp /etc /home/allen     
      <br></td>
      <td>Copies  /etc to /home/allen/etc</td>
    </tr><tr><td>$ cp -r mydir mynewdir</td>
      <td>
      <p>With the -r flag, copies directories too
        <br></p></td>
    </tr></tbody></table><p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<h2>mv
</h2>
<p>This moves and renames files and directories.
</p>
<p>
  </p><table align="left" border="0" cellpadding="4" cellspacing="1"><tbody><tr><td>$ mv file2 file3</td>
      <td>Renames a file or directory
      <br></td>
    </tr><tr><td>$ mv /home/allen/etc /tmp</td>
      <td>Moves a file or directory</td>
    </tr></tbody></table><br><br><h2>whoami
</h2>
<p>This tells you your id name, for example, "allen"
</p>
<p>So you can type
</p>
<pre>$<strong> grep `whoami` /etc/passwd</strong>
</pre>
<p>to see your home directory and some other things.
</p>
<pre>allen:!:5037:1:P. Allan:/u/allen:/bin/csh
</pre>
<p>The <code>grep</code> command is used to search for strings in text files.
</p>
<p>The backticks `` cause execution of the command inside. The result, in this case "allen", is substituted in the outer command, exactly as if the user had typed <code>grep allen /etc/passwd</code>.
  <br></p>
<p>The ! in the second field tells the computer that the encrypted password is held in another file.  This makes it a bit harder for dishonest people to get hold of your password.
</p>
<h2>passwd
</h2>
<p>This should be one of the first commands you use when given a new id.  It sets your password, and can do a few other things too.  You will be prompted for the old password (if any) and will be asked for the new password twice. (length = 8 characters)
</p>
<p> EXAMPLE
</p>
<pre>$<strong> passwd</strong>
Changing password for "allen"
allen's Old password:
allen's New password:
Enter the new password again:
$
</pre>
<p>There are restrictions on what you can choose, but they are in <em>/etc/security</em> and so not readable!
</p>
<p>Good passwords are hard to guess, but also hard to remember.  It is best to use all 8 characters and include at least one of [a-z], [A-Z] and [0-9].  There are programs around that guess many passwords, so it is unwise to use any passwords based on names, real words, the user id, the hostname, or other guessable strings.
</p>
<h2>exit
</h2>
<p>This stops your session or just one window (if in a window). <code>exit</code> detects jobs that are paused (by <strong>Ctrl + z</strong> for instance) because they would die if you used <code>exit</code>.  Type <code>exit</code> a second time if you are happy with that. Running background jobs continue.
</p>
<p>When using a graphical interface, a menu accessed with the mouse can be used to end your whole session. Window managers are not built into GNU/Linux, and vary greatly.
</p>
<h2>ps
</h2>
<p>Get a list of running processes. By default, <code>ps</code> lists only processes in the current shell. To get a list of all of your processes, use <code>ps -e</code>.
  <br></p>
<pre>$<strong> ps</strong>
  PID TTY          TIME CMD
29477 pts/0    00:00:00 bash
29811 pts/0    00:00:00 ps</pre>
<h2>kill
</h2>
<p>Terminate a running process without allowing it to complete. Particularly useful if a program has gotten into an infinite loop in which it does not receive or process keyboard input.
</p>
<pre>$<strong> kill 29477</strong>
</pre>
<p>Kills the process with Process ID 29477. In the <code>ps</code> example above, this would be the current shell.
  <br></p>
<h2>chown
</h2>
<p>Every file has an owner and a group, as you can see with the <code>ls</code> command. You should have a group named the same as your account. The Change Owner command, <code>chown</code>, lets you set these ownership attributes for files that you have the right to write.
  <br></p>
<p> You can give an entire group permission to read, write, or execute files with one command. If you want to keep files private, set the group to consist only of you, and use <code>chmod</code> (below) to restrict access by others. The following assumes that, when your user account was created, a group just for you with the same name was created. This is true on many modern systems, but not on all.
  <br></p>
<pre>$<strong> chown user:user myfile</strong></pre>
<p>If you have imported some directories that came in with the wrong ownership, you can change them all with one command. Just <code>cd</code> to the top directory, and execute this command, with the appropriate user and group names. The <code>-R</code> option tells <code>chown</code> to go through every subdirectory, and the * wildcard tells it to change ownership of every file and directory it finds there.
  <br></p>
<pre>$<strong> chown -R user:group *</strong>
</pre>
<h2>chmod
</h2>
<p>Every file and directory has a "filemode" consisting of a list of attributes.
</p>
<p>You can see this with <code>ls -l</code>.
</p>
<pre>$<strong> cd ; ls -la</strong>
</pre>
<p>The ";" separates two commands on the same line.
</p>
<p>That shows you the modes of the files in your home directory.
</p>
<p>Included in the list should be two entries called "." and "..",  which refer to your current directory and its parent.
</p>
<p>You will see a set of characters showing the file's permissions, followed by the owner (your ID, probably, for all except ..) and the group (perhaps "staff"), a file size, the time and date of the last change to the file, and the name. The listing will resemble the following:
</p>
<pre>total 312
drwxr-x---  16 allen    staff       1024 Oct 21 14:07 .
drwxr-xr-x  21 sys      sys          512 Oct 13 16:25 ..
-rwxr-----   1 allen    staff        896 Oct 20 14:44 .cshrc
drwx------   2 allen    staff        512 Oct  6 08:51 .elm
-rw-r--r--   1 allen    staff         59 Oct 17 13:59 .exrc
-rwxr-----   1 allen    staff        461 Oct 17 12:18 .login
...
</pre>
<p>A "d" in column 1 means the entry is a directory. A "-" means it is a file.
</p>
<p>See the manual page for <code>ls</code>, under the <code>-l</code> option, for other possible file types.
</p>
<p>There are 9 other characters in 3 sets of 3.
</p>
<p>Columns 2-4  are for the file's OWNER.  (named later on the line, "allen" in this case)
</p>
<p>Columns 5-7  are for the file's GROUP.  (named later on the line, "staff" in this case)
</p>
<p>Columns 8-10 are for everyone else, except the superuser who always has all permissions.
</p>
<ul><li>"r" grants read permission. </li>
  <li>"w" grants write permission. </li>
  <li>"x" grants execute permission. For a directory, this means search permission.</li>
  <li>"-" denies the permission in that location. </li>
</ul><p>See <code>man ls</code> under the <code>-l</code> flag for other possible modes. Notice that write permission on a directory allows you to remove files from that directory <em>even if you do not own the files.</em>
</p>
<pre>chmod 640     file1   # sets file1 to -rw-r-----
chmod 755     file2   # sets file2 to -rwxr-xr-x
chmod go=     file3   # sets file3 to -???-------  (removes group &amp; other)
chmod -R go-w $HOME   # GOOD SAFE COMMAND: only you can write in your home dir
</pre>
<h2>more, less, pg, cat
</h2>
<p>These commands allow you to look at text files.
  <br></p>
<pre>$<strong> more .bashrc</strong>
$<strong> less /etc/motd</strong>
$<strong> cat /etc/fstab</strong>
</pre>
<p>The <code>more</code>, <code>less</code>, and <code>pg</code> commands allow you to page through a file and search for strings. The <code>less</code> command ironically has somewhat more options than more.
</p>
<p>When in a <code>more</code>, <code>less</code>, or <code>pg</code> session type the <strong>h</strong> key to see what commands you can use.
</p>
<p>The <code>cat</code> command displays the entire file, so it is good only for files that fit on one or two screens. The original purpose of <code>cat</code> (catenate) is to join text files together, but it is extremely useful for displaying short individual files.
</p>
<pre>$<strong> cat file1 file2 &gt; file3</strong>
</pre>
<h2>grep
</h2>
<p>Find and display lines in one or more files. The earliest version, grep, is named after a common command form in an early line editor, Global Regular Expression Print, which searched through an entire file for text patterns and displayed the matching lines. Regular expressions, described in another section of this manual, provide methods for specifying text patterns. Options permit searching groups of files, including all subdirectories of the starting point. One of the most common uses of grep is to find lines in configuration and log files specific to one user or one program.
  <br></p>
<pre>$<strong> grep `whoami` /etc/passwd</strong></pre>
<p>looks for the result of the <code>whoami</code> command in the password file, returning the user's account information, though with the password obscured.
  <br></p>
<h2>df
</h2>
<p>Disk Free. Show sizes of storage media, space used, and space available. Shows sizes in blocks (a size that varies from one filesystem to another) by default, so use the <code>-h</code> option to get sizes in "human-readable" form: K for thousands of bytes, M for millions of bytes, and G for billions of bytes.
</p>
<p>
</p>
<pre>$<strong> df -h</strong>
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             143G   41G   96G  30% /
tmpfs                 941M     0  941M   0% /lib/init/rw
varrun                941M  380K  941M   1% /var/run
varlock               941M     0  941M   0% /var/lock
udev                  941M  2.7M  939M   1% /dev
tmpfs                 941M  844K  940M   1% /dev/shm
lrm                   941M  2.4M  939M   1% /lib/modules/2.6.27-11-generic/volatile</pre>
<h2>echo
</h2>
<p>Repeat after me, with substitutions if desired. Literal echoes are quite useful in scripts.
</p>
<pre>$<strong> echo "Hello, world."</strong>
Hello, world.
$<strong> echo $PATH</strong>
/home/myname/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
</pre>
<h2>file
</h2>
<p>This makes an attempt to recognize files, classifying them as English Text or executable or data.
  <br>type
</p>
<pre>$<strong> file * | less</strong></pre>
<p> to see some examples.
</p>
<table align="left" border="0" cellpadding="2" cellspacing="1" width="441" height="190"><tbody><tr><td>
    <p>XLF:
    </p></td>
    <td>
    <p>ascii text
    </p></td>
  </tr><tr><td>
    <p>doc:
    </p></td>
    <td>
    <p>directory
    </p></td>
  </tr><tr><td>
    <p>handy:
    </p></td>
    <td>
    <p>directory
    </p></td>
  </tr><tr><td>
    <p>groceries:
    </p></td>
    <td>
    <p>ascii text
    </p></td>
  </tr><tr><td>
    <p>.Xauthority:
    </p></td>
    <td>
    <p>data or International Language text
    </p></td>
  </tr><tr><td>
    <p>.cshrc:
    </p></td>
    <td>
    <p>commands text
    </p></td>
  </tr><tr><td>
    <p>.exrc:
    </p></td>
    <td>
    <p>English text
    </p></td>
  </tr></tbody></table><p>
</p>
<p> 
</p>
<p>
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<h2>diff
</h2>
<p>Differences between two text files. It also tells you whether two binary files differ.
</p>
<pre>$<strong> diff .profile~ .profile</strong>
 23a22
&gt; scim -d &amp;
</pre>
<p>This says that line 23 was added (in this case, to support typing in multiple languages and character sets), and shows the new contents of the line.
  <br></p>
<h2>wc
</h2>Word counts, plus line and character counts.
<pre>$<strong> wc .login
</strong>6       7     461 .login
</pre>
<p>This <em>.login</em> file has 6 lines, 7 words, and 461 characters.
</p>
<p>The program counts any string of printing characters between whitespace as a word, which can give strange results by human standards.
  <br></p>
<h2>find
</h2>
<p>To list all files or directories named <em>core</em> under the current working directory:
</p>
<pre>$<strong> find . -name core -ls</strong></pre>
<p>To remove all files named <em>core</em> under the current working directory (useful because programs create these files when they terminate through a programming error, but the files are of little value to you unless you possess and can read the source code):
</p>
<pre>$<strong> find . -name core -exec rm {} \;</strong>
</pre>
<p> To list all files or directories named <em>"something</em>.core" under the current working directory:
</p>
<pre>$<strong> find . -name '*.core' -ls</strong>
</pre>
<p>To name all directories called <em>man</em> under <em>/usr</em>:
</p>
<pre>$<strong> find /usr -name man -type d -print</strong>
</pre>
<p>The next 2 examples are useful for removing temporary files you no longer want.
</p>
<pre>$<strong> find /tmp /var/tmp -mtime +3 -type f -user allen -exec rm {} \;</strong>
$<strong> find /var/preserve -mtime +8 -type f -user allen -exec rm {} \;</strong>
</pre>
<p>The next example names files and directories which <em>either</em> have changed in the last 2 days, <em>or</em> have execute permission for the owner.
</p>
<pre>$<strong> find . \( -mtime -2  -o -perm -100 \) -print</strong>
</pre>Checking what has changed during the last few days is a great way to find out why your computer isn't working any more!
<br><h2>ftp
</h2>
<p>Upload and download files using File Transfer Protocol. Use:
</p>
<pre>$<strong> ftp hostname</strong>
</pre>
<p>to connect to the ftp archive at <em>hostname</em>. The FTP protocol specifies how to log in, navigate directories on the archive, upload and download files or groups of files, and much more. This summary gives you enough commands to navigate an archive and to download files (and upload them, if you have permission).
  <br></p>
<p>When you connect to a repository, you will see a &gt; prompt where you can enter commands.
</p>
<pre>&gt;<strong> binary</strong></pre>
<p>Set to binary mode, which passes every byte of the file unchanged. This should be the first command you give, unless you are absolutely certain that you will download only text files.
  <br></p>
<pre>&gt;<strong> ascii</strong>
</pre>
<p>Set to text mode, which converts line ends. This is the default when FTP starts. It is safe for text in ASCII, other 8-bit encodings, and Unicode UTF-8. <strong>Do not use for programs, images, music, and other binary files.</strong>
  <br></p>
<pre>&gt;<strong> dir</strong></pre>
<p>List files in the current directory on the remote host.
</p>
<pre>&gt;<strong> cd directory-name</strong>
</pre>
<p>Change directory.
  <br></p>
<pre>&gt;<strong> cdup</strong></pre>
<p>Change to the parent directory of the current directory on the remote host.
</p>
<pre>&gt;<strong> get remote-file [local-file]</strong>
</pre>
<p> Download a file and optionally rename it.
  <br></p>
<pre>&gt;<strong> put local-file [remote-file]</strong>
</pre>
<p>Upload a file and optionally rename it.
  <br></p>
<pre>&gt;<strong> bye</strong></pre>
<p>End the <code>ftp</code> session.
  <br></p>
<h2>wget
</h2>
<p>Download files from the Internet reliably, even over unreliable connections. If the connection goes down during a download, <code>wget</code> can resume from where it left off when the connection comes back up. 
</p>
<pre>$<strong> wget URL</strong></pre>
<p> will download the file at the URL to the current directory, using the same name. There are, as you would expect, numerous options.
</p>
<h2>tar
</h2>
<p>The Tape Archive utility creates a single tar file containing the contents of one or more files, or extracts files from a tar file. Although originally designed to produce combinations of files for backup to tape, it is still the standard utility for packing together files so you can move them around as a unit. As an option, the files can be compressed in a tgz file.
  <br></p>
<p>
</p>
<pre>$<strong> tar -cf foo.tar foo/</strong></pre>
<p> Store contents of folder <em>foo</em> in <em>foo.tar</em>. The <code>-c</code> option creates a tar file. The <code>-f</code> option says to use the filename given. Without <code>-f</code>, the result would go to standard output. You can use this form in a pipeline to use a different compression method, such as bzip2, described below.
  <br></p>
<pre>$<strong> tar -cvfz foo.tgz foo/</strong></pre>
<p> Store compressed contents of folder <em>foo</em> in <em>foo.tgz</em>, and give moderately verbose output on the console as each file is processed. More verbose output is available with the <code>vv</code> option.
</p>
<pre>$<strong> tar -xf foo.tar</strong></pre>
<p>Extract <em>foo.tar</em> in the current directory.
  <br><br></p>
<pre>$<strong> tar -xzf foo.tgz</strong></pre>
<p>Extract gzipped <em>foo.tgz</em>. The tgz extension is an abbreviation of the formerly common .tar.gz, used when combining files and compressing the result required piping the output of tar to the input of gzip.
  <br></p>
<h2>gzip, gunzip, zcat, bzip2, bunzip2, bzcat
</h2>
<p>The zip and bzip2 file compression algorithms are among the most popular of many ways to make files smaller (originally for transmission over slow modem connections), so that the inverse algorithms restore the full original files unchanged. Although the bzip2 method achieves better compression than zip, it also requires more processor time. For each one, we'll show a command for compression, decompression, and combining multiple files into one. The tar utility can use gzip compression.
  <br></p>
<pre>$<strong> gzip file</strong>
</pre>
<p>or
</p>
<pre>$<strong> bzip2 file </strong></pre>
<p>compresses a file into an archive. The name of the archive file is the same as the original file, with the extension ".gz" or ".bz2" added. 
</p>
<pre>$<strong> gunzip file.gz</strong></pre>
<p>Decompress the <em>file.gz</em> archive to the original file.
  <br></p>
<p>The <code>gunzip</code> command is equivalent to <code>gzip -d</code>, where the <code>-d</code> option stands for "decompress". Similarly, <code>bunzip2</code> is equivalent to <code>bzip2 -d</code>.
</p>
<p>The <code>zcat</code> utility is equivalent to <code>gunzip  -c</code>, where the <code>-c</code> option says to write the uncompressed results into a single file. This is frequently useful when a directory contains a number of compressed text files. For example,
</p>
<pre>$<strong> zcat *.txt.gz </strong></pre>
<p>
</p>
<p>Combining the output into one file makes it easier to search. You could pipe the output of this command to <code>grep</code>, for example. Similarly, <code>bzcat</code> is equivalent to <code>bzip2 -c</code>.
</p>
<h2>Lynx
</h2>
<p>The World-Wide Web is so widely used that some people think it is the entire Internet, but originally the Web was designed to use only text, and there are several text browsers for it still in use. Lynx (a pun on "links") remains popular among those who spend more time at the command line or inside Emacs than in a GUI.
</p>
<p>A text browser can simply ignore any material marked with HTML tags that refer to graphical content, or can display the ALT text that is often supplied with images, both for the sake of text browsers and for the blind and visually impaired.
  <br></p>
<pre>$<strong> lynx <em>url</em></strong></pre>
<p>starts Lynx. If you specify a URL, Lynx will start with that page. Otherwise, it will go to its current default home page, which you can set to point wherever you like.
</p>
<p>The following table gives you enough commands to use Lynx, but there are many more.
</p>
<p>
  </p><table border="1" cellpadding="1" cellspacing="1" width="376" height="540"><tbody><tr><td> ?</td>
      <td> Help
      <br></td>
    </tr><tr><td> K</td>
      <td> List commands
      <br></td>
    </tr><tr><td>+</td>
      <td> Scroll down one screen
      <br></td>
    </tr><tr><td> -</td>
      <td> Scroll up one screen
      <br></td>
    </tr><tr><td> ↓</td>
      <td> Next link
      <br></td>
    </tr><tr><td> ↑</td>
      <td> Previous link
      <br></td>
    </tr><tr><td> Return or →
      <br></td>
      <td> Follow link
      <br></td>
    </tr><tr><td> ←</td>
      <td> Back</td>
    </tr><tr><td> a</td>
      <td> Add current link as bookmark
      <br></td>
    </tr><tr><td> d</td>
      <td> Download current link to file
      <br></td>
    </tr><tr><td> g</td>
      <td> Go to URL
      <br></td>
    </tr><tr><td> o</td>
      <td> Set options
      <br></td>
    </tr><tr><td> p</td>
      <td> Print</td>
    </tr><tr><td> s</td>
      <td> Search</td>
    </tr><tr><td> v</td>
      <td> View bookmarks
      <br></td>
    </tr><tr><td> q</td>
      <td> Quit Lynx.
      <br></td>
    </tr></tbody></table><br><h2>Midnight Commander
</h2>
<p> The Midnight Commander (mc) is based on concepts from the Norton Commander for PCDOS, which provides a two-pane file browser, and puts many DOS commands on function keys and menus. For GNU/Linux, of course, mc offers GNU/Linux commands in a text terminal window. The command to start it is, of course, <code>mc</code>.
</p>
<pre>$<strong> mc</strong></pre>
<p>The screen shot below shows a typical display in Midnight Commnander. You will have a different directory structure and different files.
</p>
<p><img alt="Midnight Commander" src="static/IntroCommandLine-Midnight_Commander-mc-en.png" width="600" height="450"></p>
<p>You can navigate using either the mouse or the keyboard. <strong>Tab</strong> moves you to the other panel. The <strong>Insert</strong> key highlights files and directories for actions such as copy, rename, move, and delete, which you can see on the function key buttons, or for various commands on the pull-down menus.
</p>
<p>The Left and Right menus let you change views to give different information, to enter a regular expression that determines which files to display, or to sort in a different order, among other things. You can invoke FTP from either of these menus, and use Midnight Commander's file commands to upload and download files. The File menu includes commands such as chmod and chown, with a visual dialog for selecting options and on-screen help, as shown in the screenshot below.
</p>
<p><img title="chmod" alt="chmod" src="static/IntroCommandLine-Midnight_Commander-chmod-en.png" align="left" width="657" height="452"></p>
<p> 
</p>
<p>The Commander provides hints, as in the screenshot above, to alert you to useful functions that you might not discover on your own. This one is particularly useful. Setting this configuration option lets you use the left and right arrow keys to navigate between directories, in the same way that Lynx lets you navigate URLs. There are a great many more configuration options available.
  <br></p>
<p>You can set and access bookmarks on a Directory Hotlist within your file system using the <strong>Ctrl + \</strong> key combination, or by selecting the list on the Commands menu. The dialog lets you create and navigate between named bookmark lists.
</p>
<p>There is a great deal more to Midnight Commander, of course. You can learn about other functions in the Help dialog (<strong>F1</strong>).
  <br></p>
<h2>emacs, vi, nano, pico
</h2>
<p>There is a wide choice of text editors to serve a variety of needs. One of the most venerable is Emacs (originally Editing Macros; jocularly Escape, Meta, Alt, Control, Shift, for its profusion of keyboard commands), written in LISP, with the ability to add commands in LISP, and to change any key bindings for commands. It includes the ability to run external commands, including mail and news (Usenet) readers and compilers, so some users do everything from emacs. Some prefer vi (visual editor), which has a similar ability to add commands and change key bindings, but does not replace the command line for its users. Others still, including most of those who do not program for a living, prefer simpler editors such as nano and pico.
</p>
<p>In each case, one can invoke an editor and have it load up a file ready to edit in the form
</p>
<pre>$<strong> editor filename</strong>
</pre>
<p>Consult specific program documentation for other command-line options and for editing commands and the rest. For example,
  <br></p>
<p><a href="http://www.gnu.org/software/emacs/">http://www.gnu.org/software/emacs/</a> 
  <br></p>
<p> <a href="http://www.ccsf.edu/Pub/Fac/vi.html">http://www.ccsf.edu/Pub/Fac/vi.html</a> 
</p>
<p><a href="http://www.nano-editor.org">http://www.nano-editor.org/</a> 
  <br></p>
<p><a href="http://www.itd.umich.edu/itcsdocs/r1168/">http://www.itd.umich.edu/itcsdocs/r1168/</a> 
  <br></p>
<h2>pr
</h2>
<p>This adds titles and page numbers to your text files.
  <br></p>
<pre>$<strong> pr /etc/sendmail.cf | less  </strong>
</pre>
<p>Keep pressing enter to watch the file go past slowly. You can also use <strong>Page Up</strong> and <strong>Page Down</strong> keys, and arrow keys.
</p>
<h2>lpr
</h2>
<p>prints a file. Useful for plain text, and can print some other formats (notably PostScript and PDF) if the system has printer drivers that understand those formats.
</p>
<pre>$<strong> lpr .profile</strong>
</pre>
<h2>split
  <br></h2>
<p>Suppose you have a 600MB ISO file you'd like to split into several pieces for easier storage. You can do so with:
</p>
<pre>$<strong> split -b 200m image.iso image_iso_</strong></pre>
<p>This example generates three files named <em>image.iso_aa</em>, <em>image.iso_ab</em>, and <em>image.iso_ac</em>, each 200MB in size. If you want to join them again, use the command:
</p>
<pre>$<strong> cat image.iso_* &gt; new-image.iso</strong></pre>
<p> Remember, the more you practice, the easier and more efficient you can work. Experiment with these commands --the only way to get better at using them is practice!
</p>
</body></html>
   

</div>
</div>

  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

