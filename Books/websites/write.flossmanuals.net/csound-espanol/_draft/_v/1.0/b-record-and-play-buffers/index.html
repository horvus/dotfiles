
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: B-Record-And-Play-Buffers / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter B. RECORD AND PLAY BUFFERS" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter B. RECORD AND PLAY BUFFERS" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <p>RECORD AND PLAY BUFFERS</p>
<p>RECORD Y PLAY BUFFERS</p>
<p>Playing Audio From RAM - flooper2</p>
<p>Reproducci&oacute;n de audio desde RAM - flooper2</p>
<p>Csound offers many opcodes for playing back sound files that have first been loaded into a function table (and therefore are loaded into RAM). Some of these offer higher quality at the expense of computation speed; some are simpler and less fully featured.</p>
<p>Csound ofrece muchos opcodes para reproducir archivos de sonido que primero se han cargado en una tabla de funciones (y por lo tanto se cargan en RAM). Algunos de estos ofrecen una mayor calidad a expensas de la velocidad de c&aacute;lculo; Algunos son m&aacute;s sencillos y menos completos.</p>
<p>One of the newer and easier to use opcodes for this task is flooper2. As its name might suggest it is intended for the playback of files with looping. 'flooper2' can also apply a cross-fade between the end and the beginning of the loop in order to smooth the transition where looping takes place.</p>
<p>Uno de los opcodes m&aacute;s nuevos y f&aacute;ciles de usar para esta tarea es flooper2. Como su nombre podr&iacute;a sugerir que est&aacute; destinado a la reproducci&oacute;n de archivos con bucle. Flooper2 tambi&eacute;n puede aplicar un cross-fade entre el final y el comienzo del bucle con el fin de suavizar la transici&oacute;n donde se realiza el bucle.</p>
<p>In the following example a sound file that has been loaded into a GEN01 function table is played back using 'flooper2'. 'flooper2' also includes a parameter for modulating playback speed/pitch. There is also the option of modulating the loop points at k-rate. In this example the entire file is simply played and looped. You can replace the sound file with one of your own or you can download the one used in the example from here.</p>
<p>En el ejemplo siguiente se reproduce un archivo de sonido que se ha cargado en una tabla de funciones GEN01 con flooper2. Flooper2 tambi&eacute;n incluye un par&aacute;metro para modular la velocidad / paso de reproducci&oacute;n. Tambi&eacute;n existe la opci&oacute;n de modular los puntos de lazo a la velocidad k. En este ejemplo, todo el archivo se reproduce y realiza un bucle. Puede reemplazar el archivo de sonido por uno propio o puede descargar el que se utiliza en el ejemplo desde aqu&iacute;.</p>
<p>Some notes about GEN01 and function table sizes:</p>
<p>Algunas notas sobre GEN01 y tama&ntilde;os de tabla de funciones:</p>
<p>When storing sound files in GEN01 function tables we must ensure that we define a table of sufficient size to store our sound file. Normally function table sizes should be powers of 2 (2, 4, 8, 16, 32 etc.). If we know the duration of our sound file, we can derive the required table size by multiplying this duration by the sample rate and then choosing the next power of 2 larger than this. For example when the sampling rate is 44100, we will require 44100 table locations to store 1 second of audio; but 44100 is not a power of 2 so we must choose the next power of 2 larger than this which is 65536. (Hint: you can discover a sound file's duration by using Csound's 'sndinfo' utility.)</p>
<p>Al almacenar archivos de sonido en tablas de funciones GEN01 debemos asegurarnos de que definimos una tabla de tama&ntilde;o suficiente para almacenar nuestro archivo de sonido. Normalmente los tama&ntilde;os de las tablas de funciones deben ser potencias de 2 (2, 4, 8, 16, 32 etc.). Si sabemos la duraci&oacute;n de nuestro archivo de sonido, podemos derivar el tama&ntilde;o de la tabla requerida multiplicando esta duraci&oacute;n por la frecuencia de muestreo y luego elegir la siguiente potencia de 2 mayor que &eacute;sta. Por ejemplo, cuando la velocidad de muestreo es 44100, requeriremos 44100 ubicaciones de tabla para almacenar 1 segundo de audio; Pero 44100 no es una potencia de 2, as&iacute; que debemos elegir la siguiente potencia de 2 m&aacute;s grande que esta, que es 65536. (Sugerencia: puedes descubrir una duraci&oacute;n de archivos de sonido utilizando la utilidad sndinfo de Csounds.)</p>
<p>There are some 'lazy' options however: if we underestimate the table size when we then run Csound, it will warn us that this table size is too small and conveniently inform us via the terminal what the minimum size required to store the entire file would be - we can then substitute this value in our GEN01 table. We can also overestimate the table size in which case Csound won't complain at all, but this is a rather inefficient approach.</p>
<p>Hay algunas opciones perezosas sin embargo: si subestimamos el tama&ntilde;o de la tabla cuando ejecutamos Csound, nos advertir&aacute; que este tama&ntilde;o de tabla es demasiado peque&ntilde;o y convenientemente nos informar&aacute; a trav&eacute;s del terminal cu&aacute;l ser&iacute;a el tama&ntilde;o m&iacute;nimo requerido para almacenar el archivo completo - Podemos entonces sustituir este valor en nuestra tabla GEN01. Tambi&eacute;n podemos sobrestimar el tama&ntilde;o de la tabla, en cuyo caso Csound no se quejar&aacute; en absoluto, pero este es un enfoque bastante ineficiente.</p>
<p>If we give table size a value of zero we have what is referred to as 'deferred table size'. This means that Csound will calculate the exact table size needed to store our sound file and use this as the table size but this will probably not be a power of 2. Many of Csound's opcodes will work quite happily with non-power of 2 function table sizes, but not all! It is a good idea to know how to deal with power of 2 table sizes. We can also explicitly define non-power of 2 table sizes by prefacing the table size with a minus sign '-'.</p>
<p>Si damos un tama&ntilde;o de tabla a un valor de cero tenemos lo que se conoce como tama&ntilde;o de tabla diferido. Esto significa que Csound calcular&aacute; el tama&ntilde;o exacto de la tabla necesario para almacenar nuestro archivo de sonido y usarlo como el tama&ntilde;o de la tabla, pero esto probablemente no ser&aacute; una potencia de 2. Muchos de los opcodes de Csounds funcionar&aacute;n con bastante alegr&iacute;a con la no potencia de la tabla de 2 funciones Tama&ntilde;os, pero no todos! Es una buena idea saber c&oacute;mo lidiar con el poder de 2 tama&ntilde;os de mesa. Tambi&eacute;n podemos definir expl&iacute;citamente la no potencia de 2 tama&ntilde;os de tablas prefiriendo el tama&ntilde;o de tabla con un signo menos -.</p>
<p>All of the above discussion about required table sizes assumed that the sound file was mono; to store a stereo sound file will naturally require twice the storage space, for example, 1 second of stereo audio will require 88200 storage locations. GEN01 will indeed store stereo sound files and many of Csound's opcodes will read from stereo GEN01 function tables, but again not all! We must be prepared to split stereo sound files, either to two sound files on disk or into two function tables using GEN01's 'channel' parameter (p8), depending on the opcodes we are using.</p>
<p>Toda la discusi&oacute;n anterior sobre los tama&ntilde;os de tabla requeridos supuso que el archivo de sonido era mono; Para almacenar un archivo de sonido est&eacute;reo naturalmente requerir&aacute; dos veces el espacio de almacenamiento, por ejemplo, 1 segundo de audio est&eacute;reo requerir&aacute; 88200 ubicaciones de almacenamiento. Gen01 de hecho almacenar&aacute; archivos de sonido est&eacute;reo y muchos de los opcodes de Csounds leer&aacute;n desde las tablas de funciones est&eacute;reo GEN01, pero &iexcl;de nuevo no todas! Debemos estar preparados para dividir los archivos de sonido est&eacute;reo, ya sea a dos archivos de sonido en disco o en dos tablas de funci&oacute;n usando el par&aacute;metro de canal GEN01 (p8), dependiendo de los c&oacute;digos de operaci&oacute;n que estamos usando.</p>
<p>Storing audio in GEN01 tables as mono channels with non-deferred and power of 2 table sizes will ensure maximum compatibility.</p>
<p>Almacenamiento de audio en tablas GEN01 como canales mono con no diferido y la potencia de 2 tama&ntilde;os de tabla garantizar&aacute; la m&aacute;xima compatibilidad.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B01_flooper2.csd</strong></em>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac ; activate real-time audio
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	
0dbfs   =       1

; STORE AUDIO IN RAM USING GEN01 FUNCTION TABLE
giSoundFile   ftgen   0, 0, 262144, 1, "loop.wav", 0, 0, 0

  instr	1 ; play audio from function table using flooper2 opcode
kAmp         =         1   ; amplitude
kPitch       =         p4  ; pitch/speed
kLoopStart   =         0   ; point where looping begins (in seconds)
kLoopEnd     =         nsamp(giSoundFile)/sr; loop end (end of file)
kCrossFade   =         0   ; cross-fade time
; read audio from the function table using the flooper2 opcode
aSig         flooper2  kAmp,kPitch,kLoopStart,kLoopEnd,kCrossFade,giSoundFile
             out       aSig ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p4 = pitch
; (sound file duration is 4.224)
i 1 0 [4.224*2] 1
i 1 + [4.224*2] 0.5
i 1 + [4.224*1] 2
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>&nbsp;</p>
<p>Csound's Built-in Record-Play Buffer - sndloop</p>
<p>Csounds Built-in Record-Play Buffer - sndloop</p>
<p>Csound has an opcode called sndloop which provides a simple method of recording some audio into a buffer and then playing it back immediately. The duration of audio storage required is defined when the opcode is initialized. In the following example two seconds is provided. Once activated, as soon as two seconds of live audio has been recorded by 'sndloop', it immediately begins playing it back in a loop. 'sndloop' allows us to modulate the speed/pitch of the played back audio as well as providing the option of defining a crossfade time between the end and the beginning of the loop. In the example pressing 'r' on the computer keyboard activates record followed by looped playback, pressing 's' stops record or playback, pressing '+' increases the speed and therefore the pitch of playback and pressing '-' decreases the speed/pitch of playback. If playback speed is reduced below zero it enters the negative domain, in which case playback will be reversed.</p>
<p>Csound tiene un c&oacute;digo de operaci&oacute;n llamado sndloop que proporciona un m&eacute;todo simple de grabar algo de audio en un b&uacute;fer y luego reproducirlo de inmediato. La duraci&oacute;n del almacenamiento de audio requerido se define cuando el c&oacute;digo de operaci&oacute;n se inicializa. En el ejemplo siguiente se proporcionan dos segundos. Una vez activado, tan pronto como dos segundos de audio en vivo ha sido grabado por sndloop, inmediatamente comienza a reproducir en un bucle. Sndloop nos permite modular la velocidad / tono del audio reproducido, as&iacute; como proporcionar la opci&oacute;n de definir un tiempo de crossfade entre el final y el inicio del bucle. En el ejemplo pulsando r en el teclado del ordenador se activa el registro seguido de la reproducci&oacute;n en bucle, pulsando s se detiene el registro o la reproducci&oacute;n, al pulsar se aumenta la velocidad y por lo tanto el tono de la reproducci&oacute;n y la presi&oacute;n - disminuye la velocidad / tono de la reproducci&oacute;n. Si la velocidad de reproducci&oacute;n se reduce por debajo de cero, entra en el dominio negativo, en cuyo caso la reproducci&oacute;n se invertir&aacute;.</p>
<p>You will need to have a microphone connected to your computer in order to use this example.</p>
<p>Necesitar&aacute; tener un micr&oacute;fono conectado a su computadora para poder usar este ejemplo.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B02_sndloop.csd</strong></em>&nbsp;&nbsp;</p>
<p><span style="font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;">&lt;CsoundSynthesizer&gt;</span></p>
<p><span style="font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;">&lt;CsOptions&gt;</span></p>
<pre>; real-time audio in and out are both activated
-iadc -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	

  instr	1
; PRINT INSTRUCTIONS
           prints  "Press 'r' to record, 's' to stop playback, "
           prints  "'+' to increase pitch, '-' to decrease pitch.\\n"
; SENSE KEYBOARD ACTIVITY
kKey sensekey; sense activity on the computer keyboard
aIn        inch    1             ; read audio from first input channel
kPitch     init    1             ; initialize pitch parameter
iDur       init    2             ; inititialize duration of loop parameter
iFade      init    0.05          ; initialize crossfade time parameter
 if kKey = 114 then              ; if 'r' has been pressed...
kTrig      =       1             ; set trigger to begin record-playback
 elseif kKey = 115 then          ; if 's' has been pressed...
kTrig      =       0             ; set trigger to turn off record-playback
 elseif kKey = 43 then           ; if '+' has been pressed...
kPitch     =       kPitch + 0.02 ; increment pitch parameter
 elseif kKey = 45 then           ; if '-' has been pressed
kPitch     =       kPitch - 0.02 ; decrement pitch parameter
 endif                           ; end of conditional branches
; CREATE SNDLOOP INSTANCE
aOut, kRec sndloop aIn, kPitch, kTrig, iDur, iFade ; (kRec output is not used)
           out     aOut          ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600 ; instr 1 plays for 1 hour
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>Recording to and Playback from a Function Table</p>
<p>Grabaci&oacute;n y reproducci&oacute;n desde una tabla de funciones</p>
<p>Writing to and reading from buffers can also be achieved through the use of Csound's opcodes for table reading and writing operations. Although the procedure is a little more complicated than that required for 'sndloop' it is ultimately more flexible. In the next example separate instruments are used for recording to the table and for playing back from the table. Another instrument which runs constantly scans for activity on the computer keyboard and activates the record or playback instruments accordingly. For writing to the table we will use the tablew opcode and for reading from the table we will use the table opcode (if we were to modulate the playback speed it would be better to use one of Csound's interpolating variations of 'table' such as tablei or table3.</p>
<p>La escritura y la lectura de b&uacute;feres tambi&eacute;n se pueden lograr mediante el uso de opcodes Csounds para operaciones de lectura y escritura de tablas. Aunque el procedimiento es un poco m&aacute;s complicado que el requerido para sndloop, es en &uacute;ltima instancia m&aacute;s flexible. En el siguiente ejemplo se utilizan instrumentos separados para grabar en la mesa y para reproducirlos desde la mesa. Otro instrumento que se ejecuta constantemente busca la actividad en el teclado del ordenador y activa los instrumentos de grabaci&oacute;n o reproducci&oacute;n en consecuencia. Para escribir en la tabla usaremos el opcode de la tabla y para leer de la tabla usaremos el opcode de la tabla (si tuvi&eacute;ramos que modular la velocidad de reproducci&oacute;n ser&iacute;a mejor usar una de Csounds interpolando variaciones de tabla como tablei o table3 .</p>
<p>Csound writes individual values to table locations, the exact table locations being defined by an 'index'. For writing continuous audio to a table this index will need to be continuously moving 1 location for every sample. This moving index (or 'pointer') can be created with an a-rate line or a phasor. The next example uses 'line'. When using Csound's table operation opcodes we first need to create that table, either in the orchestra header or in the score. The duration of the audio buffer can be calculated from the size of the table. In this example the table is 2^17 points long, that is 131072 points. The duration in seconds is this number divided by the sample rate which in our example is 44100Hz. Therefore maximum storage duration for this example is 131072/44100 which is around 2.9 seconds.</p>
<p>Csound escribe valores individuales en ubicaciones de tabla, defini&eacute;ndose las ubicaciones exactas de la tabla por un &iacute;ndice. Para escribir audio continuo en una tabla, este &iacute;ndice necesitar&aacute; mover continuamente 1 ubicaci&oacute;n para cada muestra. Este &iacute;ndice en movimiento (o puntero) se puede crear con una l&iacute;nea a-rate o un fasor. El siguiente ejemplo usa la l&iacute;nea. Cuando utilice los opcodes de operaciones de tabla de Csounds primero debemos crear esa tabla, ya sea en el encabezado de la orquesta o en la partitura. La duraci&oacute;n del b&uacute;fer de audio se puede calcular a partir del tama&ntilde;o de la tabla. En este ejemplo la tabla tiene 2 ^ 17 puntos de largo, es decir 131072 puntos. La duraci&oacute;n en segundos es este n&uacute;mero dividido por la frecuencia de muestreo que en nuestro ejemplo es 44100Hz. Por lo tanto, la duraci&oacute;n m&aacute;xima de almacenamiento para este ejemplo es 131072/44100, que es de alrededor de 2,9 segundos.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B03_RecPlayToTable.csd</strong></em>&nbsp; &nbsp; &nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
; real-time audio in and out are both activated
-iadc -odac -d -m0
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1

giBuffer ftgen  0, 0, 2^17, 7, 0; table for audio data storage
maxalloc 2,1 ; allow only one instance of the recording instrument at a time!

  instr	1 ; Sense keyboard activity. Trigger record or playback accordingly.
           prints  "Press 'r' to record, 'p' for playback.\\n"
iTableLen  =       ftlen(giBuffer)  ; derive buffer function table length
idur       =       iTableLen / sr   ; derive storage time in seconds
kKey sensekey                       ; sense activity on the computer keyboard
  if kKey=114 then                  ; if ASCCI value of 114 ('r') is output
event	"i", 2, 0, idur, iTableLen  ; activate recording instrument (2)
  endif
 if kKey=112 then                   ; if ASCCI value of 112 ('p) is output
event	"i", 3, 0, idur, iTableLen  ; activate playback instrument
 endif
  endin

  instr 2 ; record to buffer
iTableLen  =        p4              ; table/recording length in samples
; -- print progress information to terminal --
           prints   "recording"
           printks  ".", 0.25       ; print '.' every quarter of a second
krelease   release                  ; sense when note is in final k-rate pass...
 if krelease=1 then                 ; then ..
           printks  "\\ndone\\n", 0 ; ... print a message
 endif
; -- write audio to table --
ain        inch     1               ; read audio from live input channel 1
andx       line     0,p3,iTableLen  ; create an index for writing to table
           tablew   ain,andx,giBuffer ; write audio to function table
endin

  instr 3 ; playback from buffer
iTableLen  =        p4              ; table/recording length in samples
; -- print progress information to terminal --
           prints   "playback"
           printks  ".", 0.25       ; print '.' every quarter of a second
krelease   release                  ; sense when note is in final k-rate pass
 if krelease=1 then                 ; then ...
           printks  "\\ndone\\n", 0 ; ... print a message
 endif; end of conditional branch
; -- read audio from table --
aNdx       line     0, p3, iTableLen; create an index for reading from table
a1         table    aNdx, giBuffer  ; read audio to audio storage table
           out      a1              ; send audio to output
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3600 ; Sense keyboard activity. Start recording - playback.
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Encapsulating Record and Play Buffer Functionality to a UDO</p>
<p>Encapsulando la Funci&oacute;n de Buffer de Grabaci&oacute;n y Reproducci&oacute;n en un UDO</p>
<p>Recording and playing back of buffers can also be encapsulated into a User Defined Opcode. This time the tabw opcode will be used for writing audio data to a buffer. tabw is slightly faster than tablew but doesn't offer the same number of protections for out of range index values.</p>
<p>La grabaci&oacute;n y reproducci&oacute;n de b&uacute;feres tambi&eacute;n se pueden encapsular en un c&oacute;digo de usuario definido por el usuario. Esta vez, el opcode tabw se utilizar&aacute; para escribir datos de audio en un b&uacute;fer. Tabw es ligeramente m&aacute;s r&aacute;pido que tablew pero no ofrece el mismo n&uacute;mero de protecciones para valores de &iacute;ndice fuera de rango.</p>
<p>An empty table (buffer) of any size can be created with a negative number as size. A table for recording 10 seconds of audio data can be created in this way:</p>
<p>Se puede crear una tabla vac&iacute;a (buffer) de cualquier tama&ntilde;o con un n&uacute;mero negativo como tama&ntilde;o. De esta manera se puede crear una tabla para grabar 10 segundos de datos de audio:</p>
<p>giBuf1&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp; 0, 0, -(10*sr), 2, 0</p>
<p>The user can decide whether they want to assign a certain number to the table, or whether to allow Csound do assign one automatically, thereafter calling the table via its variable name, in this case giBuf1. Below follows a UDO for creating a mono buffer, and another UDO for creating a stereo buffer:</p>
<p>El usuario puede decidir si desea asignar un cierto n&uacute;mero a la tabla, o si permite que Csound asignar uno autom&aacute;ticamente, despu&eacute;s llamando a la tabla a trav&eacute;s de su nombre de variable, en este caso giBuf1. A continuaci&oacute;n se muestra un UDO para crear un buffer mono y otro UDO para crear un buffer est&eacute;reo:</p>
<p>opcode BufCrt1, i, io</p>
<pre>ilen, inum xin
ift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp; inum, 0, -(ilen*sr), 2, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ift
&nbsp;endop

&nbsp;opcode BufCrt2, ii, io
ilen, inum xin
iftL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp; inum, 0, -(ilen*sr), 2, 0
iftR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp; inum, 0, -(ilen*sr), 2, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iftL, iftR
&nbsp;endop&nbsp;
</pre>
<p>This simplifies the procedure of creating a record/play buffer, because the user is just asked for the length of the buffer. A number can be given, but by default Csound will assign this number. This statement will create an empty stereo table for 5 seconds of recording:</p>
<p>Esto simplifica el procedimiento de creaci&oacute;n de un b&uacute;fer de grabaci&oacute;n / reproducci&oacute;n, ya que se pide al usuario la longitud del b&uacute;fer. Se puede dar un n&uacute;mero, pero por defecto Csound asignar&aacute; este n&uacute;mero. Esta declaraci&oacute;n crear&aacute; una tabla est&eacute;reo vac&iacute;a durante 5 segundos de grabaci&oacute;n:</p>
<p>iBufL,iBufR BufCrt2&nbsp;&nbsp; 5</p>
<p>A first, simple version of a UDO for recording will just write the incoming audio to sequential locations of the table. This can be done by setting the ksmps value to 1 inside this UDO (setksmps 1), so that each audio sample has its own discrete k-value. In this way the write index for the table can be assigned via the statement andx=kndx, and increased by one for the next k-cycle. An additional k-input turns recording on and off:</p>
<p>Una primera versi&oacute;n simple de un UDO para la grabaci&oacute;n s&oacute;lo escribir&aacute; el audio entrante a ubicaciones secuenciales de la tabla. Esto puede hacerse ajustando el valor ksmps a 1 dentro de este UDO (setksmps 1), de manera que cada muestra de audio tenga su propio valor k discreto. De esta manera se puede asignar el &iacute;ndice de escritura de la tabla mediante la sentencia yx = kndx, y se incrementa en uno para el siguiente ciclo k. Una entrada k adicional activa y desactiva la grabaci&oacute;n:</p>
<p>opcode BufRec1, 0, aik</p>
<pre>ain, ift, krec&nbsp; xin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setksmps&nbsp; 1
if krec == 1 then ;record as long as krec=1
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
andx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tabw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ain, andx, ift
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx+1
endif
&nbsp;endop
</pre>
<p>The reading procedure is just as simple. In fact the same code can be used; it will be sufficient just to replace the opcode for writing (tabw) with the opcode for reading (tab):</p>
<p>El procedimiento de lectura es tan simple. De hecho, se puede utilizar el mismo c&oacute;digo; Bastar&aacute; con sustituir el opcode de escritura (tabw) por el opcode de lectura (tab):</p>
<p>opcode BufPlay1, a, ik</p>
<pre>ift, kplay&nbsp; xin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setksmps&nbsp; 1
if kplay == 1 then ;play as long as kplay=1
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
andx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx
aout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; andx, ift
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx+1
endif
&nbsp;endop
</pre>
<p>Next we will use these first simple UDOs in a Csound instrument. Press the "r" key as long as you want to record, and the "p" key for playing back. Note that you must disable the key repeats on your computer keyboard for this example (in QuteCsound, disable "Allow key repeats" in Configuration -&gt; General).</p>
<p>A continuaci&oacute;n vamos a utilizar estos primeros UDO simples en un instrumento Csound. Pulse la tecla r mientras desee grabar y la tecla p para reproducir. Tenga en cuenta que debe deshabilitar las repeticiones de teclas en el teclado del equipo para este ejemplo (en QuteCsound, deshabilitar Permitir repeticiones de clave en Configuraci&oacute;n - General).</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B04_BufRecPlay_UDO.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac -d -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example written by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  opcode BufCrt1, i, io
ilen, inum xin
ift       ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      ift
  endop

  opcode BufRec1, 0, aik
ain, ift, krec  xin
          setksmps  1
imaxindx  =         ftlen(ift)-1 ;max index to write
knew      changed   krec
if krec == 1 then ;record as long as krec=1
 if knew == 1 then ;reset index if restarted
kndx      =         0
 endif
kndx      =         (kndx &gt; imaxindx ? imaxindx : kndx)
andx      =         kndx
          tabw      ain, andx, ift
kndx      =         kndx+1
endif
  endop

  opcode BufPlay1, a, ik
ift, kplay  xin
          setksmps  1
imaxindx  =         ftlen(ift)-1 ;max index to read
knew      changed   kplay
if kplay == 1 then ;play as long as kplay=1
 if knew == 1 then ;reset index if restarted
kndx      =         0
 endif
kndx      =         (kndx &gt; imaxindx ? imaxindx : kndx)
andx      =         kndx
aout      tab       andx, ift
kndx      =         kndx+1
endif
          xout      aout
  endop

  opcode KeyStay, k, kkk
;returns 1 as long as a certain key is pressed
key, k0, kascii    xin ;ascii code of the key (e.g. 32 for space)
kprev     init      0 ;previous key value
kout      =         (key == kascii || (key == -1 &amp;&amp; kprev == kascii) ? 1 : 0)
kprev     =         (key &gt; 0 ? key : kprev)
kprev     =         (kprev == key &amp;&amp; k0 == 0 ? 0 : kprev)
          xout      kout
  endop

  opcode KeyStay2, kk, kk
;combines two KeyStay UDO's (this way is necessary
;because just one sensekey opcode is possible in an orchestra)
kasci1, kasci2 xin ;two ascii codes as input
key,k0    sensekey
kout1     KeyStay   key, k0, kasci1
kout2     KeyStay   key, k0, kasci2
          xout      kout1, kout2
  endop


instr 1
ain        inch      1 ;audio input on channel 1
iBuf       BufCrt1   3 ;buffer for 3 seconds of recording
kRec,kPlay KeyStay2  114, 112 ;define keys for record and play
           BufRec1   ain, iBuf, kRec ;record if kRec=1
aout       BufPlay1  iBuf, kPlay ;play if kPlay=1
           out       aout ;send out
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Next we will create an extended and easier to use version of these two UDOs for recording and playing back a buffer. The requirements of a user might be the following:</p>
<p>A continuaci&oacute;n crearemos una versi&oacute;n extendida y m&aacute;s f&aacute;cil de usar de estos dos UDOs para grabar y reproducir un buffer. Los requisitos de un usuario pueden ser los siguientes:</p>
<p>Recording:</p>
<p>Grabaci&oacute;n:</p>
<p>&nbsp;</p>
<p>allow recording not just from the beginning of the buffer, but also from any arbitrary starting point kstart</p>
<p>Permiten grabar no s&oacute;lo desde el principio del buffer, sino tambi&eacute;n desde cualquier punto de inicio arbitrario kstart</p>
<p>allow circular recording (wrap around) if the end of the buffer has been reached: kwrap=1</p>
<p>Permiten la grabaci&oacute;n circular (envolvente) si se ha alcanzado el final del buffer: kwrap = 1</p>
<p>Playing:</p>
<p>Jugando:</p>
<p>play back with different speed kspeed (negative speed means playing backwards)</p>
<p>Reproducir con velocidad diferente kspeed (velocidad negativa significa reproducir hacia atr&aacute;s)</p>
<p>start playback at any point of the buffer kstart</p>
<p>Iniciar la reproducci&oacute;n en cualquier punto de la memoria intermedia kstart</p>
<p>end playback at any point of the buffer kend</p>
<p>Final en cualquier punto de la memoria intermedia</p>
<p>allow certain modes of wraparound kwrap while playing:</p>
<p>Permiten ciertos modos de envolvente kwrap durante la reproducci&oacute;n:</p>
<p>kwrap=0 stops at the defined end point of the buffer</p>
<p>Kwrap = 0 se detiene en el punto final definido del buffer</p>
<p>kwrap=1 repeats playback between defined end and start points</p>
<p>Kwrap = 1 repite la reproducci&oacute;n entre los puntos finales y de inicio definidos</p>
<p>kwrap=2 starts at a defined starting point but wraps between end point and beginning of the buffer</p>
<p>Kwrap = 2 comienza en un punto de partida definido pero envuelve entre el punto final y el comienzo del buffer</p>
<ul>
<ul>
<li>kwrap=3 wraps between kstart and the end of the table</li>
<li>Kwrap = 3 envuelve entre kstart y el final de la tabla</li>
</ul>
</ul>
<p>The following example provides versions of BufRec and BufPlay which do this job. We will use the table3 opcode instead of the simple tab or table opcodes in this case, because we want to translate any number of samples in the table to any number of output samples using different speed values. In short, we will need to read amplitude values that must be 'imagined' between two existing table value.</p>
<p>El siguiente ejemplo proporciona versiones de BufRec y BufPlay que realizan este trabajo. En este caso, utilizaremos el opcode table3 en lugar de los opcodes simples de tabulaci&oacute;n o tabla, porque queremos traducir cualquier n&uacute;mero de muestras en la tabla a cualquier n&uacute;mero de muestras de salida usando diferentes valores de velocidad. En resumen, tendremos que leer valores de amplitud que deben imaginarse entre dos valores de tabla existentes.</p>
<p><img src="/csound/_v/1.0/http://en.flossmanuals.net/floss/pub/Csound/" alt="" width="0" height="0" /></p>
<p><img title="101124table3" src="static/Csound-Picts-06_Samples-101124table3-en.png" alt="101124table3" width="605" height="643" />&nbsp;</p>
<p>For higher or lower speed values than the original record speed, interpolation must be used in between certain sample values if the original shape of the wave is to be reproduced as accurately as possible. This job is performed with high quality by table3 which employs cubic interpolation.</p>
<p>Para valores de velocidad m&aacute;s alta o m&aacute;s baja que la velocidad de registro original, la interpolaci&oacute;n se debe utilizar entre ciertos valores de muestra si la forma original de la onda se va a reproducir con la mayor exactitud posible. Este trabajo se realiza con alta calidad por table3 que emplea interpolaci&oacute;n c&uacute;bica.</p>
<p>In a typical application of recording and playing buffer buffers, the ability to interact with the process will be paramount. We can benefit from having interactive access to the following:</p>
<p>En una aplicaci&oacute;n t&iacute;pica de almacenar y de almacenar amortiguadores del almacenador intermediario, la capacidad de obrar rec&iacute;procamente con el proceso ser&aacute; suprema. Podemos beneficiarnos de tener acceso interactivo a lo siguiente:</p>
<p>starting and stopping record</p>
<p>Iniciar y detener el registro</p>
<p>adjusting the start and end points of recording</p>
<p>Ajustar los puntos de inicio y fin de la grabaci&oacute;n</p>
<p>use or prevent wraparound while recording</p>
<p>Utilizar o evitar el envolvente durante la grabaci&oacute;n</p>
<p>starting and stopping playback</p>
<p>Iniciar y detener la reproducci&oacute;n</p>
<p>adjusting the start and end points of playback</p>
<p>Ajustar los puntos inicial y final de la reproducci&oacute;n</p>
<p>adjusting wraparound in playback using one of the specified modes (1 - 4)</p>
<p>Ajustar el envolvente en la reproducci&oacute;n utilizando uno de los modos especificados (1 - 4)</p>
<p>applying volume control to the playback signal</p>
<p>Aplicar el control de volumen a la se&ntilde;al de reproducci&oacute;n</p>
<p>These interactions could be carried out via widgets, MIDI, OSC or something else. As we want to provide examples which can be used with any Csound frontend here, we are restricted to triggering the record and play events by hitting the space bar of the computer keyboard. (See the CsoundQt version of this example for a more interactive version.)</p>
<p>Estas interacciones podr&iacute;an llevarse a cabo a trav&eacute;s de widgets, MIDI, OSC o cualquier otra cosa. Como queremos proporcionar ejemplos que se pueden utilizar con cualquier frontend Csound aqu&iacute;, estamos limitados a activar los eventos de grabaci&oacute;n y reproducci&oacute;n pulsando la barra espaciadora del teclado del ordenador. (Vea la versi&oacute;n CsoundQt de este ejemplo para una versi&oacute;n m&aacute;s interactiva.)</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B05_BufRecPlay_complex.csd</strong></em>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example written by joachim heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  opcode BufCrt2, ii, io ;creates a stereo buffer
ilen, inum xin ;ilen = length of the buffer (table) in seconds
iftL      ftgen     inum, 0, -(ilen*sr), 2, 0
iftR      ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      iftL, iftR
  endop

  opcode BufRec1, k, aikkkk ;records to a buffer
ain, ift, krec, kstart, kend, kwrap xin
		setksmps	1
kendsmps	=		kend*sr ;end point in samples
kendsmps	=		(kendsmps == 0 || kendsmps &gt; ftlen(ift) ? ftlen(ift) : kendsmps)
kfinished	=		0
knew		changed	krec ;1 if record just started
 if krec == 1 then
  if knew == 1 then
kndx		=		kstart * sr - 1 ;first index to write
  endif
  if kndx &gt;= kendsmps-1 &amp;&amp; kwrap == 1 then
kndx		=		-1
  endif
  if kndx &lt; kendsmps-1 then
kndx		=		kndx + 1
andx		=		kndx
		tabw		ain, andx, ift
  else
kfinished	=		1
  endif
 endif
 		xout		kfinished
  endop

  opcode BufRec2, k, aaiikkkk ;records to a stereo buffer
ainL, ainR, iftL, iftR, krec, kstart, kend, kwrap xin
kfin      BufRec1     ainL, iftL, krec, kstart, kend, kwrap
kfin      BufRec1     ainR, iftR, krec, kstart, kend, kwrap
          xout        kfin
  endop

  opcode BufPlay1, ak, ikkkkkk
ift, kplay, kspeed, kvol, kstart, kend, kwrap xin
;kstart = begin of playing the buffer in seconds
;kend = end of playing in seconds. 0 means the end of the table
;kwrap = 0: no wrapping. stops at kend (positive speed) or kstart
;  (negative speed).this makes just sense if the direction does not
;  change and you just want to play the table once
;kwrap = 1: wraps between kstart and kend
;kwrap = 2: wraps between 0 and kend
;kwrap = 3: wraps between kstart and end of table
;CALCULATE BASIC VALUES
kfin		init		0
iftlen		=		ftlen(ift)/sr ;ftlength in seconds
kend		=		(kend == 0 ? iftlen : kend) ;kend=0 means end of table
kstart01	=		kstart/iftlen ;start in 0-1 range
kend01		=		kend/iftlen ;end in 0-1 range
kfqbas		=		(1/iftlen) * kspeed ;basic phasor frequency
;DIFFERENT BEHAVIOUR DEPENDING ON WRAP:
if kplay == 1 &amp;&amp; kfin == 0 then
 ;1. STOP AT START- OR ENDPOINT IF NO WRAPPING REQUIRED (kwrap=0)
 if kwrap == 0 then
; -- phasor freq so that 0-1 values match distance start-end
kfqrel		=		kfqbas / (kend01-kstart01)
andxrel	phasor 	kfqrel ;index 0-1 for distance start-end
; -- final index for reading the table (0-1)
andx		=		andxrel * (kend01-kstart01) + (kstart01)
kfirst		init		1 ;don't check condition below at the first k-cycle (always true)
kndx		downsamp	andx
kprevndx	init		0
 ;end of table check:
  ;for positive speed, check if this index is lower than the previous one
  if kfirst == 0 &amp;&amp; kspeed &gt; 0 &amp;&amp; kndx &lt; kprevndx then
kfin		=		1
 ;for negative speed, check if this index is higher than the previous one
  else
kprevndx	=		(kprevndx == kstart01 ? kend01 : kprevndx)
   if kfirst == 0 &amp;&amp; kspeed &lt; 0 &amp;&amp; kndx &gt; kprevndx then
kfin		=		1
   endif
kfirst		=		0 ;end of first cycle in wrap = 0
  endif
 ;sound out if end of table has not yet reached
asig		table3		andx, ift, 1	
kprevndx	=		kndx ;next previous is this index
 ;2. WRAP BETWEEN START AND END (kwrap=1)
 elseif kwrap == 1 then
kfqrel		=		kfqbas / (kend01-kstart01) ;same as for kwarp=0
andxrel	phasor 	kfqrel
andx		=		andxrel * (kend01-kstart01) + (kstart01)
asig		table3		andx, ift, 1	;sound out
 ;3. START AT kstart BUT WRAP BETWEEN 0 AND END (kwrap=2)
 elseif kwrap == 2 then
kw2first	init		1
  if kw2first == 1 then ;at first k-cycle:
		reinit		wrap3phs ;reinitialize for getting the correct start phase
kw2first	=		0
  endif
kfqrel		=		kfqbas / kend01 ;phasor freq so that 0-1 values match distance start-end
wrap3phs:
andxrel	phasor 	kfqrel, i(kstart01) ;index 0-1 for distance start-end
		rireturn	;end of reinitialization
andx		=		andxrel * kend01 ;final index for reading the table
asig		table3		andx, ift, 1	;sound out
 ;4. WRAP BETWEEN kstart AND END OF TABLE(kwrap=3)
 elseif kwrap == 3 then
kfqrel		=		kfqbas / (1-kstart01) ;phasor freq so that 0-1 values match distance start-end
andxrel	phasor 	kfqrel ;index 0-1 for distance start-end
andx		=		andxrel * (1-kstart01) + kstart01 ;final index for reading the table
asig		table3		andx, ift, 1	
 endif
else ;if either not started or finished at wrap=0
asig		=		0 ;don't produce any sound
endif
  		xout		asig*kvol, kfin
  endop

  opcode BufPlay2, aak, iikkkkkk ;plays a stereo buffer
iftL, iftR, kplay, kspeed, kvol, kstart, kend, kwrap xin
aL,kfin   BufPlay1     iftL, kplay, kspeed, kvol, kstart, kend, kwrap
aR,kfin   BufPlay1     iftR, kplay, kspeed, kvol, kstart, kend, kwrap
          xout         aL, aR, kfin
  endop

  opcode In2, aa, kk ;stereo audio input
kchn1, kchn2 xin
ain1      inch      kchn1
ain2      inch      kchn2
          xout      ain1, ain2
  endop

  opcode Key, kk, k
;returns '1' just in the k-cycle a certain key has been pressed (kdown)
;  or released (kup)
kascii    xin ;ascii code of the key (e.g. 32 for space)
key,k0    sensekey
knew      changed   key
kdown     =         (key == kascii &amp;&amp; knew == 1 &amp;&amp; k0 == 1 ? 1 : 0)
kup       =         (key == kascii &amp;&amp; knew == 1 &amp;&amp; k0 == 0 ? 1 : 0)
          xout      kdown, kup
  endop

instr 1
giftL,giftR BufCrt2   3 ;creates a stereo buffer for 3 seconds
gainL,gainR In2     1,2 ;read input channels 1 and 2 and write as global audio
          prints    "PLEASE PRESS THE SPACE BAR ONCE AND GIVE AUDIO INPUT
                     ON CHANNELS 1 AND 2.\n"
          prints    "AUDIO WILL BE RECORDED AND THEN AUTOMATICALLY PLAYED
                     BACK IN SEVERAL MANNERS.\n"
krec,k0   Key       32
 if krec == 1 then
          event     "i", 2, 0, 10
 endif
endin

instr 2
; -- records the whole buffer and returns 1 at the end
kfin      BufRec2   gainL, gainR, giftL, giftR, 1, 0, 0, 0
  if kfin == 0 then
          printks   "Recording!\n", 1
  endif
 if kfin == 1 then
ispeed    random    -2, 2
istart    random    0, 1
iend      random    2, 3
iwrap     random    0, 1.999
iwrap     =         int(iwrap)
printks "Playing back with speed = %.3f, start = %.3f, end = %.3f,
                    wrap = %d\n", p3, ispeed, istart, iend, iwrap
aL,aR,kf  BufPlay2  giftL, giftR, 1, ispeed, 1, istart, iend, iwrap
  if kf == 0 then
          printks   "Playing!\n", 1
  endif
 endif
krel      release
 if kfin == 1 &amp;&amp; kf == 1 || krel == 1 then
          printks   "PRESS SPACE BAR AGAIN!\n", p3
          turnoff
 endif
          outs      aL, aR
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>&nbsp;</p>
<p>Further Opcodes for Investigation</p>
<p>&nbsp;</p>
<p>Opcodes adicionales para la investigaci&oacute;n</p>
<p>Csound contains a wide range of opcodes that offer a variety of 'ready-made' methods of playing back audio held in a function table. The oldest group of these opcodes are loscil and loscil3. Despite their age they offer some unique features such as the ability implement both sustain and release stage looping (in a variety of looping modes), their ability to read from stereo as well as mono function tables and their ability to read looping and base frequency data from the sound file stored in the function table. loscil and loscil3 were originally intended as the kernel mechanism for building a sampler.</p>
<p>Csound contiene una amplia gama de opcodes que ofrecen una variedad de m&eacute;todos listos para reproducir el audio contenido en una tabla de funciones. El grupo m&aacute;s antiguo de estos opcodes son loscil y loscil3. A pesar de su edad que ofrecen algunas caracter&iacute;sticas &uacute;nicas, tales como la capacidad de implementar tanto mantener y liberar la etapa de bucle (en una variedad de modos de bucle), su capacidad de leer desde est&eacute;reo, as&iacute; como tablas de funci&oacute;n mono y su capacidad de leer bucle y frecuencia base de datos Desde el archivo de sonido almacenado en la tabla de funciones. Loscil y loscil3 fueron originalmente concebidos como el mecanismo n&uacute;cleo para la construcci&oacute;n de un muestreador.</p>
<p>For reading multichannel files of more than two channels, the more recent loscilx exists as an option.</p>
<p>Para leer archivos multicanal de m&aacute;s de dos canales, el loscilx m&aacute;s reciente existe como una opci&oacute;n.</p>
<p>loscil and loscil3 will only allow looping points to be defined at i-time. lposcil, lposcil3, lposcila, lposcilsa and lposcilsa2 will allow looping points to be changed a k-rate, while the note is playing.</p>
<p>Loscil y loscil3 s&oacute;lo permitir&aacute;n que los puntos de bucle sean definidos en i-time. Lposcil, lposcil3, lposcila, lposcilsa y lposcilsa2 permitir&aacute;n que los puntos de bucle sean cambiados a k-rate, mientras que la nota est&aacute; jugando.</p>
<p>It is worth not forgetting Csound's more exotic methods of playback of sample stored in function tables. mincer and temposcal use streaming vocoder techniques to faciliate independent pitch and time-stretch control during playback (this area is covered more fully in the chapter FOURIER ANALYSIS / SPECTRAL PROCESSING. sndwarp and sndwarpst similiarly faciliate independent pitch and playback speed control but through the technique of granular synthesis this area is covered in detail in the chapter GRANULAR SYNTHESIS.</p>
<p>Vale la pena no olvidar Csounds m&aacute;s ex&oacute;ticos m&eacute;todos de reproducci&oacute;n de la muestra almacenada en las tablas de funciones. Mincer y temposcal utilizan t&eacute;cnicas de vocoder de flujo continuo para facilitar el control independiente del tono y el tiempo de estiramiento durante la reproducci&oacute;n (esta &aacute;rea se cubre con m&aacute;s detalle en el cap&iacute;tulo AN&Aacute;LISIS DE FOURIER / SPECTRAL PROCESSING) sndwarp y sndwarpst facilitan similarmente el control independiente de la velocidad de reproducci&oacute;n y reproducci&oacute;n. S&iacute;ntesis granular esta &aacute;rea se describe en detalle en el cap&iacute;tulo S&Iacute;NTESIS GRANULAR.</p>
<p>&nbsp;</p>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

