
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: A-Initialization-And-Performance-Pass / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <h1>PASADAS DE INICIALIZACI&Oacute;N Y EJECUCI&Oacute;N</h1>
<p>No s&oacute;lo para los principiantes, sino tambi&eacute;n para los usuarios experimentados de Csound, muchos de los problemas que se presentan son producto de malentendidos respecto de los llamados ciclos-i y ciclos-k. Por ejemplo, cuando se desea que Csound haga algo por &uacute;nica vez, pero Csound lo hace repetidamente. O a la inversa, cuando se quiere que Csound haga algo continuadamente, pero lo hace s&oacute;lo una vez. Si experimenta estos s&iacute;ntomas, lo m&aacute;s probable es que haya confundido las variables de ciclo-i con las de ciclo-k.</p>
<p>El modelo conceptual que sustenta esto en verdad no es tan complicado. Cuando pensamos en el flujo de un programa, esto es algo que se menciona impl&iacute;citamente, pero en Csound es necesario hacerlo expl&iacute;cito. De este modo, cuando usamos Csound tendemos a olvidarlo y no notamos cuando inadvertidamente solicitamos al lenguaje convertir peras en manzanas. Este cap&iacute;tulo intenta explicar cuidadosamente la diferencia entre las peras y las manzanas, y c&oacute;mo se puede sacar provecho de ellas, despu&eacute;s de haber comprendido y aceptado la naturaleza diferente de ambas.<br />&nbsp;</p>
<h2>La Pasada de Inicializaci&oacute;n</h2>
<p>Cuando se llama a un instrumento en Csound en todas las variables se establecen valores iniciales. Esto se denomina pasada de inicializaci&oacute;n.</p>
<p>Hay ciertas variables que permanecen en el estado en el que han sido puestas por la pasada de inicializaci&oacute;n. Dichas variables comienzan con la letra <strong>i</strong> si son locales (esto es, s&oacute;lo significan algo dentro de un instrumento), o con el prefijo <strong>gi</strong> si son globales (es decir, cuyo nombre es visible desde cualquier lugar dentro de la Orquesta). Este es un ejemplo sencillo:</p>
<p>&nbsp;&nbsp;&nbsp; <em><strong>EXAMPLE 03A01_Init-pass.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;

giGlobal   =          1/2

instr 1
iLocal     =          1/4
           print      giGlobal, iLocal
endin

instr 2
iLocal     =          1/5
           print      giGlobal, iLocal
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;ejemplo por joachim heintz
</pre>
<p>La salida a consola deber&iacute;a incluir las siguientes l&iacute;neas: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">SECTION 1: <br />new alloc for instr 1: <br />instr 1:&nbsp; giGlobal = 0.500&nbsp; iLocal = 0.250 <br />new alloc for instr 2: <br />instr 2:&nbsp; giGlobal = 0.500&nbsp; iLocal = 0.200 </span></p>
<p><span id="InsertNoteID_6_marker7" class="InsertNoteMarker">Como se ve, las variables locales <em>iLocal</em> tienen diferentes significados en el contexto de cada instrumento en particular, mientras que <em>giGlobal</em> es visible en todas partes y -a menos que se modifique- siempre mantiene su valor. Tambi&eacute;n vale la pena mencionar que la duraci&oacute;n de los instrumentos (p3) es igual a cero. Esto no es un error y en este ejemplo tiene sentido ya que los instrumentos son llamados, pero s&oacute;lo se realiza la pasada de incializaci&oacute;n. </span></p>
<h2>La Pasada de Ejecuci&oacute;n</h2>
<p>Despu&eacute;s de asignar valores iniciales a todas las variables, Csound inicia la ejecuci&oacute;n propiamente dicha. Como la m&uacute;sica es una variaci&oacute;n de los valores en el tiempo,<span id="InsertNoteID_8_marker9" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_8">2</a></sup></span> las se&ntilde;ales de audio constantemente est&aacute;n conteniendo valores que var&iacute;an en el tiempo. En todo audio digital, la unidad de tiempo viene dada por la tasa de muestreo, y una muestra es el &aacute;tomo de tiempo m&aacute;s peque&ntilde;o posible. Para una frecuencia de muestreo de 44100Hz,<span id="InsertNoteID_10_marker11" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_10">3</a></sup></span> una muestra posee una duraci&oacute;n de 1/44100 = 0,0000227 segundos.</p>
<p>Por lo tanto, la ejecuci&oacute;n en una aplicaci&oacute;n de audio significa b&aacute;sicamente: computar todas las muestras que se escribir&aacute;n finalmente en la salida. Esto se puede imaginar como la cooperaci&oacute;n entre un reloj y una calculadora. Para cada muestra, el reloj marca un tick y para cada tick, se calcula la siguiente muestra.</p>
<p>La mayor&iacute;a de las aplicaciones de audio no realizan este c&aacute;lculo de las muestras una por una. Es mucho m&aacute;s eficiente recolectar cierta cantidad de muestras en un "bloque" o "vector" y calcularlas todas juntas. Esto significa, de hecho, la utilizaci&oacute;n de otro reloj interno en su aplicaci&oacute;n; un reloj que marca los ticks con una frecuencia menor que el reloj que equivale a la tasa de muestreo. Por ejemplo, asumiendo que su frecuencia de muestreo es 44100 Hz, si el tama&ntilde;o de bloque consta de 10 muestras, el reloj interno que producir&aacute; cada bloque marcar&aacute; un tick cada 1/4410 = 0.000227 segundos. Si, en cambio, su tama&ntilde;o de bloque consta de 441 muestras, el reloj marcar&aacute; cada 1/100 = 0.01 segundos.</p>
<p>La ilustraci&oacute;n siguiente muestra un tama&ntilde;o de bloque de 10 muestras. Las muestras se il&uacute;stran en la l&iacute;nea inferior. Inmediatamente arriba se encuentran los ticks de control, uno por cada diez muestras. Las dos l&iacute;neas superiores muestran el tiempo de ambos relojes en segundos. En la l&iacute;nea superior se ve que el primer ciclo de control ha terminado a los 0,000227 segundos, el segundo a los 0,000454 segundos, y as&iacute; sucesivamente.<span id="InsertNoteID_28_marker29" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_28">4</a></sup></span></p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="static/03A_sr_kr_time3.png" alt="" width="769" height="261" /><br /><br />La tasa (frecuencia) de estos ticks se denomina tasa de control en Csound. Por una raz&oacute;n hist&oacute;rica,<span id="InsertNoteID_12_marker13" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_12">5</a></sup></span> se llama "tasa de kontrol" en lugar de "tasa de control", y por lo tanto se abrevia como kr en lugar de cr. Cada uno de los ciclos de c&aacute;lculo se denomina "ciclo-k". El tama&ntilde;o del bloque o tama&ntilde;o del vector viene dado en consecuencia por el par&aacute;metro <em>ksmps</em> que responde a la siguiente pregunta: &iquest;cu&aacute;ntas muestras (smps) se calculan para un ciclo-k?<span id="InsertNoteID_14_marker15" class="InsertNoteMarker">.<span id="InsertNoteID_14_marker15" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_14">6</a></sup></span></span></p>
<p>Veamos algunos ejemplos de c&oacute;digo para ilustrar estos contextos b&aacute;sicos.</p>
<h3>Incremento Impl&iacute;cito</h3>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A02_Perf-pass_incr.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
kCount&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0; set kcount to 0 first
kCount&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kCount + 1; increase at each k-pass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk&nbsp;&nbsp;&nbsp; 0, kCount; print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>La salida a consola deber&iacute;a contener estas l&iacute;neas: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.10000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.20000:&nbsp;&nbsp;&nbsp;&nbsp; 2.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.30000:&nbsp;&nbsp;&nbsp;&nbsp; 3.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.40000:&nbsp;&nbsp;&nbsp;&nbsp; 4.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.50000:&nbsp;&nbsp;&nbsp;&nbsp; 5.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.60000:&nbsp;&nbsp;&nbsp;&nbsp; 6.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.70000:&nbsp;&nbsp;&nbsp;&nbsp; 7.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.80000:&nbsp;&nbsp;&nbsp;&nbsp; 8.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.90000:&nbsp;&nbsp;&nbsp;&nbsp; 9.00000 <br />i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 1.00000:&nbsp;&nbsp;&nbsp; 10.00000 </span></p>
<p>Un contador (kCount) se establece en cero como valor inicial. Luego, en cada ciclo de control, el contador se incrementa en uno. Lo que se percibe entonces es el comportamiento t&iacute;pico de un bucle. El bucle no ha sido establecido de forma expl&iacute;cita, pero funciona impl&iacute;citamente a causa del rec&aacute;lculo continuo de todas las variables-k. De modo que tambi&eacute;n podemos hablar de los ciclos-k como si se tratara de un bucle-k impl&iacute;cito (y activado por un reloj).<span id="InsertNoteID_16_marker17" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_16">7</a></sup></span> Intente cambiar el valor de ksmps de 4410 a 8820 y luego a 2205 y observe la diferencia.</p>
<p>El siguiente ejemplo interpreta el incremento de <em>kCount</em> como el valor de una frecuencia en ascenso. El primer instrumento, denominado Rise, fija la frecuencia de ciclo-k <em>kFreq</em> al valor inicial de 100 Hz, y luego a&ntilde;ade 10 Hz en cada nuevo ciclo-k. Como ksmps = 441, un ciclo-k toma 1/100 de segundo para ejecutarse. As&iacute; que en 3 segundos, la frecuencia sube de 100 a 3100 Hz. En el &uacute;ltimo ciclo-k, se imprime el valor de la frecuencia final a la que se ha arribado.<span id="InsertNoteID_18_marker19" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_18">8</a></sup></span> - El segundo instrumento, Partials, incrementa el contador en uno por cada ciclo-k, pero s&oacute;lo lo considera como la nueva frecuencia por cada 100 repeticiones. De esta manera, la frecuencia se mantiene en 100 Hz durante un segundo, luego en 200 Hz durante otro segundo, y as&iacute; sucesivamente. Como las frecuencias resultantes est&aacute;n comprendidas en la relaci&oacute;n 1 : 2 : 3&nbsp; ..., escuchamos arm&oacute;nicos basados en una fundamental de 100 Hz, desde el primero hasta el 31&ordm;. El opcode printk2 imprime el valor de la frecuencia siempre y cuando &eacute;sta haya cambiado.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A03_Perf-pass_incr_listen.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441
0dbfs = 1
nchnls = 2

;build a table containing a sine wave
giSine&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 2^10, 10, 1

instr Rise
kFreq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100
aSine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poscil&nbsp;&nbsp;&nbsp;&nbsp; .2, kFreq, giSine
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aSine, aSine
;increment frequency by 10 Hz for each k-cycle
kFreq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kFreq + 10
;print out the frequency for the last k-cycle
kLast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release
&nbsp;if kLast == 1 then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk&nbsp;&nbsp;&nbsp;&nbsp; 0, kFreq
&nbsp;endif
endin

instr Partials
;initialize kCount
kCount&nbsp;&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100
;get new frequency if kCount equals 100, 200, ...
&nbsp;if kCount % 100 == 0 then
kFreq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kCount
&nbsp;endif
aSine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poscil&nbsp;&nbsp;&nbsp;&nbsp; .2, kFreq, giSine
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aSine, aSine
;increment kCount
kCount&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kCount + 1
;print out kFreq whenever it has changed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk2&nbsp;&nbsp;&nbsp; kFreq
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Rise" 0 3
i "Partials" 4 31
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<h3>Init vs. =</h3>
<p>Un error frecuente es establecer la variable-k utilizando <em>kCount = 0</em>, en lugar de <em>kCount init 0</em>. El significado de ambas sentencias tiene una diferencia significativa. <em>kCount init 0</em> establece el valor de kCount en cero s&oacute;lo durante la pasada de de inicializaci&oacute;n, sin afectarlo durante la pasada de ejecuci&oacute;n. <em>kCount = 1</em>, en cambio, establece el valor para kCount en cero una y otra vez, durante cada ciclo de ejecuci&oacute;n. De modo que el incremento comienza siempre desde el mismo punto, y en consecuencia el valor resultante se percibe como una constante luego del incremento:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A04_Perf-pass_no_incr.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
kcount&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0; sets kcount to 0 at each k-cycle
kcount&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kcount + 1; does not really increase ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk&nbsp;&nbsp;&nbsp; 0, kcount; print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Salida a consola: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.10000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.20000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.30000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.40000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.50000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.60000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.70000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.80000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 0.90000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp;&nbsp; 1 time&nbsp;&nbsp;&nbsp;&nbsp; 1.00000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000</span></p>
<h3>Una Mirada al Vector de Audio</h3>
<p>Hay diferentes opcodes para imprimir el contenido de las variables-k.<span id="InsertNoteID_20_marker21" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_20">9</a></sup></span> No existe un opcode en Csound para imprimir el contenido de un vector de audio directamente, pero se puede usar el opcode <em>vaget</em> para ver lo que acontece con las muestras de audio durante un ciclo de control.</p>
<p>&nbsp;&nbsp;&nbsp; <em><strong>EXAMPLE 03A05_Audio_vector.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 5
0dbfs = 1

instr 1
aSine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oscils&nbsp;&nbsp;&nbsp;&nbsp; 1, 2205, 0
kVec1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, aSine
kVec2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, aSine
kVec3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2, aSine
kVec4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3, aSine
kVec5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4, aSine
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printks&nbsp;&nbsp;&nbsp; "kVec1 = % f, kVec2 = % f, kVec3 = % f, kVec4 = % f, kVec5 = % f\n",\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, kVec1, kVec2, kVec3, kVec4, kVec5
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 [1/2205]
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>La salida a consola muestra estas l&iacute;neas: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">kVec1 =&nbsp; 0.000000, kVec2 =&nbsp; 0.309017, kVec3 =&nbsp; 0.587785, kVec4 =&nbsp; 0.809017, kVec5 =&nbsp; 0.951057 <br />kVec1 =&nbsp; 1.000000, kVec2 =&nbsp; 0.951057, kVec3 =&nbsp; 0.809017, kVec4 =&nbsp; 0.587785, kVec5 =&nbsp; 0.309017 <br />kVec1 = -0.000000, kVec2 = -0.309017, kVec3 = -0.587785, kVec4 = -0.809017, kVec5 = -0.951057 <br />kVec1 = -1.000000, kVec2 = -0.951057, kVec3 = -0.809017, kVec4 = -0.587785, kVec5 = -0.309017 </span></p>
<p>En este ejemplo, el n&uacute;mero de muestras de audio en un ciclo k se establece en cinco mediante la instrucci&oacute;n <em>ksmps = 5</em>. El primer argumento a vaget especifica qu&eacute; muestra del bloque obtendr&aacute;. Por ejemplo,</p>
<pre>kVec1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, aSine</pre>
<p>obtiene el primer valor del vector de audio y lo escribe en la variable kVec1. Para una frecuencia de 2205 Hz a una frecuencia de muestreo de 44100 Hz, se necesitan 20 muestras para escribir un ciclo completo de la sinusoide. Entonces llamamos al instrumento durante 1/2205 segundos, y obtenemos 4 ciclos-k. La impresi&oacute;n a consola muestra exactamente un per&iacute;odo de la onda sinusoidal.</p>
<h3>Un Ejemplo Que Resume lo Expuesto</h3>
<p>Despu&eacute;s de haber puesto tanta atenci&oacute;n a los diferentes aspectos de la inicializaci&oacute;n, de la ejecuci&oacute;n y de los vectores de audio, el siguiente ejemplo trata de resumir e ilustrar todos los aspectos seg&uacute;n su naturaleza pr&aacute;ctica.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A06_Init_perf_audio.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441
nchnls = 2
0dbfs = 1
instr 1
iAmp      =       p4 ;amplitude taken from the 4th parameter of the score line
iFreq     =       p5 ;frequency taken from the 5th parameter
; --- move from 0 to 1 in the duration of this instrument call (p3)
kPan      line      0, p3, 1
aNote     oscils  iAmp, iFreq, 0 ;create an audio signal
aL, aR    pan2    aNote, kPan ;let the signal move from left to right
          outs    aL, aR ;write it to the output
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3 0.2 443
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Como ksmps = 441, cada ciclo de control es de 0,01 segundos de longitud (441/44100). Esto es lo que ocurre cuando se realiza la llamada al instrumento:</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="InitAndPerfPass3" src="/csound/_edit/static/Csound-Picts-03_CsLanguage-InitAndPerfPass3-en.png" alt="InitAndPerfPass3" width="781" height="423" />&nbsp;</p>
<h2>Accediendo al Valor de Inicializaci&oacute;n de una Variable-k.</h2>
<p>Se ha dicho que la pasada de inicializaci&oacute;n establece valores iniciales para todas las variables. Debe enfatizarse que esto afecta de hecho a <strong>todas</strong> las variables y no s&oacute;lo a las variables-i. Es simplemente que las variables-i no se ven afectadas por nada que suceda con posterioridad, durante el tiempo de la ejecuci&oacute;n. Pero tambi&eacute;n las variables-k y las variables-a obtienen valores iniciales en la pasada de inicializaci&oacute;n.</p>
<p>Como vimos anteriormente, el opcode <em>init</em> se usa para establecer valores iniciales para variables-k y para variables-a expl&iacute;citamente. Por otro lado, puede obtener el valor inicial de una variable k que no ha sido definida de forma expl&iacute;cita utilizando la forma i(). Este es un ejemplo sencillo:</p>
<p>&nbsp;&nbsp;&nbsp; <em><strong>EXAMPLE 03A07_Init-values_of_k-variables.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
instr 1
gkLine line 0, p3, 1
endin
instr 2
iInstr2LineValue = i(gkLine)
print iInstr2LineValue
endin
instr 3
iInstr3LineValue = i(gkLine)
print iInstr3LineValue
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 2 0
i 3 4 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>Salida a consola: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">new alloc for instr 1: <br />B&nbsp; 0.000 ..&nbsp; 2.000 T&nbsp; 2.000 TT&nbsp; 2.000 M:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0 <br />new alloc for instr 2: <br />instr 2:&nbsp; iInstr2LineValue = 0.400 <br />B&nbsp; 2.000 ..&nbsp; 4.000 T&nbsp; 4.000 TT&nbsp; 4.000 M:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0 <br />new alloc for instr 3: <br />instr 3:&nbsp; iInstr3LineValue = 0.800 <br />B&nbsp; 4.000 ..&nbsp; 5.000 T&nbsp; 5.000 TT&nbsp; 5.000 M:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0 </span></p>
<p>El instrumento 1 produce una se&ntilde;al-k ascendente, comenzando en cero y terminando en uno, en un lapso de cinco segundos. Los valores del incremento de esta l&iacute;nea se escriben en la variable global <em>gkLine</em>. Despu&eacute;s de dos segundos, se llama al instrumento 2, y se examina el valor de <em>gkLine</em> durante su pasada de inicializaci&oacute;n (esto es, la del instrumento 2) v&iacute;a <em><strong>i</strong>(gkLine)</em>. El valor en este momento (0.4), se imprime a consola durante el tiempo-de-inicializaci&oacute;n&nbsp; como <em>iInstr2LineValue</em>. Lo mismo ocurre con el instrumento 3, que se llama reci&eacute;n a los 4 segundos y por lo tanto imprime el valor <em>iInstr3LineValue = 0.800</em>.</p>
<p>La forma i() es particularmente &uacute;til cuando se necesita examinar el valor de cualquier se&ntilde;al de control de un widget o de un dispositivo midi, en el momento en que se inicia un instrumento.</p>
<h2>Valores-k e Inicializaci&oacute;n en M&uacute;ltiples Llamadas a Instrumentos</h2>
<p>&iquest;Qu&eacute; sucede con una variable-k si un instrumento se llama varias veces? &iquest;Cu&aacute;l es el valor de inicializaci&oacute;n de esta variable en la primera llamada y en las llamadas posteriores?</p>
<p>Si esta variable no se establece expl&iacute;citamente, el valor de inicializaci&oacute;n durante la primera llamada de un instrumento es cero, tal como sucede usualmente. Pero para las llamadas siguientes la variable-k se inicializar&aacute; con el valor con el que qued&oacute; cuando se apag&oacute; la instancia anterior del mismo instrumento.</p>
<p>El ejemplo siguiente demuestra este comportamiento. El instrumento "Call" simplemente llama al instrumento "Called" una vez por segundo, y le env&iacute;a el n&uacute;mero de la llamada. El instrumento "Called" genera la variable kRndVal mediante el uso de un generador aleatorio, e informa sobre:</p>
<p>- el valor de kRndVal durante la inicializaci&oacute;n, y</p>
<p>- el valor de kRndVal durante el tiempo de ejecuci&oacute;n, es decir, durante el primer ciclo de control.</p>
<p>(Despu&eacute;s del primer ciclo-k, el instrumento se apaga inmediatamente.)</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A08_k-inits_in_multiple_calls_1.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

 instr Call
kNumCall init 1
kTrig metro 1
if kTrig == 1 then
  event "i", "Called", 0, 1, kNumCall
  kNumCall += 1
endif
 endin

 instr Called
iNumCall = p4
kRndVal random 0, 10
prints "Initialization value of kRnd in call %d = %.3f\n", iNumCall, i(kRndVal)
printks "  New random value of kRnd generated in call %d = %.3f\n", 0, iNumCall, kRndVal
turnoff
 endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Call" 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>La salida a consola deber&iacute;a mostrar algo similar a esto:</p>
<p><span style="font-family: 'courier new', courier, monospace; font-size: small;">Initialization value of kRnd in call 1 = 0.000 <br />&nbsp; New random value of kRnd generated in call 1 = 8.829 <br />Initialization value of kRnd in call 2 = 8.829 <br />&nbsp; New random value of kRnd generated in call 2 = 2.913 <br />Initialization value of kRnd in call 3 = 2.913 <br />&nbsp; New random value of kRnd generated in call 3 = 9.257 </span></p>
<p>La impresi&oacute;n muestra lo que se mencionaba anteriormente: si no hay un valor anterior para una variable-k, la variable se inicializa con valor cero. Si hay un valor anterior, &eacute;ste sirve como valor de inicializaci&oacute;n.</p>
<p>Pero &iquest;guarda alguna relevancia&nbsp; este valor de inicializaci&oacute;n de las variables-k? En realidad, elegimos un valor de k porque queremos usarlo en el tiempo de ejecuci&oacute;n, no en el tiempo de init. El problema es que Csound&nbsp; *realizar&aacute;* la pasada-de-inicializaci&oacute;n para todas las variables k- (y a-), a menos que se le impida de hacerlo expl&iacute;citamente. Y si, por ejemplo, se genera el &iacute;ndice de un vector en la instancia anterior del mismo instrumento, que est&aacute; fuera de rango en la inicializaci&oacute;n, Csound reportar&aacute; un error o incluso fallar&aacute;:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A09_<em><strong>k-inits_in_multiple_calls_2</strong></em>.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

gkArray[] fillarray 1, 2, 3, 5, 8

instr Call
kNumCall init 1
kTrig metro 1
if kTrig == 1 then
  event "i", "Called", 0, 1, kNumCall
  kNumCall += 1
endif
endin

instr Called
  ;get the number of the instrument instance
iNumCall = p4
  ;set the start index for the while-loop
kIndex = 0
  ;get the init value of kIndex
prints "Initialization value of kIndx in call %d = %d\n", iNumCall, i(kIndex)
  ;perform the while-loop until kIndex equals five
while kIndex &lt; lenarray(gkArray) do
  printf "Index %d of gkArray has value %d\n", kIndex+1, kIndex, gkArray[kIndex]
  kIndex += 1
od
  ;last value of kIndex is 5 because of increment
printks "  Last value of kIndex in call %d = %d\n", 0, iNumCall, kIndex
  ;turn this instance off after first k-cycle
turnoff
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Call" 0 1 ;change performance time to 2 to get an error!
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Cuando cambie el tiempo de ejecuci&oacute;n a 2 en lugar de 1, obtendr&aacute; un error, ya que se le pedir&aacute; al vector que devuelva el valor de &iacute;ndice=5. (Pero, como la longitud del vector es 5, el &uacute;ltimo &iacute;ndice posible es 4). Esta ser&aacute; la salida en este caso:</p>
<p>&nbsp;</p>
<p><span style="font-size: small;"><span style="font-family: 'courier new', courier, monospace;">Initialization value of kIndx in call 1 = 0 <br />Index 0 of gkArray has value 1 <br />Index 1 of gkArray has value 2 <br />Index 2 of gkArray has value 3 <br />Index 3 of gkArray has value 5 <br />Index 4 of gkArray has value 8 <br />&nbsp; Last value of kIndex in call 1 = 5 <br />Initialization value of kIndx in call 2 = 5 <br />PERF ERROR in instr 2: Array index 5 out of range (0,4) for dimension 1 <br />&nbsp;&nbsp; note aborted <br /></span></span></p>
<p>El problema es que la expresi&oacute;n gkArray [kIndex] se ejecuta *durante el tiempo de inicializaci&oacute;n*. Asimismo la expresi&oacute;n kIndex=0 no tiene ning&uacute;n efecto en absoluto para el valor de kIndex *duante el tiempo de inicializaci&oacute;n*. Si queremos estar seguros de que kIndex es cero tambi&eacute;n en init-time, debemos escribir esto de forma expl&iacute;cita</p>
<p>&nbsp;kIndex init 0</p>
<p>Tenga en cuenta que esto es *exactamente* lo mismo para los Opcodes Definidos por el Usuario (UDOs)! Si se llama a un UDO dos veces, en la segunda llamada las variables-k tendr&aacute;n como valor inicial el &uacute;ltimo valor de la primera llamada, a menos que inicialice la variable-k explicitamente mediante una instrucci&oacute;n init.</p>
<p>El &uacute;ltimo ejemplo muestra ambas posibilidades, utilizando la inicializaci&oacute;n expl&iacute;cita o no, y el efecto resultante.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A10_k-inits_in_multiple_calls_3.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

instr without_init
prints "instr without_init, call %d:\n", p4
kVal = 1
prints "  Value of kVal at initialization = %d\n", i(kVal)
printks "  Value of kVal at first k-cycle = %d\n", 0, kVal
kVal = 2
turnoff
endin

instr with_init
prints "instr with_init, call %d:\n", p4
kVal init 1
kVal = 1
prints "  Value of kVal at initialization = %d\n", i(kVal)
printks "  Value of kVal at first k-cycle = %d\n", 0, kVal
kVal = 2
turnoff
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "without_init" 0 .1 1
i "without_init" + .1 2
i "with_init" 1 .1 1
i "with_init" + .1 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Esta es la salida a consola:</p>
<p><span style="font-size: small;"><span style="font-family: 'courier new', courier, monospace;">instr without_init, call 1: <br />&nbsp; Value of kVal at initialization = 0 <br />&nbsp; Value of kVal at first k-cycle = 1 <br />instr without_init, call 2: <br />&nbsp; Value of kVal at initialization = 2 <br />&nbsp; Value of kVal at first k-cycle = 1 <br />instr with_init, call 1: <br />&nbsp; Value of kVal at initialization = 1 <br />&nbsp; Value of kVal at first k-cycle = 1 <br />instr with_init, call 2: <br />&nbsp; Value of kVal at initialization = 1 <br />&nbsp; Value of kVal at first k-cycle = 1</span></span></p>
<p>&nbsp;</p>
<h2>Reinicializaci&oacute;n</h2>
<p>Como vimos anteriormente, un valor-i no es afectado por el bucle de ejecuci&oacute;n. Por lo tanto, no puede esperarse que esto funcione como un incremento:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A11_Init_no_incr.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
iCount&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;set iCount to 0 first
iCount&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCount + 1 ;increase
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print&nbsp;&nbsp;&nbsp;&nbsp; iCount&nbsp;&nbsp;&nbsp;&nbsp; ;print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>La salida a consola no es m&aacute;s que: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">instr 1:&nbsp; iCount = 1.000 </span></p>
<p>Sin embargo, puede ped&iacute;rsele a Csound que repita la inicializaci&oacute;n de una variable-i. Esto se hace con el opcode <em>reinit</em>. En primer lugar debe marcarse una secci&oacute;n con una etiqueta (cualquier nombre seguido de dos puntos). Luego, la instrucci&oacute;n <em>reinit</em> har&aacute; que la variable-i se actualice. Use <em>rireturn</em> para terminar la secci&oacute;n <em>reinit</em>.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A12_Re-init.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
iCount&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; set icount to 0 first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reinit&nbsp;&nbsp;&nbsp; new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; reinit the section each k-pass
new:
iCount&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iCount + 1 ; increase
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print&nbsp;&nbsp;&nbsp;&nbsp; iCount&nbsp;&nbsp;&nbsp;&nbsp; ; print the value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rireturn
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>Salida a consola: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">instr 1:&nbsp; iCount = 1.000 <br />instr 1:&nbsp; iCount = 2.000 <br />instr 1:&nbsp; iCount = 3.000 <br />instr 1:&nbsp; iCount = 4.000 <br />instr 1:&nbsp; iCount = 5.000 <br />instr 1:&nbsp; iCount = 6.000 <br />instr 1:&nbsp; iCount = 7.000 <br />instr 1:&nbsp; iCount = 8.000 <br />instr 1:&nbsp; iCount = 9.000 <br />instr 1:&nbsp; iCount = 10.000 <br />instr 1:&nbsp; iCount = 11.000 </span> <br /><br />Lo que sucede aqu&iacute; es lo siguiente. En la pasada-de-inicializaci&oacute;n real, <em>iCount</em> se pone a cero a trav&eacute;s de <em>iCount init 0</em>. A&uacute;n en este init-pass, se incrementa en uno (iCount = iCount 1) y el valor se imprime como <em>iCount = 1.000</em>. Luego comienza la primer pasada-de-ejecuci&oacute;n. La sentencia <em>reinit new</em> demanda a Csound que vuelva a inicializar la secci&oacute;n etiquetada como nueva. As&iacute;, la sentencia <em>iCount = iCount + 1</em> se ejecuta de nuevo. Como el valor actual de <em>iCount</em> en este momento es 1, el resultado es 2. Por lo tanto, la impresi&oacute;n en este primer pase de rendimiento es <em>iCount = 2.000</em>. Lo mismo ocurre en los pr&oacute;ximos nueve ciclos de rendimiento, por lo que el recuento final es 11.</p>
<p>&nbsp;</p>
<h2>Orden de C&oacute;mputo</h2>
<p>En este contexto, puede ser muy importante observar el orden en que se eval&uacute;an los instrumentos de una orquesta de Csound. Este orden est&aacute; determinado por los n&uacute;meros de instrumento. Por lo tanto, si desea utilizar durante la misma pasada-de-ejecuci&oacute;n un valor en el instrumento 10 que a su vez es generado por otro instrumento, no debe dar a ese &uacute;ltimo instrumento un n&uacute;mero superior o igual a 11. En el ejemplo siguiente, el instrumento 10 utiliza un valor del instrumento 1; luego, un valor del instrumento 100.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A13_Order_of_calc.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
gkcount&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ;set gkcount to 0 first
gkcount&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gkcount + 1 ;increase
endin

instr 10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk&nbsp;&nbsp;&nbsp; 0, gkcount ;print the value
endin

instr 100
gkcount&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ;set gkcount to 0 first
gkcount&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gkcount + 1 ;increase
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;first i1 and i10
i 1 0 1
i 10 0 1
;then i100 and i10
i 100 1 1
i 10 1 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;Example by Joachim Heintz</pre>
<p>La salida a consola muestra la diferencia: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">new alloc for instr 1: <br />new alloc for instr 10: <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.10000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.20000:&nbsp;&nbsp;&nbsp;&nbsp; 2.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.30000:&nbsp;&nbsp;&nbsp;&nbsp; 3.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.40000:&nbsp;&nbsp;&nbsp;&nbsp; 4.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.50000:&nbsp;&nbsp;&nbsp;&nbsp; 5.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.60000:&nbsp;&nbsp;&nbsp;&nbsp; 6.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.70000:&nbsp;&nbsp;&nbsp;&nbsp; 7.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.80000:&nbsp;&nbsp;&nbsp;&nbsp; 8.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 0.90000:&nbsp;&nbsp;&nbsp;&nbsp; 9.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.00000:&nbsp;&nbsp;&nbsp; 10.00000 <br />B&nbsp; 0.000 ..&nbsp; 1.000 T&nbsp; 1.000 TT&nbsp; 1.000 M:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0 <br />new alloc for instr 100: <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.10000:&nbsp;&nbsp;&nbsp;&nbsp; 0.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.20000:&nbsp;&nbsp;&nbsp;&nbsp; 1.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.30000:&nbsp;&nbsp;&nbsp;&nbsp; 2.00000</span><span style="font-family: 'courier new', courier, monospace; font-size: small;"><span style="font-family: 'courier new', courier, monospace; font-size: small;"> <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.40000:&nbsp;&nbsp;&nbsp;&nbsp; 3.00000 </span> <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.50000:&nbsp;&nbsp;&nbsp;&nbsp; 4.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.60000:&nbsp;&nbsp;&nbsp;&nbsp; 5.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.70000:&nbsp;&nbsp;&nbsp;&nbsp; 6.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.80000:&nbsp;&nbsp;&nbsp;&nbsp; 7.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 1.90000:&nbsp;&nbsp;&nbsp;&nbsp; 8.00000 <br />&nbsp;i&nbsp; 10 time&nbsp;&nbsp;&nbsp;&nbsp; 2.00000:&nbsp;&nbsp;&nbsp;&nbsp; 9.00000 <br />B&nbsp; 1.000 ..&nbsp; 2.000 T&nbsp; 2.000 TT&nbsp; 2.000 M:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0 </span></p>
<p>&nbsp;</p>
<p>El instrumento 10 puede utilizar los valores que el instrumento 1 ha producido en el mismo ciclo de control, pero s&oacute;lo puede referirse a los valores del instrumento 100 que ya hayan sido producidos en el ciclo de control anterior. Por esta raz&oacute;n, la impresi&oacute;n muestra valores que equivalen a n&uacute;meros con una diferencia de 1.</p>
<p>&nbsp;</p>
<h2>Instrumentos con Nombre</h2>
<p>Se ha dicho en el cap&iacute;tulo 02B (Inicio R&aacute;pido) que en lugar de un n&uacute;mero tambi&eacute;n se puede utilizar un nombre para un instrumento. Esta puede ser una pr&aacute;ctica preferible ya que de este modo pueden utilizarse nombres significativos, conduciendo a un c&oacute;digo m&aacute;s f&aacute;cil de seguir. Pero &iquest;qu&eacute; pasa con el orden de c&oacute;mputo en los instrumentos con nombre?</p>
<p>La respuesta es simple: Csound los calcula en el mismo orden en que est&aacute;n escritos en la orquesta. As&iacute; que si su orquesta es como la siguiente...</p>
<p><br />&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A14_Order_of_calc_named.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nd
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

instr Grain_machine
prints " Grain_machine\n"
endin

instr Fantastic_FM
prints "&nbsp; Fantastic_FM\n"
endin

instr Random_Filter
prints "&nbsp;&nbsp; Random_Filter\n"
endin

instr Final_Reverb
prints "&nbsp;&nbsp;&nbsp; Final_Reverb\n"
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Final_Reverb" 0 1
i "Random_Filter" 0 1
i "Grain_machine" 0 1
i "Fantastic_FM" 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>... puede contar con que la salida a consola ser&aacute; la siguiente: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">new alloc for instr Grain_machine: <br />&nbsp;Grain_machine <br />new alloc for instr Fantastic_FM: <br />&nbsp; Fantastic_FM <br />new alloc for instr Random_Filter: <br />&nbsp;&nbsp; Random_Filter <br />new alloc for instr Final_Reverb: <br />&nbsp;&nbsp;&nbsp; Final_Reverb </span></p>
<p>N&oacute;tese que la partitura no tiene el mismo orden. Pero internamente Csound transforma todos los nombres en n&uacute;meros, en el orden en que se escriben de arriba a abajo. Los n&uacute;meros utilizados se informan en la parte superior de la salida a consola que realiza Csound<span id="InsertNoteID_22_marker23" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_22">10</a></sup></span>:</p>
<p><br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">instr Grain_machine uses instrument number 1 <br />instr Fantastic_FM uses instrument number 2 <br />instr Random_Filter uses instrument number 3 <br />instr Final_Reverb uses instrument number 4 </span></p>
<h2>Acerca de los Opcodes de "tiempo-i" y "ciclo-k"</h2>
<p><span id="InsertNoteID_24_marker25" class="InsertNoteMarker">A menudo es confuso para los principiantes que haya algunos opcodes que s&oacute;lo funcionan en "tiempo-i", y otros que s&oacute;lo funcionan "tiempo-k". Por ejemplo, si el usuario quiere imprimir el valor de cualquier variable, piensa: "OK - impr&iacute;malo". Pero Csound responde: "Por favor, d&iacute;game primero si quiere imprimir una "variable-i" o una "variable-k<span id="InsertNoteID_24_marker25" class="InsertNoteMarker">".<span id="InsertNoteID_24_marker25" class="InsertNoteMarker"><sup><a title="init" href="http://write.flossmanuals.net/csound/a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_24">11</a></sup></span></span></span></p>
<p>El opcode <a title="init" href="http://csounds.com/manual/html/print.html">print</a> s&oacute;lo imprime variables que se actualizan en cada paso de inicializaci&oacute;n ("tiempo-i" o "ciclo-i"). Si desea imprimir una variable que se actualiza en cada ciclo de control ("tiempo-k" o "ciclo-k"), necesita su contraparte <a title="init" href="http://csounds.com/manual/html/printk.html">printk</a>. (Como la pasada de ejecuci&oacute;n generalmente corresponde a una actualizaci&oacute;n de algunas miles de veces por segundo, printk posee un par&aacute;metro adicional para informar a Csound la frecuencia con la que desea imprimir los valores-k).</p>
<p>Por lo tanto, algunos opcodes son s&oacute;lo para las variables de ciclo-i, como <a title="init" href="http://csounds.com/manual/html/filelen.html">filelen</a> o <a title="init" href="http://csounds.com/manual/html/ftgen.html">ftgen</a>. Otros son s&oacute;lo para las variables de ciclo-k como <a title="init" href="http://csounds.com/manual/html/metro.html">metro</a> o <a title="init" href="http://csounds.com/manual/html/max_k.html">max_k</a>. Muchos opcodes tienen variantes para variables de ciclo-i o de ciclo-k, tales como <a title="init" href="http://csounds.com/manual/html/printf.html">printf_i</a> y <a title="init" href="http://csounds.com/manual/html/printf.html">printf</a>, <a title="init" href="http://csounds.com/manual/html/sprintf.html">sprintf</a> y <a title="init" href="http://csounds.com/manual/html/sprintf.html">sprintfk</a>, <a title="init" href="http://csounds.com/manual/html/strindex.html">strindex</a> y <a title="init" href="http://csounds.com/manual/html/strindexk.html">strindexk</a>.</p>
<p>La mayor&iacute;a de los opcodes de Csound son capaces de trabajar ya sea en tiempo-i, en tiempo-k o en tiempo-a (tiempo de audio), pero debe pensarse cuidadosamente lo que se necesita, ya que el comportamiento ser&aacute; muy diferente si se elige la variante i- k- o a- de un opcode. Por ejemplo, el opcode <a title="init" href="http://csounds.com/manual/html/random.html">random</a>&nbsp; puede funcionar a las tres frecuencias:</p>
<pre>ires      random    imin, imax : works at "i-time"
kres      random    kmin, kmax : works at "k-rate"
ares      random    kmin, kmax : works at "audio-rate"
</pre>
<p>Si utiliza el random de ciclo-i, obtendr&aacute; un valor para cada nota. Entonces si desea obtener un tono diferente para cada nota que est&aacute; generando, probablemente necesite usar esta variante.</p>
<p>Si utiliza el random de ciclo-k, obtendr&aacute; un nuevo valor en cada ciclo de control. Si su tasa de muestreo es 44100 y su ksmps = 10, obtendr&aacute; 4410 nuevos valores por segundo! Si se toma esto como valor del tono para una nota, no oir&aacute; m&aacute;s que un cambio de tono cercano al ruido. Para casos as&iacute;, puede usar la variante&nbsp;<a title="init" href="http://csounds.com/manual/html/randomi.html">randomi</a> del generador de ciclo-k, que puede reducir el n&uacute;mero de nuevos valores por segundo e interpolar entre ellos.</p>
<p>Si utiliza la variante de ciclo-a, obtendr&aacute; tantos nuevos valores por segundo como su tasa de muestreo y si lo usa en el rango de su amplitud de 0 dB, produce ruido blanco.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A15_Random_at_ika.csd</strong></em>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 2

          seed      0 ;each time different seed
giSine    ftgen     0, 0, 2^10, 10, 1 ;sine table

instr 1 ;i-rate random
iPch      random    300, 600
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, iPch, giSine
          outs      aSine, aSine
endin

instr 2 ;k-rate random: noisy
kPch      random    300, 600
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, kPch, giSine
          outs      aSine, aSine
endin

instr 3 ;k-rate random with interpolation: sliding pitch
kPch      randomi   300, 600, 3
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, kPch, giSine
          outs      aSine, aSine
endin

instr 4 ;a-rate random: white noise
aNoise    random    -.1, .1
          outs      aNoise, aNoise
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0   .5
i 1 .25 .5
i 1 .5  .5
i 1 .75 .5
i 2 2   1
i 3 4   2
i 3 5   2
i 3 6   2
i 4 9   1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h2>Posibles Problemas con el Tama&ntilde;o del Tick de los ciclos-k</h2>
<p>Se ha dicho que por lo general el reloj de ciclo-k se actualiza mucho m&aacute;s lento que el reloj de la muestra (ciclo-a). Para el valor habitual de ksmps = 32, un valor-k se mantendr&aacute; constante durante 32 muestras. Esto puede dar lugar a problemas, por ejemplo, si utiliza envolventes de ciclo-k. Supongamos que desea producir un desvanecimiento muy corto de 3 milisegundos y lo hace con la siguiente l&iacute;nea de c&oacute;digo:</p>
<p>kFadeIn linseg 0, .003, 1</p>
<p>Su envolvente se ver&aacute; as&iacute;:</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="static/03A_k-rate_env.png" alt="" width="607" height="347" /></p>
<p align="center"><br />Such a "staircase-envelope" is what you hear in the next example as zipper noise. The transeg opcode produces a non-linear envelope with a sharp peak:</p>
<p>Esta "envolvente en escalera" es lo que se escucha en el siguiente ejemplo como ruido de cremallera. El opcode transeg produce una envolvente no lineal con un pico agudo:</p>
<p align="center"><img src="static/03A_peak.png" alt="" width="127" height="258" />&nbsp;</p>
<p>El ataque y la extinci&oacute;n son cada uno de 1/100 segundos de duraci&oacute;n. Si esta envolvente se produce en ciclos-k con un tama&ntilde;o de bloques de 128 (instr 1), el ruido es claramente audible. Intente cambiar ksmps a 64, 32 o 16 y compare la cantidad de "ruido de cremallera". - El instrumento 2 utiliza una envolvente igual a la tasa de muestreo. Independientemente del tama&ntilde;o del bloque, cada muestra se calcula separadamente, por lo que la envolvente siempre ser&aacute; suave.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A16_Zipper.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
;--- increase or decrease to hear the difference more or less evident
ksmps = 128
nchnls = 2
0dbfs = 1

instr 1 ;envelope at k-time
aSine     oscils    .5, 800, 0
kEnv      transeg   0, .1, 5, 1, .1, -5, 0
aOut      =         aSine * kEnv
          outs      aOut, aOut
endin

instr 2 ;envelope at a-time
aSine     oscils    .5, 800, 0
aEnv      transeg   0, .1, 5, 1, .1, -5, 0
aOut      =         aSine * aEnv
          outs      aOut, aOut
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
r 5 ;repeat the following line 5 times
i 1 0 1
s ;end of section
r 5
i 2 0 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h2>Tiempo Imposible</h2>
<p>Hay dos relojes internos en Csound. La tasa de muestreo (sr) determina el la frecuencia del audio, mientras que la tasa de control (kr) determina la frecuencia en la que un nuevo ciclo de control se puede iniciar y en la que se puede procesar un nuevo bloque de muestras. En general, Csound no puede iniciar o finalizar ning&uacute;n evento entre dos ciclos de control.</p>
<p>El siguiente ejemplo utiliza una tasa de control extremadamente peque&ntilde;a (s&oacute;lo 10 k-ciclos por segundo) para ilustrar esto.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03A17_Time_Impossible.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o test.wav -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410
nchnls = 1
0dbfs = 1
&nbsp; 
&nbsp; instr 1
aPink oscils .5, 430, 0
out aPink
&nbsp; endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0.05 0.1
i 1 0.4 0.15
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>La primera llamada avisa al instrumento 1 que inicie la ejecuci&oacute;n durante el tiempo 0.05. Pero esto es imposible ya que se encuentra entre dos ciclos de control. La segunda llamada comienza en un tiempo posible, pero la duraci&oacute;n de 0.15 de nuevo no coincide con la tasa de control. As&iacute; que el resultado inicia la primera llamada en el tiempo 0.1 y extiende la segunda llamada a 0.2 segundos:</p>
<p><img src="static/03A_Wrong_times.png" alt="" width="418" height="321" />&nbsp;</p>
<p>&nbsp;</p>
<p>Con Csound6, las posibilidades de estas "intersecciones" se ampl&iacute;an a trav&eacute;s de la opci&oacute;n --sample-accurate. La imagen siguiente muestra c&oacute;mo una envolvente de 0.01 segundos generada por el c&oacute;digo</p>
<pre>a1 init  1
a2 linen a1, p3/3, p3, p3/3
   out   a2
</pre>
<p>(y una llamada de 0.01 segundos con sr=44100) se muestra en los siguientes casos:</p>
<ol>
<li>ksmps=128</li>
<li>ksmps=32</li>
<li>ksmps=1</li>
<li>ksmps=128 y --sample-accurate habilitado.</li>
</ol>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="static/03A_ksmps.png" alt="" width="740" height="305" />&nbsp;</p>
<p>Este es el efecto:</p>
<ol>
<li>Con ksmps = 128, falta la &uacute;ltima secci&oacute;n de la envolvente. La raz&oacute;n es que, con sr = 44100 Hz, 0,01 segundos contienen 441 muestras. 441 muestras divididas por el tama&ntilde;o de bloque (ksmps) de 128 muestras producen 3,4453125 bloques. Esto se redondea a 3. As&iacute; que s&oacute;lo 3 * 128 = 384 muestras se generan. Como se ve, la forma de la envolvente se calcula correctamente. Terminar&iacute;a exactamente en 0,01 segundos ... pero no, porque el bloque ksmps termina demasiado pronto. As&iacute; que con esta envolvente podr&iacute;a o&iacute;rse un clic al final de la nota.</li>
<li>
<p>Con ksmps = 32, el n&uacute;mero de muestras (441) dividido por ksmps produce un valor de 13.78125. Esto se redondea a 14, por lo que el audio procesado es ligeramente m&aacute;s largo que 0,01 segundos (448 muestras). </p>
</li>
<li>
<p>Con ksmps = 1, la envolvente se genera tal como es de esperarse.</p>
</li>
<li>
<p>Con ksmps = 128 y --sample-accurate habilitado, la envolvente es tambi&eacute;n la correcta. Tenga en cuenta que la secci&oacute;n es ahora 4 * 128 = 512 muestras de largo, pero la envolvente es m&aacute;s precisa que con ksmps = 32.</p>
</li>
</ol>
<p>Por lo tanto, en caso de que experimente clics en envolventes muy cortas, aunque use envolventes de ciclo-a, puede ser necesario establecer ksmps = 1 o habilitar la opci&oacute;n --sample-accurate.</p>
<p>&nbsp;</p>
<h2>Cu&aacute;ndo Usar Ciclos-i y Ciclos-k</h2>
<p>Cuando se escribe un instrumento en Csound, a veces hace falta preguntarse si necesitaremos un opcode de ciclo-i o uno de ciclo-k. Seg&uacute;n se dice, la respuesta general es clara: Utilice el ciclo-i para algo que necesite ejcutarse s&oacute;lo una vez, o de manera puntual. Use el ciclo-k para algo que tenga que hacerse de forma cont&iacute;nua, o si debe considerarse lo que sucede durante la ejecuci&oacute;n.</p>
<p><br />&nbsp;</p>
<ol id="InsertNote_NoteList">
<li id="InsertNoteID_8">No obtendr&iacute;a ning&uacute;n otro resultado si estableci&oacute; p3 a 1 o cualquier otro valor, ya que aqu&iacute; no se hace nada excepto la inicializaci&oacute;n.<span id="InsertNoteID_8_LinkBacks"><sup><a id="InsertNoteID_8" href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_8_marker9">^</a></sup></span></li>
<li id="InsertNoteID_10">44100 muestras por segundo<span id="InsertNoteID_10_LinkBacks"><sup><a id="InsertNoteID_10" href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_10_marker11">^</a></sup></span></li>
<li id="InsertNoteID_28">These are by the way the times which Csound reports if you ask for the control cycles. The first control cycle in this example (sr=44100, ksmps=10) would be reported as 0.00027 seconds, not as 0.00000 seconds.<span id="InsertNoteID_28_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_28_marker29">^</a></sup></span></li>
<li id="InsertNoteID_12">As Richard Boulanger explains, in early Csound a line starting with 'c' was a comment line. So it was not possible to abbreviate control variables as cAnything (http://csound.1045644.n5.nabble.com/OT-why-is-control-rate-called-kontrol-rate-td5720858.html#a5720866). <span id="InsertNoteID_12_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_12_marker13">^</a></sup></span></li>
<li id="InsertNoteID_14">As the k-rate is directly depending on sample rate (sr) and ksmps (kr = sr/ksmps), it is probably the best style to specify sr and ksmps in the header, but not kr. <span id="InsertNoteID_14_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_14_marker15">^</a></sup></span></li>
<li id="InsertNoteID_16">This must not be confused with a 'real' k-loop where inside one single k-cycle a loop is performed. See chapter 03C (section Loops) for examples.<span id="InsertNoteID_16_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_16_marker17">^</a></sup></span></li>
<li id="InsertNoteID_18">The value is 3110 instead of 3100 because it has already been incremented by 10.<span id="InsertNoteID_18_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_18_marker19">^</a></sup></span></li>
<li id="InsertNoteID_20">See the manual page for printk, printk2, printks, printf to know more about the differences.<span id="InsertNoteID_20_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_20_marker21">^</a></sup></span></li>
<li id="InsertNoteID_22">If you want to know the number in an instrument, use the nstrnum opcode. <span id="InsertNoteID_22_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_22_marker23">^</a></sup></span></li>
<li id="InsertNoteID_24">See the following section 03B about the variable types for more on this subject.<span id="InsertNoteID_24_LinkBacks"><sup><a href="a-initialization-and-performance-pass/a-initialization-and-performance-pass#InsertNoteID_24_marker25">^</a></sup></span></li>
</ol>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

