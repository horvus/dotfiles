
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: K-Ats-Resynthesis / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter K. ATS RESYNTHESIS" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter K. ATS RESYNTHESIS" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <p>K. ANALYSIS TRANSFORMATION SYNTHESIS</p>
<p>K. S&Iacute;NTESIS DE TRANSFORMACI&Oacute;N DE AN&Aacute;LISIS</p>
<p>&nbsp;</p>
<p>1. The ATS technique.</p>
<p>1. La t&eacute;cnica ATS.</p>
<p>&nbsp;</p>
<p>General overview.</p>
<p>Visi&oacute;n general.</p>
<p>The ATS technique (Analysis-Transformation-Synthesis) was developed by Juan Pampin. A comprehensive explanation of this technique can be found in his ATS Theory1 but, essentially, it may be said that it represents two aspects of the analyzed signal: the deterministic part and the stochastic or residual part. This model was initially conceived by Julius Orion Smith and Xavier Serra,2 but ATS refines certain aspects of it, such as the weighting of the spectral components on the basis of their Signal-to-Mask-Ratio (SMR).3</p>
<p>La t&eacute;cnica ATS (An&aacute;lisis-Transformaci&oacute;n-S&iacute;ntesis) fue desarrollada por Juan Pampin. Una explicaci&oacute;n exhaustiva de esta t&eacute;cnica puede encontrarse en su Teor&iacute;a ATS1, pero, esencialmente, puede decirse que representa dos aspectos de la se&ntilde;al analizada: la parte determinista y la parte estoc&aacute;stica o residual. Este modelo fue inicialmente concebido por Julius Orion Smith y Xavier Serra2, pero ATS refina ciertos aspectos de la misma, como la ponderaci&oacute;n de los componentes espectrales sobre la base de su Relaci&oacute;n Se&ntilde;al-M&aacute;scara (SMR) .3</p>
<p>The deterministic part consists in sinusoidal trajectories with varying amplitude, frequency and phase. It is achieved by means of the depuration of the spectral data obtained using STFT (Short-Time Fourier Transform) analysis.</p>
<p>La parte determinista consiste en trayectorias sinusoidales con amplitud, frecuencia y fase variables. Se logra mediante la depuraci&oacute;n de los datos espectrales obtenidos mediante el an&aacute;lisis STFT (Short-Time Fourier Transform).</p>
<p>The stochastic part is also termed residual, because it is achieved by subtracting the deterministic signal from the original signal. For such purposes, the deterministic part is synthesized preserving the phase alignment of its components in the second step of the analysis. The residual part is represented with noise variable energy values along the 25 critical bands.4</p>
<p>La parte estoc&aacute;stica tambi&eacute;n se denomina residual, porque se logra sustrayendo la se&ntilde;al determin&iacute;stica de la se&ntilde;al original. Para estos prop&oacute;sitos, la parte determinista se sintetiza preservando la alineaci&oacute;n de fases de sus componentes en la segunda etapa del an&aacute;lisis. La parte residual se representa con valores de energ&iacute;a variable de ruido a lo largo de las 25 bandas cr&iacute;ticas.</p>
<p>The ATS technique has the following advantages:</p>
<p>La t&eacute;cnica ATS tiene las siguientes ventajas:</p>
<p>The splitting between deterministic and stochastic parts allows an independent treatment of two different qualitative aspects of an audio signal.</p>
<p>La divisi&oacute;n entre partes determin&iacute;sticas y estoc&aacute;sticas permite un tratamiento independiente de dos aspectos cualitativos diferentes de una se&ntilde;al de audio.</p>
<p>The representation of the deterministic part by means of sinusoidal trajectories improves the information and presents it on a way that is much closer to the way that musicians think of sound. Therefore, it allows many 'classical' spectral transformations (such as the suppression of partials or their frequency warping) in a more flexible and conceptually clearer way.</p>
<p>La representaci&oacute;n de la parte determinista por medio de trayectorias sinusoidales mejora la informaci&oacute;n y la presenta de una manera mucho m&aacute;s cercana a la forma en que los m&uacute;sicos piensan en el sonido. Por lo tanto, permite muchas transformaciones espectrales cl&aacute;sicas (tales como la supresi&oacute;n de parciales o su deformaci&oacute;n de frecuencia) de una manera m&aacute;s flexible y conceptualmente m&aacute;s clara.</p>
<p>The representation of the residual part by means of noise values among the 25 critical bands simplifies the information and its further reconstruction. Namely, it is possible to overcome the common artifacts that arise in synthesis using oscillator banks or IDFT, when the time of a noisy signal analyzed using a FFT is warped.</p>
<p>La representaci&oacute;n de la parte residual por medio de valores de ruido entre las 25 bandas cr&iacute;ticas simplifica la informaci&oacute;n y su posterior reconstrucci&oacute;n. A saber, es posible superar los artefactos comunes que surgen en la s&iacute;ntesis usando bancos de oscilador o IDFT, cuando el tiempo de una se&ntilde;al ruidosa analizada usando una FFT es deformado.</p>
<p>&nbsp;</p>
<p>The ATS file format</p>
<p>El formato de archivo ATS</p>
<p>Instead of storing the 'crude' data of the FFT analysis, the ATS files store a representation of a digital sound signal in terms of sinusoidal trajectories (called partials) with instantaneous frequency, amplitude, and phase changing along temporal frames. Each frame has a set of partials, each having (at least) amplitude and frequency values (phase information might be discarded from the analysis). Each frame might also contain noise information, modeled as time-varying energy in the 25 critical bands of the analysis residual. All the data is stored as 64 bits floats in the host's byte order.</p>
<p>En lugar de almacenar los datos brutos del an&aacute;lisis FFT, los archivos ATS almacenan una representaci&oacute;n de una se&ntilde;al de sonido digital en t&eacute;rminos de trayectorias sinusoidales (llamadas parciales) con frecuencia instant&aacute;nea, amplitud y cambio de fase a lo largo de tramas temporales. Cada trama tiene un conjunto de parciales, cada uno de los cuales tiene (al menos) valores de amplitud y frecuencia (la informaci&oacute;n de fase puede ser descartada del an&aacute;lisis). Cada trama tambi&eacute;n puede contener informaci&oacute;n de ruido, modelada como energ&iacute;a variable en el tiempo en las 25 bandas cr&iacute;ticas del an&aacute;lisis residual. Todos los datos se almacenan como 64 bits flotantes en el orden de los hosts bytes.</p>
<p>The ATS files start with a header at which their description is stored (such as frame rate, duration, number of sinusoidal trajectories, etc.). The header of the ATS files contains the following information:</p>
<p>Los archivos ATS comienzan con una cabecera en la que se almacena su descripci&oacute;n (como la velocidad de fotogramas, la duraci&oacute;n, el n&uacute;mero de trayectorias sinusoidales, etc.). El encabezado de los archivos ATS contiene la siguiente informaci&oacute;n:</p>
<p>ats-magic-number (just the arbitrary number 123. for consistency checking)</p>
<p>Ats-magic-number (s&oacute;lo el n&uacute;mero arbitrario 123. para la verificaci&oacute;n de la coherencia)</p>
<p>sampling-rate (samples/sec)</p>
<ol>
<li>frame-size (samples)</li>
<li>window-size (samples)</li>
<li>partials (number of partials)</li>
<li>frames (number of frames)</li>
<li>ampmax (max. amplitude)</li>
<li>frqmax (max. frequency)</li>
<li>dur (duration in sec.)</li>
<li>type (frame type, see below)</li>
</ol>
<p>The ATS frame type may be, at present, one of the four following:</p>
<p>El tipo de trama ATS puede ser, actualmente, uno de los cuatro siguientes:</p>
<p>Type 1: only sinusoidal trajectories with amplitude and frequency data.</p>
<p>Tipo 1: s&oacute;lo trayectorias sinusoidales con datos de amplitud y frecuencia.</p>
<p>Type 2: only sinusoidal trajectories with amplitude, frequency and phase data.</p>
<p>Tipo 2: s&oacute;lo trayectorias sinusoidales con datos de amplitud, frecuencia y fase.</p>
<p>Type 3: sinusoidal trajectories with amplitude, and frequency data as well as residual data.</p>
<p>Tipo 3: trayectorias sinusoidales con amplitud, y datos de frecuencia, as&iacute; como datos residuales.</p>
<p>Type 4: sinusoidal trajectories with amplitude, frequency and phase data as well as residual data.</p>
<p>Tipo 4: trayectorias sinusoidales con datos de amplitud, frecuencia y fase, as&iacute; como datos residuales.</p>
<p>So, after the header, an ATS file with frame type 4, np number of partials and nf frames will have:</p>
<p>Por lo tanto, despu&eacute;s del encabezado, un archivo ATS con tipo de trama 4, np n&uacute;mero de parciales y nf marcos tendr&aacute;:</p>
<p>Frame 1:</p>
<pre>		Amp.of partial 1,   Freq. of partial 1, Phase of partial 1
		.......................................................................................
		.......................................................................................
		Amp.of partial <em>np</em>,   Freq. of partial <em>np</em>, Phase of partial <em>np</em>	

		Residual energy  value for  critical band 1
		..................................................................
		..................................................................
		Residual energy  value for  critical band 25

........................................................................................................

Frame <em>nf</em>:
		Amp.of partial 1,   Freq. of partial 1, Phase of partial 1
		.......................................................................................
		.......................................................................................
		Amp.of partial <em>np</em>,   Freq. of partial <em>np</em>, Phase of partial <em>np</em>	

		Residual energy  value for  critical band 1
		..................................................................
		..................................................................
		Residual energy  value for  critical band 25
</pre>
<p>As an example, an ATS file of frame type 4, with 100 frames and 10 partials will need:</p>
<p>Como ejemplo, un archivo ATS de tipo de trama 4, con 100 tramas y 10 parciales necesitar&aacute;:</p>
<p>A header with 10 double floats values.</p>
<p>Una cabecera con 10 valores de flotadores dobles.</p>
<p>100*10*3 double floats for storing the Amplitude, Frequency and Phase values of 10 partials along 100 frames.</p>
<p>100 * 10 * 3 flotadores dobles para almacenar los valores de Amplitud, Frecuencia y Fase de 10 partiales a lo largo de 100 tramas.</p>
<p>25*100 double floats for storing the noise information of the 25 critical bands along 100 frames.</p>
<p>25 * 100 flotadores dobles para almacenar la informaci&oacute;n de ruido de las 25 bandas cr&iacute;ticas a lo largo de 100 marcos.</p>
<p>Header:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 10*8 &nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp; 80 bytes</p>
<pre>Deterministic data:&nbsp; 3000*8     =&nbsp;&nbsp;&nbsp; 24000 bytes
Residual data:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 2500*8     =&nbsp;&nbsp;&nbsp; 20000 bytes&nbsp;&nbsp;&nbsp;

Total:       80 + 24000 + 20000 =    44080 bytes</pre>
<p>The following Csound code shows how to retrieve the data of the header of an ATS file.</p>
<p>El siguiente c&oacute;digo Csound muestra c&oacute;mo recuperar los datos del encabezado de un archivo ATS.</p>
<p><em><strong>&nbsp; EXAMPLE 05K01_ats_header.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-n -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;Some macros
#define ATS_SR	# 0 # 	;sample rate  	(Hz)
#define ATS_FS	# 1 # 	;frame size 	(samples)
#define ATS_WS	# 2 #	;window Size 	(samples)
#define ATS_NP	# 3 #	;number of Partials
#define ATS_NF	# 4 #	;number of Frames
#define ATS_AM	# 5 #	;maximum Amplitude
#define ATS_FM	# 6 #	;maximum Frequency (Hz)
#define ATS_DU	# 7 #	;duration 	(seconds)
#define ATS_TY	# 8 #	;ATS file Type

instr 1	
iats_file=p4
;instr1 just reads the file header and loads its data into several variables
;and prints the result in the Csound prompt.
i_sampling_rate 	ATSinfo iats_file,  $ATS_SR
i_frame_size 		ATSinfo iats_file,  $ATS_FS
i_window_size 		ATSinfo iats_file,  $ATS_WS
i_number_of_partials 	ATSinfo iats_file,  $ATS_NP
i_number_of_frames 	ATSinfo iats_file,  $ATS_NF
i_max_amp 		ATSinfo iats_file,  $ATS_AM
i_max_freq 		ATSinfo iats_file,  $ATS_FM
i_duration 		ATSinfo iats_file,  $ATS_DU
i_ats_file_type 	ATSinfo iats_file,  $ATS_TY

print i_sampling_rate
print i_frame_size
print i_window_size
print i_number_of_partials
print i_number_of_frames
print i_max_amp
print i_max_freq
print i_duration
print i_ats_file_type

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;change to put any ATS file you like
#define ats_file #"../ats-files/basoon-C4.ats"#
;	st	dur	atsfile
i1 	0	0 	$ats_file
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;Example by Oscar Pablo Di Liscia</pre>
<p>2. Performing ATS analysis with the ATSA command-line utility of Csound.</p>
<p>2. Realizar an&aacute;lisis ATS con la utilidad de l&iacute;nea de comandos ATSA de Csound.</p>
<p>All the Csound Opcodes devoted to ATS Synthesis need to read an ATS Analysis file. ATS was initially developed for the CLM environment (Common Lisp Music), but at present there exist several GNU applications that can perform ATS analysis, among them the Csound Package command-line utility ATSA which is based on the ATSA program (Di Liscia, Pampin, Moss) and was ported to Csound by Istvan Varga. The ATSA program (Di Liscia, Pampin, Moss) may be obtained at:</p>
<p>Todos los Opcodes Csound dedicados a la s&iacute;ntesis ATS necesitan leer un archivo de an&aacute;lisis ATS. ATS se desarroll&oacute; inicialmente para el entorno CLM (Common Lisp Music), pero en la actualidad existen varias aplicaciones GNU que pueden realizar an&aacute;lisis ATS, entre ellas la utilidad de l&iacute;nea de comandos Csound Package ATSA que se basa en el programa ATSA (Di Liscia, Pampin , Moss) y fue portado a Csound por Istvan Varga. El programa ATSA (Di Liscia, Pampin, Moss) se puede obtener en:</p>
<p><a href="https://github.com/jamezilla/ats/tree/master/ats">https://github.com/jamezilla/ats/tree/master/ats</a></p>
<p>Graphical Resources for displaying ATS analysis files.</p>
<p>Recursos gr&aacute;ficos para mostrar archivos de an&aacute;lisis ATS.</p>
<p>If a plot of the ATS files is required, the ATSH software (Di Liscia, Pampin, Moss) may be used. ATSH is a C program that uses the GTK graphic environment. The source code and compilation directives can be obtained at:</p>
<p>Si se requiere una trama de los archivos ATS, se puede usar el software ATSH (Di Liscia, Pampin, Moss). ATSH es un programa C que utiliza el entorno gr&aacute;fico GTK. El c&oacute;digo fuente y las directivas de compilaci&oacute;n pueden obtenerse en:</p>
<p><a href="https://github.com/jamezilla/ats/tree/master/ats">https://github.com/jamezilla/ats/tree/master/ats</a></p>
<p>Another very good GUI program that can be used for such purposes is Qatsh, a Qt 4 port by Jean-Philippe Meuret. This one can be obtained at: http://sourceforge.net/apps/trac/speed-dreams/browser/subprojects/soundeditor/trunk?rev=5250</p>
<p>Otro muy buen programa GUI que se puede utilizar para tales fines es Qatsh, un puerto Qt 4 de Jean-Philippe Meuret. Este se puede obtener en: Http://sourceforge.net/apps/trac/speed-dreams/browser/subprojects/soundeditor/trunk?rev=5250</p>
<p>&nbsp;</p>
<p>Parameters explanation. How to get a good analysis. What a good analysis is.</p>
<p>Explicaci&oacute;n de los par&aacute;metros. C&oacute;mo obtener un buen an&aacute;lisis. Lo que un buen an&aacute;lisis es.</p>
<p>&nbsp;</p>
<p>The analysis parameters are somewhat numerous, and must be carefully tuned in order to obtain good results. A detailed explanation of the meaning of these parameters can be found at:</p>
<p>Los par&aacute;metros de an&aacute;lisis son algo numerosos y deben ser cuidadosamente ajustados para obtener buenos resultados. Una explicaci&oacute;n detallada del significado de estos par&aacute;metros se puede encontrar en:</p>
<p><a href="http://musica.unq.edu.ar/personales/odiliscia/software/ATSH-doc.htm%20">http://musica.unq.edu.ar/personales/odiliscia/software/ATSH-doc.htm </a></p>
<p>In order to get a good analysis, the sound to be analysed should meet the following requirements:</p>
<p>Con el fin de obtener un buen an&aacute;lisis, el sonido a analizar debe cumplir los siguientes requisitos:</p>
<p>The ATS analysis was meant to analyse isolated, individual sounds. This means that the analysis of sequences and/or superpositions of sounds, though possible, is not likely to render optimal results.</p>
<p>El an&aacute;lisis ATS ten&iacute;a como objetivo analizar los sonidos individuales aislados. Esto significa que el an&aacute;lisis de secuencias y / o superposiciones de sonidos, aunque sea posible, no es probable que produzca resultados &oacute;ptimos.</p>
<p>Must have been recorded with a good signal-to-noise ratio, and should not contain unwanted noises.</p>
<p>Debe haber sido grabado con una buena relaci&oacute;n se&ntilde;al-ruido, y no debe contener ruidos no deseados.</p>
<ol>
<li>Must have been recorded without reverberation and/or echoes.</li>
<li>Debe haber sido grabado sin reverberaci&oacute;n y / o ecos.</li>
</ol>
<p>A good ATS analysis should meet the following requirements:</p>
<p>Un buen an&aacute;lisis ATS debe cumplir con los siguientes requisitos:</p>
<p>Must have a good temporal resolution of the frequency, amplitude, phase and noise (if any) data. The tradeoff between temporal and frequency resolution is a very well known issue in FFT based spectral analysis.</p>
<p>Debe tener una buena resoluci&oacute;n temporal de la frecuencia, la amplitud, la fase y el ruido (si hay) los datos. La compensaci&oacute;n entre la resoluci&oacute;n temporal y de frecuencia es una cuesti&oacute;n muy conocida en el an&aacute;lisis espectral basado en FFT.</p>
<p>The Deterministic and Stochastic (also termed "residual") data must be reasonably separated in their respective ways of representation. This means that, if a sound has both, deterministic and stochastic data, the former must be represented by sinusoidal trajectories, whilst the latter must be represented by energy values among the 25 critical bands. This allows a more effective treatment of both types of data in the synthesis and transformation processes.</p>
<p>Los datos determin&iacute;sticos y estoc&aacute;sticos (tambi&eacute;n llamados residuales) deben estar razonablemente separados en sus respectivas formas de representaci&oacute;n. Esto significa que si un sonido tiene datos deterministas y estoc&aacute;sticos, el primero debe ser representado por trayectorias sinusoidales, mientras que el segundo debe ser representado por valores de energ&iacute;a entre las 25 bandas cr&iacute;ticas. Esto permite un tratamiento m&aacute;s eficaz de ambos tipos de datos en los procesos de s&iacute;ntesis y transformaci&oacute;n.</p>
<ol>
<li>If the analysed sound is pitched, the sinusoidal trajectories (Deterministic) should be as stable as possible and ordered according the original sound harmonics. This means that the trajectory #1 should represent the first (fundamental) harmonic, the trajectory #2 should represent the second harmonic, and so on. This allow to perform easily further transformation processes during resynthesis (such as, for example, selecting the odd harmonics to give them a different treatment than the others).</li>
<li>Si el sonido analizado es lanzado, las trayectorias sinusoidales (Deterministic) deben ser tan estables como sea posible y ordenadas de acuerdo a los arm&oacute;nicos de sonido originales. Esto significa que la trayectoria #1 deber&iacute;a representar el primer arm&oacute;nico (fundamental), la trayectoria #2 debe representar el segundo arm&oacute;nico, y as&iacute; sucesivamente. Esto permite realizar procesos de transformaci&oacute;n f&aacute;cilmente m&aacute;s f&aacute;ciles durante la res&iacute;ntesis (por ejemplo, seleccionar los arm&oacute;nicos impares para darles un tratamiento diferente del de los dem&aacute;s). </li>
</ol>
<p>Whilst the first requirement is unavoidable, in order to get a useful analysis, the second and third ones are sometimes almost impossible to meet in full and their accomplishment depends often on the user objectives.</p>
<p>Si bien el primer requisito es inevitable, para obtener un an&aacute;lisis &uacute;til, el segundo y el tercero a veces son casi imposibles de cumplir en su totalidad y su realizaci&oacute;n depende a menudo de los objetivos del usuario.</p>
<p>&nbsp;3. Synthesizing ATS analysis files. 3. Sintetizar archivos de an&aacute;lisis ATS.</p>
<p>&nbsp;</p>
<p>Synthesis techniques applied to ATS. T&eacute;cnicas de s&iacute;ntesis aplicadas al ATS.</p>
<p>The synthesis techniques that are usually applied in order to get a synthesized sound that resembles the original sound as much as possible are detailed explained in Pampin 20115 and di Liscia 20136 . However, it is worth pointing out that once the proper data is stored in an analysis file, the user is free to read and apply to this data any reasonable transformation/synthesis technique/s, thereby facilitating the creation of new and interesting sounds that need not be similar nor resemble the original sound.</p>
<p>Las t&eacute;cnicas de s&iacute;ntesis que se suelen aplicar con el fin de obtener un sonido sintetizado que se asemeja al sonido original tanto como sea posible se explican detalladamente en Pampin 20115 y di Liscia 20136. Sin embargo, vale la pena se&ntilde;alar que una vez que los datos adecuados se almacenan en un archivo de an&aacute;lisis, el usuario es libre de leer y aplicar a estos datos cualquier t&eacute;cnica de s&iacute;ntesis / transformaci&oacute;n razonable, facilitando as&iacute; la creaci&oacute;n de sonidos nuevos e interesantes que necesitan No sea similar ni se asemeje al sonido original.</p>
<p>Csound Opcodes for Reading ATS files data:</p>
<p>Csound Opcodes para lectura de datos de archivos ATS:</p>
<p><a href="http://www.csounds.com/manual/html/ATSread.html">ATSread</a>, <a href="http://www.csounds.com/manual/html/ATSreadnz.html">ATSreadnz</a>, <a href="http://www.csounds.com/manual/html/ATSbufread.html">ATSbufread</a>, <a href="http://www.csounds.com/manual/html/ATSinterpread.html">ATSinterpread</a>, <a href="http://www.csounds.com/manual/html/ATSpartialtap.html">ATSpartialtap</a>.</p>
<p>The former Csound opcodes were essentially developed to read ATS data from ATS files and were written by Alex Norman.</p>
<p>Los primeros opcodes de Csound fueron esencialmente desarrollados para leer datos ATS de archivos ATS y fueron escritos por Alex Norman.</p>
<p>ATSread</p>
<p>This opcode reads the deterministic ATS data from an ATS file. It outputs frequency/amplitude pairs of a sinusoidal trajectory corresponding to a specific partial number, according to a time pointer that must be delivered. As the unit works at k-rate, the frequency and amplitude data must be interpolated in order to avoid unwanted clicks in the resynthesis.</p>
<p>Este c&oacute;digo de operaci&oacute;n lee los datos ATS determin&iacute;sticos de un archivo ATS. Emite pares de frecuencia / amplitud de una trayectoria sinusoidal correspondiente a un n&uacute;mero parcial espec&iacute;fico, de acuerdo con un puntero de tiempo que se debe entregar. A medida que la unidad trabaja a k-velocidad, los datos de frecuencia y amplitud deben ser interpolados para evitar clics no deseados en la res&iacute;ntesis.</p>
<p>The following example reads and synthesizes the 10 partials of an ATS analysis corresponding to a steady 440 cps flute sound. Since the instrument is designed to synthesize only one partial of the ATS file, the mixing of several of them must be obtained performing several notes in the score (the use of Csound's macros is strongly recommended in this case). Though not the most practical way of synthesizing ATS data, this method facilitates individual control of the frequency and amplitude values of each one of the partials, which is not possible any other way. In the example that follows, even numbered partials are attenuated in amplitude, resulting in a sound that resembles a clarinet. Amplitude and frequency envelopes could also be used in order to affect a time changing weighting of the partials. Finally, the amplitude and frequency values could be used to drive other synthesis units, such as filters or FM synthesis networks of oscillators.</p>
<p>El siguiente ejemplo lee y sintetiza los 10 parciales de un an&aacute;lisis ATS correspondientes a un sonido de flauta constante de 440 cps. Dado que el instrumento est&aacute; dise&ntilde;ado para sintetizar s&oacute;lo una parte del archivo ATS, la mezcla de varias de ellas debe obtenerse realizando varias notas en la partitura (se recomienda encarecidamente el uso de macros Csounds en este caso). Aunque no es la forma m&aacute;s pr&aacute;ctica de sintetizar los datos ATS, este m&eacute;todo facilita el control individual de los valores de frecuencia y amplitud de cada uno de los parciales, lo que no es posible de otra manera. En el ejemplo que sigue, los parciales parciales pares se aten&uacute;an en amplitud, dando como resultado un sonido que se asemeja a un clarinete. Tambi&eacute;n se pueden usar sobres de amplitud y frecuencia para afectar a una ponderaci&oacute;n de cambio de tiempo de los parciales. Finalmente, los valores de amplitud y frecuencia podr&iacute;an utilizarse para impulsar otras unidades de s&iacute;ntesis, tales como filtros o redes de s&iacute;ntesis FM de osciladores.</p>
<p><em><strong>&nbsp; EXAMPLE 05K02_atsread.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1	
iamp = p4                       ;amplitude scaler
ifreq = p5                      ;frequency scaler
ipar = p6                       ;partial required
itab = p7                       ;audio table
iatsfile = p8                   ;ats file

idur ATSinfo iatsfile, 7        ;get duration

ktime line 0, p3, idur          ;time pointer

kfreq, kamp ATSread ktime, iatsfile, ipar        ;get frequency and amplitude values
aamp        interp  kamp                         ;interpolate amplitude values
afreq       interp  kfreq                        ;interpolate frequency values
aout        oscil3  aamp*iamp, afreq*ifreq, itab ;synthesize with amp and freq scaling
	
            out     aout
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; sine wave table
f 1 0 16384 10 1
#define atsfile #"../ats-files/flute-A5.ats"#

;	start	dur	amp	freq	par	tab	atsfile
i1 	0 	3 	1	1	1	1	$atsfile	
i1 	0 	. 	.1	.	2	.	$atsfile
i1 	0 	. 	1	.	3	.	$atsfile
i1 	0 	. 	.1	.	4	.	$atsfile
i1 	0 	. 	1	.	5	.	$atsfile
i1 	0 	. 	.1	.	6	.	$atsfile
i1 	0 	. 	1	.	7	.	$atsfile
i1 	0 	. 	.1	.	8	.	$atsfile
i1 	0 	. 	1	.	9	.	$atsfile
i1 	0 	. 	.1	.	10	.	$atsfile
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia
</pre>
<p>In Csound6, you can use arrays to simplify the code, and to choose different numbers of partials:</p>
<p>En Csound6, puede utilizar matrices para simplificar el c&oacute;digo, y para elegir diferentes n&uacute;meros de parciales:</p>
<p><em><strong>&nbsp; EXAMPLE 05K03_atsread2.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr      = 44100
ksmps   = 32
nchnls  = 1
0dbfs   = 1

gS_ATS_file =         "../ats-files/flute-A5.ats" ;ats file
giSine     ftgen      0, 0, 16384, 10, 1 ; sine wave table


instr Master ;call instr "Play" for each partial
iNumParts  =          p4 ;how many partials to synthesize
idur       ATSinfo    gS_ATS_file, 7 ;get ats file duration

iAmps[]    array      1, .1 ;array for even and odd partials
iParts[]   genarray   1,iNumParts ;creates array [1, 2, ..., iNumParts]

indx       =          0 ;initialize index
 ;loop for number of elements in iParts array
until indx == iNumParts do
  ;call an instance of instr "Play" for each partial
           event_i    "i", "Play", 0, p3, iAmps[indx%2], iParts[indx], idur
indx       +=         1 ;increment index
od ;end of do ... od block

           turnoff ;turn this instrument off as job has been done
endin

instr Play
iamp       =          p4 ;amplitude scaler
ipar       =          p5 ;partial required
idur       =          p6 ;ats file duration

ktime      line       0, p3, idur ;time pointer

kfreq, kamp ATSread   ktime, gS_ATS_file, ipar ;get frequency and amplitude values
aamp       interp     kamp ;interpolate amplitude values
afreq      interp     kfreq ;interpolate frequency values
aout       oscil3     aamp*iamp, afreq, giSine ;synthesize with amp scaling

           out        aout
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;           strt dur number of partials
i "Master"  0    3   1
i .         +    .   3
i .         +    .   10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia and Joachim Heintz</pre>
<h3>ATSreadnz</h3>
<p>This opcode is similar to ATSread in the sense that it reads the noise data of an ATS file, delivering k-rate energy values for the requested critical band. In order to this Opcode to work, the input ATS file must be either type 3 or 4 (types 1 and 2 do not contain noise data). ATSreadnz is simpler than ATSread, because whilst the number of partials of an ATS file is variable, the noise data (if any) is stored always as 25 values per analysis frame each value corresponding to the energy of the noise in each one of the critical bands. The three required arguments are: a time pointer, an ATS file name and the number of critical band required (which, of course, must have a value between 1 and 25).</p>
<p>Este opcode es similar a ATSread en el sentido de que lee los datos de ruido de un archivo ATS, entregando valores de energ&iacute;a k-rate para la banda cr&iacute;tica solicitada. Para que este Opcode funcione, el archivo ATS de entrada debe ser del tipo 3 o 4 (los tipos 1 y 2 no contienen datos de ruido). ATSreadnz es m&aacute;s simple que ATSread, porque mientras que el n&uacute;mero de partiales de un archivo ATS es variable, los datos de ruido (si los hay) se almacenan siempre como 25 valores por cuadro de an&aacute;lisis cada valor correspondiente a la energ&iacute;a del ruido en cada uno de los cr&iacute;ticos alzacuello. Los tres argumentos requeridos son: un puntero de tiempo, un nombre de archivo ATS y el n&uacute;mero de banda cr&iacute;tica requerida (que, por supuesto, debe tener un valor entre 1 y 25).</p>
<p>The following example is similar to the previous. The instrument is designed to synthesize only one noise band of the ATS file, the mixing of several of them must be obtained performing several notes in the score. In this example the synthesis of the noise band is done using Gaussian noise filtered with a resonator (i.e., band-pass) filter. This is not the method used by the ATS synthesis Opcodes that will be further shown, but its use in this example is meant to lay stress again on the fact that the use of the ATS analysis data may be completely independent of its generation. In this case, also, a macro that performs the synthesis of the 25 critical bands was programmed. The ATS file used correspond to a female speech sound that lasts for 3.633 seconds, and in the examples is stretched to 10.899 seconds, that is three times its original duration. This shows one of the advantages of the Deterministic plus Stochastic data representation of ATS: the stochastic ("noisy") part of a signal may be stretched in the resynthesis without the artifacts that arise commonly when the same data is represented by cosine components (as in the FFT based resynthesis). Note that, because the Stochastic noise values correspond to energy (i.e., intensity), in order to get the proper amplitude values, the square root of them must be computed.</p>
<p>El siguiente ejemplo es similar al anterior. El instrumento est&aacute; dise&ntilde;ado para sintetizar s&oacute;lo una banda de ruido del archivo ATS, la mezcla de varios de ellos debe obtenerse realizando varias notas en la partitura. En este ejemplo, la s&iacute;ntesis de la banda de ruido se realiza usando ruido gaussiano filtrado con un filtro de resonador (es decir, paso de banda). Este no es el m&eacute;todo utilizado por la s&iacute;ntesis ATS Opcodes que se mostrar&aacute; m&aacute;s adelante, pero su uso en este ejemplo est&aacute; destinado a poner &eacute;nfasis nuevamente en el hecho de que el uso de los datos de an&aacute;lisis ATS puede ser completamente independiente de su generaci&oacute;n. En este caso, tambi&eacute;n se program&oacute; una macro que realiza la s&iacute;ntesis de las 25 bandas cr&iacute;ticas. El archivo ATS utilizado corresponde a un sonido de voz femenino que dura 3.633 segundos, y en los ejemplos se estira a 10.899 segundos, es decir, tres veces su duraci&oacute;n original. Esto demuestra una de las ventajas de la representaci&oacute;n de datos estoc&aacute;sticos de ATS: la parte estoc&aacute;stica (ruidosa) de una se&ntilde;al puede ser estirada en la res&iacute;ntesis sin los artefactos que surgen com&uacute;nmente cuando los mismos datos est&aacute;n representados por componentes de coseno Res&iacute;ntesis basada en FFT). Obs&eacute;rvese que, debido a que los valores de ruido estoc&aacute;stico corresponden a energ&iacute;a (es decir, intensidad), para obtener los valores de amplitud apropiados, se debe calcular la ra&iacute;z cuadrada de los mismos.</p>
<p><em><strong>&nbsp; EXAMPLE 05K04_atsreadnz.csd</strong></em> </p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1	
itabc = p7                      ;table with the 25 critical band frequency edges
iscal = 1                       ;reson filter scaling factor		
iamp = p4                       ;amplitude scaler
iband = p5                      ;energy band required
if1     table   iband-1, itabc  ;lower edge
if2     table   iband, itabc    ;upper edge
idif    = if2-if1		
icf     = if1 + idif*.5         ;center frequency value
ibw     = icf*p6                ;bandwidth
iatsfile = p8                   ;ats file name

idur    ATSinfo iatsfile, 7     ;get duration

ktime   line    0, p3, idur     ;time pointer

ken     ATSreadnz ktime, iatsfile, iband        ;get frequency and amplitude values
anoise  gauss 1
aout    reson anoise*sqrt(ken), icf, ibw, iscal ;synthesize with amp and freq scaling

        out aout*iamp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; sine wave table
f1 0 16384 10 1
;the 25 critical bands edge's frequencies
f2 0 32 -2 0 100 200 300 400 510 630 770 920 1080 1270 1480 1720 2000 2320 \
           2700 3150 3700 4400 5300 6400 7700 9500 12000 15500 20000

;an ats file name
#define atsfile #"../ats-files/female-speech.ats"#

;a macro that synthesize the noise data along all the 25 critical bands
#define all_bands(start'dur'amp'bw'file)
#
i1 	$start 	$dur 	$amp	1	$bw	2	$file	
i1 	. 	. 	.	2	.	.	$file
i1 	. 	. 	.	3	.	.	.
i1 	. 	. 	.	4	.	.	.
i1 	. 	. 	.	5	.	.	.
i1 	. 	. 	.	6	.	.	.
i1 	. 	. 	.	7	.	.	.
i1 	. 	. 	.	8	.	.	.
i1 	. 	. 	.	9	.	.	.
i1 	. 	. 	.	10	.	.	.
i1 	. 	. 	.	11	.	.	.
i1 	. 	. 	.	12	.	.	.
i1 	. 	. 	.	13	.	.	.
i1 	. 	. 	.	14	.	.	.
i1 	. 	. 	.	15	.	.	.
i1 	. 	. 	.	16	.	.	.
i1 	. 	. 	.	17	.	.	.
i1 	. 	. 	.	18	.	.	.
i1 	. 	. 	.	19	.	.	.
i1 	. 	. 	.	20	.	.	.
i1 	. 	. 	.	21	.	.	.
i1 	. 	. 	.	22	.	.	.
i1 	. 	. 	.	23	.	.	.
i1 	. 	. 	.	24	.	.	.
i1 	. 	. 	.	25	.	.	.
#

;ditto...original sound duration is 3.633 secs.
;stretched 300%
$all_bands(0'10.899'1'.05'$atsfile)

e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia</pre>
<h3>ATSbufread, ATSinterpread, ATSpartialtap.</h3>
<p>The ATSbufread opcode reads an ATS file and stores its frequency and amplitude data into an internal table. The first and third input arguments are the same as in the ATSread and the ATSreadnz Opcodes: a time pointer and an ATS file name. The second input argument is a frequency scaler. The fourth argument is the number of partials to be stored. Finally, this Opcode may take two optional arguments: the first partial and the increment of partials to be read, which default to 0 and 1 respectively.</p>
<p>El opcode ATSbufread lee un archivo ATS y almacena sus datos de frecuencia y amplitud en una tabla interna. Los argumentos de entrada primero y tercero son los mismos que en el ATSread y el ATSreadnz Opcodes: un puntero de tiempo y un nombre de archivo ATS. El segundo argumento de entrada es un escalador de frecuencia. El cuarto argumento es el n&uacute;mero de parciales a almacenar. Finalmente, este Opcode puede tomar dos argumentos opcionales: el primero parcial y el incremento de los partials a leer, que por defecto son 0 y 1 respectivamente.</p>
<p>Although this opcode does not have any output, the ATS frequency and amplitude data is available to be used by other opcode. In this case, two examples are provided, the first one uses the ATSinterpread opcode and the second one uses the ATSpartialtap opcode.</p>
<p>Aunque este c&oacute;digo de operaci&oacute;n no tiene ninguna salida, los datos de frecuencia y amplitud ATS est&aacute;n disponibles para ser utilizados por otro c&oacute;digo de operaci&oacute;n. En este caso, se proporcionan dos ejemplos, el primero utiliza el c&oacute;digo de operaci&oacute;n ATSinterpread y el segundo utiliza el c&oacute;digo de operaci&oacute;n ATSpartialtap.</p>
<p>The ATSinterpread opcode reads an ATS table generated by the ATSbufread opcode and outputs amplitude values interpolating them between the two amplitude values of the two frequency trajectories that are closer to a given frequency value. The only argument that this opcode takes is the desired frequency value.</p>
<p>El c&oacute;digo de operaci&oacute;n ATSinterpread lee una tabla ATS generada por el c&oacute;digo de operaci&oacute;n ATSbufread y emite valores de amplitud interpol&aacute;ndolos entre los dos valores de amplitud de las dos trayectorias de frecuencia que est&aacute;n m&aacute;s cerca de un valor de frecuencia dado. El &uacute;nico argumento que toma este opcode es el valor de frecuencia deseado.</p>
<p>The following example synthesizes five sounds. All the data is taken from the ATS file "test.ats". The first and final sounds match the two frequencies closer to the first and the second partials of the analysis file and have their amplitude values closer to the ones in the original ATS file. The other three sounds (second, third and fourth), have frequencies that are in-between the ones of the first and second partials of the ATS file, and their amplitudes are scaled by an interpolation between the amplitudes of the first and second partials. The more the frequency requested approaches the one of a partial, the more the amplitude envelope rendered by ATSinterpread is similar to the one of this partial. So, the example shows a gradual "morphing" beween the amplitude envelope of the first partial to the amplitude envelope of the second according to their frequency values.</p>
<p>El siguiente ejemplo sintetiza cinco sonidos. Todos los datos se toman del archivo ATS test.ats. Los sonidos primero y final coinciden con las dos frecuencias m&aacute;s cerca de la primera y la segunda parciales del archivo de an&aacute;lisis y tienen sus valores de amplitud m&aacute;s cercanos a los del archivo ATS original. Los otros tres sonidos (segundo, tercero y cuarto) tienen frecuencias que est&aacute;n entre los de la primera y segunda parciales del archivo ATS, y sus amplitudes son escaladas por una interpolaci&oacute;n entre las amplitudes de la primera y segunda parciales. Cuanto m&aacute;s se acerque la frecuencia solicitada a la de un parcial, m&aacute;s amplitud que la envolvente prestada por ATSinterpread es similar a la de este parcial. Por lo tanto, el ejemplo muestra un morphing gradual entre la envolvente de amplitud de la primera parcial a la envolvente de amplitud de la segunda seg&uacute;n sus valores de frecuencia.</p>
<p><em><strong>&nbsp; EXAMPLE 05K05_atsinterpread.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1	

iamp =      p4                  ;amplitude scaler
ifreq =     p5                  ;frequency scaler
iatsfile =  p7                  ;atsfile
itab =      p6                  ;audio table
ifreqscal = 1                   ;frequency scaler
ipars   ATSinfo iatsfile, 3     ;how many partials
idur    ATSinfo iatsfile, 7     ;get duration
ktime   line    0, p3, idur     ;time pointer

        ATSbufread ktime, ifreqscal, iatsfile, ipars ;reads an ATS buffer		
kamp    ATSinterpread ifreq         ;get the amp values according to freq
aamp    interp kamp                               ;interpolate amp values
aout    oscil3 aamp, ifreq, itab                  ;synthesize
	
        out aout*iamp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; sine wave table
f 1 0 16384 10 1
#define atsfile #"../ats-files/test.ats"#

;  start dur amp freq atab atsfile
i1 0     3   1   440  1    $atsfile     ;first partial
i1 +     3   1   550  1    $atsfile     ;closer to first partial
i1 +     3   1   660  1    $atsfile     ;half way between both
i1 +     3   1   770  1    $atsfile     ;closer to second partial
i1 +     3   1   880  1    $atsfile     ;second partial
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia
</pre>
<p>The ATSpartialtap Opcode reads an ATS table generated by the ATSbufread Opcode and outputs the frequency and amplitude k-rate values of a specific partial number. The example presented here uses four of these opcodes that read from a single ATS buffer obtained using ATSbufread in order to drive the frequency and amplitude of four oscillators. This allows the mixing of different combinations of partials, as shown by the three notes triggered by the designed instrument.</p>
<p>El Opcode ATSpartialtap lee una tabla ATS generada por el Opcode ATSbufread y emite los valores de frecuencia y amplitud k-rate de un n&uacute;mero parcial espec&iacute;fico. El ejemplo aqu&iacute; presentado utiliza cuatro de estos opcodes que se leen desde un &uacute;nico buffer ATS obtenido usando ATSbufread para accionar la frecuencia y amplitud de cuatro osciladores. Esto permite la mezcla de diferentes combinaciones de parciales, como lo muestran las tres notas activadas por el instrumento dise&ntilde;ado.</p>
<p>&nbsp;</p>
<p><em><strong>&nbsp; EXAMPLE 05K06_atspartialtap.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1	
iamp =  p4/4            ;amplitude scaler
ifreq = p5              ;frequency scaler
itab =  p6              ;audio table
ip1 =   p7              ;first partial to be synthesized
ip2 =   p8              ;second partial to be synthesized
ip3 =   p9              ;third partial to be synthesized
ip4 =   p10             ;fourth partial to be synthesized
iatsfile = p11          ;atsfile

ipars   ATSinfo iatsfile, 3     ;get how many partials
idur    ATSinfo iatsfile, 7     ;get duration

ktime   line    0, p3, idur     ;time pointer

        ATSbufread ktime, ifreq, iatsfile, ipars ;reads an ATS buffer		

kf1,ka1 ATSpartialtap ip1       ;get the amp values according each partial number
af1     interp kf1
aa1     interp ka1			
kf2,ka2 ATSpartialtap ip2       ;ditto
af2     interp kf2
aa2     interp ka2			
kf3,ka3 ATSpartialtap ip3       ;ditto
af3     interp kf3
aa3     interp ka3			
kf4,ka4 ATSpartialtap ip4       ;ditto
af4     interp kf4
aa4     interp ka4			

a1      oscil3  aa1, af1*ifreq, itab    ;synthesize each partial
a2      oscil3  aa2, af2*ifreq, itab    ;ditto
a3      oscil3  aa3, af3*ifreq, itab    ;ditto
a4      oscil3  aa4, af4*ifreq, itab    ;ditto	
	
        out (a1+a2+a3+a4)*iamp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; sine wave table
f 1 0 16384 10 1
#define atsfile #"../ats-files/oboe-A5.ats"#

;   start dur amp freq atab part#1 part#2 part#3 part#4 atsfile
i1  0     3   10  1    1    1      5      11     13     $atsfile		
i1  +     3   7   1    1    1      6      14     17     $atsfile
i1  +     3   400 1    1    15     16     17     18     $atsfile
	
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia</pre>
<h3>Synthesizing ATS data: ATSadd, ATSaddnz,&nbsp; ATSsinnoi. ATScross.</h3>
<p>The four opcodes that will be presented in this section synthesize ATS analysis data internally and allow for some modifications of these data as well. A significant difference to the preceding opcodes is that the synthesis method cannot be chosen by the user. The synthesis methods used by all of these opcodes are fully explained in: [1] Juan Pampin, 2011. ATS_theory http://wiki.dxarts.washington.edu/groups/general/wiki/39f07/attachments/55bd6/ATS_theory.pdf [2] Oscar Pablo Di Liscia, 2013. A Pure Data toolkit for real-time synthesis of ATS spectral data http://lac.linuxaudio.org/2013/papers/26.pdf</p>
<p>Los cuatro opcodes que se presentar&aacute;n en esta secci&oacute;n sintetizan los datos de an&aacute;lisis ATS internamente y permiten algunas modificaciones de estos datos tambi&eacute;n. Una diferencia significativa con los opcodes anteriores es que el m&eacute;todo de s&iacute;ntesis no puede ser elegido por el usuario. Los m&eacute;todos de s&iacute;ntesis utilizados por todos estos opcodes se explican completamente en: [1] Juan Pampin, 2011. ATS_theory Http://wiki.dxarts.washington.edu/groups/general/wiki/39f07/attachments/55bd6/ATS_theory.pdf [2] Oscar Pablo Di Liscia, 2013. Un kit de herramientas Pure Data para la s&iacute;ntesis en tiempo real de datos espectrales ATS Http://lac.linuxaudio.org/2013/papers/26.pdf</p>
<p>The ATSadd opcode synthesizes deterministic data from an ATS file using an array of table lookup oscillators whose amplitude and frequency values are obtained by linear interpolation of the ones in the ATS file according to the time of the analysis requested by a time pointer (see [2] for more details). The frequency of all the partials may be modified at k-rate, allowing shifting and/or frequency modulation. An ATS file, a time pointer and a function table are required. The table is supposed to contain either a cosine or a sine function, but nothing prevents the user from experimenting with other functions. Some care must be taken in the last case, so as not to produce foldover (frequency aliasing). The user may also request a number of partials smaller than the number of partials of the ATS file (by means of the inpars variable in the example below). There are also two optional arguments: a partial offset (i.e., the first partial that will be taken into account for the synthesis, by means of the ipofst variable in the example below) and a step to select the partials (by means of the inpincr variable in the example below).</p>
<p>El c&oacute;digo de operaci&oacute;n ATSadd sintetiza datos determin&iacute;sticos de un archivo ATS usando una matriz de osciladores de b&uacute;squeda de tabla cuyos valores de amplitud y frecuencia se obtienen por interpolaci&oacute;n lineal de los del archivo ATS seg&uacute;n el tiempo de an&aacute;lisis solicitado por un puntero de tiempo. ] para m&aacute;s detalles). La frecuencia de todos los parciales puede modificarse a k-velocidad, permitiendo el cambio y / o la modulaci&oacute;n de frecuencia. Se requiere un archivo ATS, un puntero de tiempo y una tabla de funciones. Se supone que la tabla contiene una funci&oacute;n coseno o seno, pero nada impide que el usuario experimente con otras funciones. Se debe tener cuidado en el &uacute;ltimo caso, para no producir foldover (aliasing de frecuencia). El usuario tambi&eacute;n puede solicitar un n&uacute;mero de parciales menor que el n&uacute;mero de partiales del archivo ATS (mediante la variable inpars en el ejemplo siguiente). Tambi&eacute;n hay dos argumentos opcionales: un offset parcial (es decir, el primer parcial que se tendr&aacute; en cuenta para la s&iacute;ntesis, mediante la variable ipofst en el ejemplo siguiente) y un paso para seleccionar los parciales (mediante el comando inpincr Variable en el ejemplo siguiente).</p>
<p>Default values for these arguments are 0 and 1 respectively. Finally, the user may define a final optional argument that references a function table that will be used to rescale the amplitude values during the resynthesis. The amplitude values of all the partials along all the frames are rescaled to the table length and used as indexes to lookup a scaling amplitude value in the table. For example, in a table of size 1024, the scaling amplitude of all the 0.5 amplitude values (-6 dBFS) that are found in the ATS file is in the position 512 (1024*0.5). Very complex filtering effects can be obtained by carefully setting these gating tables according to the amplitude values of a particular ATS analysis.</p>
<p>Los valores por defecto para estos argumentos son 0 y 1, respectivamente. Finalmente, el usuario puede definir un argumento opcional final que haga referencia a una tabla de funciones que se utilizar&aacute; para volver a escala los valores de amplitud durante la res&iacute;ntesis. Los valores de amplitud de todos los parciales a lo largo de todos los cuadros se reescalonan a la longitud de la tabla y se utilizan como &iacute;ndices para buscar un valor de amplitud de escala en la tabla. Por ejemplo, en una tabla de tama&ntilde;o 1024, la amplitud de escala de todos los 0,5 valores de amplitud (-6 dBFS) que se encuentran en el archivo ATS est&aacute; en la posici&oacute;n 512 (1024 * 0.5). Se pueden obtener efectos de filtrado muy complejos ajustando cuidadosamente estas tablas de paso seg&uacute;n los valores de amplitud de un an&aacute;lisis ATS particular.</p>
<p>&nbsp;</p>
<p><em><strong>&nbsp; EXAMPLE 05K07_atsadd.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1


;Some macros
#define ATS_NP # 3 #    ;number of Partials
#define ATS_DU # 7 #    ;duration

instr 1	

/*read some ATS data from the file header*/
iatsfile = p11
i_number_of_partials    ATSinfo iatsfile,  $ATS_NP
i_duration              ATSinfo iatsfile,  $ATS_DU

iamp     =      p4              ;amplitude scaler
ifreqdev =      2^(p5/12)       ;frequency deviation (p5=semitones up or down)
itable   =      p6              ;audio table

/*here we deal with number of partials, offset and increment issues*/
inpars  =       (p7 &lt; 1 ? i_number_of_partials : p7)    ;inpars can not be &lt;=0
ipofst  =       (p8 &lt; 0 ? 0 : p8)                       ;partial offset can not be &lt; 0
ipincr  =       (p9 &lt; 1 ? 1 : p9)                       ;partial increment can not be &lt;= 0
imax    =       ipofst + inpars*ipincr                  ;max. partials allowed

if imax &lt;= i_number_of_partials igoto OK 	
;if we are here, something is wrong!
;set npars to zero, so as the output will be zero and the user knows
print imax, i_number_of_partials
inpars  = 0
ipofst  = 0
ipincr  = 1
OK: ;data is OK
/********************************************************************/
igatefn =      p10               ;amplitude scaling table

ktime   linseg 0, p3, i_duration
asig    ATSadd ktime, ifreqdev, iatsfile, itable, inpars, ipofst, ipincr, igatefn

        out    asig*iamp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;

;change to put any ATS file you like
#define ats_file #"../ats-files/basoon-C4.ats"#

;audio table (sine)
f1      0       16384   10      1
;some tables to test amplitude gating
;f2 reduce progressively partials with amplitudes from 0.5 to 1 (-6dBFs to 0 dBFs)
;and eliminate partials with amplitudes below 0.5 (-6dBFs)
f2      0       1024     7      0 512 0 512 1		
;f3 boost partials with amplitudes from 0 to 0.125 (-12dBFs)
;and attenuate partials with amplitudes from 0.125 to 1 (-12dBFs to 0dBFs)
f3      0       1024     -5     8 128 8 896 .001

;   start dur  amp  freq atable npars offset pincr gatefn atsfile
i1  0     2.82 1    0    1      0     0      1     0      $ats_file
i1  +     .    1    0    1      0     0      1     2      $ats_file
i1  +     .    .8   0    1      0     0      1     3      $ats_file

e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia</pre>
<p>The ATSaddnz opcode synthesizes residual ("noise") data from an ATS file using the method explained in [1] and [2]. This opcode works in a similar fashion to ATSadd except that frequency warping of the noise bands is not permitted and the maximum number of noise bands will always be 25 (the 25 critical bands, see Zwiker/Fastl, footnote 3). The optional arguments offset and increment work in a similar fashion to that in ATSadd. The ATSaddnz opcode allows the synthesis of several combinations of noise bands, but individual amplitude scaling of them is not possible.</p>
<p>El c&oacute;digo de operaci&oacute;n ATSaddnz sintetiza los datos residuales (ruido) de un archivo ATS utilizando el m&eacute;todo explicado en [1] y [2]. Este opcode funciona de manera similar a ATSadd, excepto que no se permite la deformaci&oacute;n de frecuencia de las bandas de ruido y el n&uacute;mero m&aacute;ximo de bandas de ruido ser&aacute; siempre 25 (las 25 bandas cr&iacute;ticas, v&eacute;ase Zwiker / Fastl, nota 3). Los argumentos opcionales offset e incremento funcionan de manera similar a la de ATSadd. El c&oacute;digo de operaci&oacute;n ATSaddnz permite la s&iacute;ntesis de varias combinaciones de bandas de ruido, pero no es posible escalar las amplitudes individuales de ellas.</p>
<p><em><strong>&nbsp; EXAMPLE 05K08_atsaddnz.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;Some macros
#define NB      # 25 #  ;number noise bands
#define ATS_DU  # 7 #   ;duration

instr 1	
/*read some ATS data from the file header*/
iatsfile = p8
i_duration ATSinfo iatsfile, $ATS_DU

iamp    =       p4                ;amplitude scaler

/*here we deal with number of partials, offset and increment issues*/
inb     =       (p5 &lt; 1 ? $NB : p5)     ;inb can not be &lt;=0
ibofst  =       (p6 &lt; 0 ? 0 : p6)       ;band offset cannot be &lt; 0
ibincr  =       (p7 &lt; 1 ? 1 : p7)       ;band increment cannot be &lt;= 0
imax    =       ibofst + inb*ibincr     ;max. bands allowed

if imax &lt;= $NB igoto OK 	
;if we are here, something is wrong!
;set nb to zero, so as the output will be zero and the user knows
print imax, $NB
inb  = 0
ibofst	= 0
ibincr	= 1
OK: ;data is OK
/********************************************************************/
ktime   linseg   0, p3, i_duration
asig    ATSaddnz ktime, iatsfile, inb, ibofst, ibincr

        out      asig*iamp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;

;change to put any ATS file you like
#define ats_file #"../ats-files/female-speech.ats"#

;   start dur  amp nbands bands_offset bands_incr atsfile	
i1  0     7.32 1   25     0            1          $ats_file     ;all bands
i1  +     .    .   15     10           1          $ats_file     ;from 10 to 25 step 1
i1  +     .    .   8      1            3          $ats_file     ;from 1 to 24 step 3
i1  +     .    .   5      15           1          $ats_file     ;from 15 to 20 step 1
	
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia
</pre>
<p>The ATSsinnoi opcode synthesizes both deterministic and residual ("noise") data from an ATS file using the method explained in [1] and [2]. This opcode may be regarded as a combination of the two previous opcodes but with the allowance of individual amplitude scaling of the mixes of deterministic and residual parts. All the arguments of ATSsinnoi are the same as those for the two previous opcodes, except for the two k-rate variables ksinlev and knoislev that allow individual, and possibly time-changing, scaling of the deterministic and residual parts of the synthesis.</p>
<p>El c&oacute;digo de operaci&oacute;n ATSsinnoi sintetiza los datos determin&iacute;sticos y residuales (ruido) de un archivo ATS utilizando el m&eacute;todo explicado en [1] y [2]. Este opcode puede considerarse como una combinaci&oacute;n de los dos opcodes anteriores, pero con la posibilidad de escalamiento de amplitud individual de las mezclas de partes determin&iacute;sticas y residuales. Todos los argumentos de ATSsinnoi son los mismos que para los dos opcodes anteriores, excepto para las dos variables de k-ksinlev y knoislev que permiten el escalamiento individual, y posiblemente cambiante, de las partes deterministas y residuales de la s&iacute;ntesis.</p>
<p><em><strong>&nbsp; EXAMPLE 05K09_atssinnoi.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;Some macros
#define ATS_NP  # 3 #   ;number of Partials
#define ATS_DU  # 7 #   ;duration

instr 1	
iatsfile = p11
/*read some ATS data from the file header*/
i_number_of_partials    ATSinfo iatsfile, $ATS_NP
i_duration              ATSinfo iatsfile, $ATS_DU
print i_number_of_partials

iamp     =      p4              ;amplitude scaler
ifreqdev =      2^(p5/12)       ;frequency deviation (p5=semitones up or down)
isinlev  =      p6              ;deterministic part gain
inoislev =      p7              ;residual part gain

/*here we deal with number of partials, offset and increment issues*/
inpars   =      (p8 &lt; 1 ? i_number_of_partials : p8) ;inpars can not be &lt;=0
ipofst   =      (p9 &lt; 0 ? 0 : p9)                    ;partial offset can not be &lt; 0
ipincr   =      (p10 &lt; 1 ? 1 : p10)                  ;partial increment can not be &lt;= 0
imax     =      ipofst + inpars*ipincr               ;max. partials allowed

if imax &lt;= i_number_of_partials igoto OK 	
;if we are here, something is wrong!
;set npars to zero, so as the output will be zero and the user knows
prints "wrong number of partials requested", imax, i_number_of_partials
inpars  = 0
ipofst	= 0
ipincr	= 1
OK: ;data is OK
/********************************************************************/

ktime   linseg     0, p3, i_duration
asig    ATSsinnoi  ktime, isinlev, inoislev, ifreqdev, iatsfile, inpars, ipofst, ipincr

        out        asig*iamp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;change to put any ATS file you like
#define ats_file #"../ats-files/female-speech.ats"#

;       start   dur     amp     freqdev sinlev  noislev npars   offset  pincr   atsfile	
i1      0       3.66    .79     0       1       0       0       0       1       $ats_file
;deterministic only
i1      +       3.66    .79     0       0       1       0       0       1       $ats_file	
;residual only
i1      +       3.66    .79     0       1       1       0       0       1       $ats_file	
;deterministic and residual
;       start   dur     amp     freqdev sinlev  noislev npars   offset  pincr   atsfile	
i1      +       3.66    2.5     0       1       0       80      60      1       $ats_file
;from partial 60 to partial 140, deterministic only
i1      +       3.66    2.5     0       0       1       80      60      1       $ats_file
;from partial 60 to partial 140, residual only
i1      +       3.66    2.5     0       1       1       80      60      1       $ats_file
;from partial 60 to partial 140, deterministic and residual
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia </pre>
<p>ATScross is an opcode that performs some kind of "interpolation" of the amplitude data between two ATS analyses. One of these two ATS analyses must be obtained using the ATSbufread opcode (see above) and the other is to be loaded by an ATScross instance. Only the deterministic data of both analyses is used. The ATS file, time pointer, frequency scaling, number of partials, partial offset and partial increment arguments work the same way as usages in previously described opcodes. Using the arguments kmylev and kbuflev the user may define how much of the amplitude values of the file read by ATSbufread is to be used to scale the amplitude values corresponding to the frequency values of the analysis read by ATScross. So, a value of 0 for kbuflev and 1 for kmylev will retain the original ATS analysis read by ATScross unchanged whilst the converse (kbuflev =1 and kmylev=0) will retain the frequency values of the ATScross analysis but scaled by the amplitude values of the ATSbufread analysis. As the time pointers of both units need not be the same, and frequency warping and number of partials may also be changed, very complex cross synthesis and sound hybridation can be obtained using this opcode.</p>
<p>ATScross es un opcode que realiza alg&uacute;n tipo de interpolaci&oacute;n de los datos de amplitud entre dos an&aacute;lisis ATS. Uno de estos dos an&aacute;lisis ATS se debe obtener usando el opcode ATSbufread (v&eacute;ase arriba) y el otro debe ser cargado por una instancia ATScross. S&oacute;lo se utilizan los datos determin&iacute;sticos de ambos an&aacute;lisis. El archivo ATS, el puntero de tiempo, la escala de frecuencia, el n&uacute;mero de partiales, el desplazamiento parcial y los argumentos de incremento parcial funcionan de la misma manera que los usos en los c&oacute;digos de operaci&oacute;n descritos anteriormente. Utilizando los argumentos kmylev y kbuflev, el usuario puede definir cu&aacute;nto de los valores de amplitud del archivo le&iacute;do por ATSbufread se va a utilizar para escalar los valores de amplitud correspondientes a los valores de frecuencia del an&aacute;lisis le&iacute;do por ATScross. Por lo tanto, un valor de 0 para kbuflev y 1 para kmylev mantendr&aacute; el an&aacute;lisis ATS original le&iacute;do por ATScross sin cambios, mientras que el inverso (kbuflev = 1 y kmylev = 0) conservar&aacute; los valores de frecuencia del an&aacute;lisis ATScross pero escalado por los valores de amplitud de El an&aacute;lisis ATSbufread. Como los indicadores de tiempo de ambas unidades no necesitan ser iguales, y la deformaci&oacute;n de frecuencia y el n&uacute;mero de partiales tambi&eacute;n pueden cambiarse, s&iacute;ntesis cruzada muy compleja y hibridaci&oacute;n de sonido pueden obtenerse usando este c&oacute;digo de operaci&oacute;n.</p>
<p>&nbsp;</p>
<p><em><strong>&nbsp; EXAMPLE 05K10_atscross.csd</strong></em></p>
<p>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;ATS files
#define ats1 #"../ats-files/flute-A5.ats"#
#define ats2 #"../ats-files/oboe-A5.ats"#


instr 1	
iamp    = p4            ;general amplitude scaler

ilev1   = p5            ;level of iats1 partials
ifd1    = 2^(p6/12)     ;frequency deviation for iats1 partials

ilev2   = p7            ;level of ats2 partials
ifd2    = 2^(p8/12)     ;frequency deviation for iats2 partials	

itau    = p9            ;audio table

/*get ats file data*/
inp1  ATSinfo $ats1, 3
inp2  ATSinfo $ats2, 3
idur1 ATSinfo $ats1, 7
idur2 ATSinfo $ats2, 7

ktime   line    0, p3, idur1
ktime2  line    0, p3, idur2

        ATSbufread ktime,  ifd1, $ats1, inp1
aout    ATScross   ktime2, ifd2, $ats2, itau, ilev2, ilev1, inp2

        out        aout*iamp

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;

; sine wave for the audio table
f1 	0 	16384 	10 	1

;  start dur amp lev1 f1  lev2 f2 table
i1 0     2.3 .75 0    0   1    0  1     ;original oboe	
i1 +     .   .   0.25 .   .75  .  .     ;oboe 75%, flute 25%
i1 +     .   .   0.5  .   0.5  .  .     ;oboe 50%, flute 50%
i1 +     .   .   .75  .   .25  .  .     ;oboe 25%, flute 75%
i1 +     .   .   1    .   0    .  .     ;oboe partials with flute's amplitudes

e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by Oscar Pablo Di Liscia &nbsp;
</pre>
<p>&nbsp;</p>
<ol id="InsertNote_NoteList">
<li id="InsertNoteID_6">Juan Pampin. 2011. ATS_theory, <a href="http://wiki.dxarts.washington.edu/groups/general/wiki/39f07/attachments/55bd6/ATS_theory.pdf">http://wiki.dxarts.washington.edu/groups/general/wiki/39f07/attachments/55bd6/ATS_theory.pdf</a><span id="InsertNoteID_6_LinkBacks"><sup><a href="k-ats-resynthesis/k-ats-resynthesis#InsertNoteID_6_marker7">^</a></sup></span></li>
<li id="InsertNoteID_8">Xavier Serra and Julius O. Smith III. 1990. A Sound Analysis/Synthesis System Based on a Deterministic plus Stochastic Decomposition, Computer Music Journal, Vol.14 #4, MIT Press, USA.<span id="InsertNoteID_8_LinkBacks"><sup><a href="k-ats-resynthesis/k-ats-resynthesis#InsertNoteID_8_marker9">^</a></sup></span></li>
<li id="InsertNoteID_10">Ernst Zwiker and Hugo Fastl. 1990. Psychoacoustics Facts and Models. Springer, Berlin, Heidelberg.<span id="InsertNoteID_10_LinkBacks"><sup><a href="k-ats-resynthesis/k-ats-resynthesis#InsertNoteID_10_marker11">^</a></sup></span></li>
<li id="InsertNoteID_12">Cf. Zwiker/Fastl (above footnote).<span id="InsertNoteID_12_LinkBacks"><sup><a href="k-ats-resynthesis/k-ats-resynthesis#InsertNoteID_12_marker13">^</a></sup></span></li>
<li id="InsertNoteID_7">Juan Pampin. 2011. ATS_theory, <a href="http://wiki.dxarts.washington.edu/groups/general/wiki/39f07/attachments/55bd6/ATS_theory.pdf">http://wiki.dxarts.washington.edu/groups/general/wiki/39f07/attachments/55bd6/ATS_theory.pdf</a><span id="InsertNoteID_7_LinkBacks"><sup><a href="k-ats-resynthesis/k-ats-resynthesis#InsertNoteID_7_marker8">^</a></sup></span></li>
<li id="InsertNoteID_9">Oscar Pablo Di Liscia, 2013. A Pure Data toolkit for real-time synthesis of ATS spectral data <a href="http://lac.linuxaudio.org/2013/papers/26.pdf">http://lac.linuxaudio.org/2013/papers/26.pdf</a><span id="InsertNoteID_9_LinkBacks"><sup><a href="k-ats-resynthesis/k-ats-resynthesis#InsertNoteID_9_marker10">^</a></sup></span></li>
</ol>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

