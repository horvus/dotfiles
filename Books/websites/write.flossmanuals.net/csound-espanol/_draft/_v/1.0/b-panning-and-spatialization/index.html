
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: B-Panning-And-Spatialization / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter B. PANNING AND SPATIALIZATION" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter B. PANNING AND SPATIALIZATION" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <h1>PANNING AND SPATIALIZATION</h1>
<h2>Simple Stereo Panning&nbsp;</h2>
<p>Csound provides a large number of opcodes designed to assist in the distribution of sound amongst two or more speakers. These range from opcodes that merely balance a sound between two channels to one that include algorithms to simulate the doppler shift which occurs when sound moves, algorithms that simulate the filtering and inter-aural delay that occurs as sound reaches both our ears and algorithms that simulate distance in an acoustic space.</p>
<p>Csound proporciona un gran n&uacute;mero de opcodes dise&ntilde;ados para ayudar en la distribuci&oacute;n de sonido entre dos o m&aacute;s hablantes. Estos var&iacute;an desde opcodes que simplemente equilibran un sonido entre dos canales a uno que incluye algoritmos para simular el desplazamiento doppler que se produce cuando se mueve el sonido, algoritmos que simulan el filtrado y el retardo interauricular que se produce cuando el sonido alcanza nuestros o&iacute;dos y algoritmos que simulan Distancia en un espacio ac&uacute;stico.</p>
<p>First we will look at some methods of panning a sound between two speakers based on first principles.</p>
<p>En primer lugar vamos a mirar algunos m&eacute;todos de panning un sonido entre dos altavoces basados en los primeros principios.</p>
<p>The simplest method that is typically encountered is to multiply one channel of audio (aSig) by a panning variable (kPan) and to multiply the other side by 1 minus the same variable like this:</p>
<p>El m&eacute;todo m&aacute;s sencillo que normalmente se encuentra es multiplicar un canal de audio (aSig) por una variable panor&aacute;mica (kPan) y multiplicar el otro lado por 1 menos la misma variable como &eacute;sta:</p>
<p>aSigL = aSig * kPan</p>
<pre>aSigR  =  aSig * (1 &ndash; kPan)
          outs aSigL, aSigR
</pre>
<p>kPan should be a value within the range zero and 1. If kPan is 1 all of the signal will be in the left channel, if it is zero, all of the signal will be in the right channel and if it is 0.5 there will be signal of equal amplitude in both the left and the right channels. This way the signal can be continuously panned between the left and right channels.</p>
<p>KPan debe ser un valor dentro del rango cero y 1. Si kPan es 1 toda la se&ntilde;al estar&aacute; en el canal izquierdo, si es cero, toda la se&ntilde;al estar&aacute; en el canal derecho y si es 0.5 habr&aacute; Se&ntilde;al de amplitud igual en los canales izquierdo y derecho. De esta manera, la se&ntilde;al puede ser continuamente explorada entre los canales izquierdo y derecho.</p>
<p>&nbsp;</p>
<p>The problem with this method is that the overall power drops as the sound is panned to the middle.</p>
<p>El problema con este m&eacute;todo es que la potencia total disminuye cuando el sonido se filtra hacia el centro.</p>
<p>&nbsp;</p>
<p>One possible solution to this problem is to take the square root of the panning variable for each channel before multiplying it to the audio signal like this:</p>
<p>Una posible soluci&oacute;n a este problema es tomar la ra&iacute;z cuadrada de la variable panor&aacute;mica para cada canal antes de multiplicarla a la se&ntilde;al de audio como &eacute;sta:</p>
<p>aSigL = aSig * sqrt(kPan)</p>
<pre>aSigR  =     aSig * sqrt((1 &ndash; kPan))
       outs  aSigL, aSigR
</pre>
<p>By doing this, the straight line function of the input panning variable becomes a convex curve, so that less power is lost as the sound is panned centrally.</p>
<p>Haciendo esto, la funci&oacute;n de l&iacute;nea recta de la variable de panor&aacute;mica de entrada se convierte en una curva convexa, de modo que se pierde menos energ&iacute;a a medida que el sonido se proyecta centralmente.</p>
<p>&nbsp;</p>
<p>Using 90&ordm; sections of a sine wave for the mapping produces a more convex curve and a less immediate drop in power as the sound is panned away from the extremities. This can be implemented using the code shown below.</p>
<p>El uso de secciones de 90&ordm; de una onda sinusoidal para la cartograf&iacute;a produce una curva m&aacute;s convexa y una disminuci&oacute;n menos inmediata de la potencia cuando el sonido es alejado de las extremidades. Esto se puede implementar usando el c&oacute;digo que se muestra a continuaci&oacute;n.</p>
<p>aSigL = aSig * sin(kPan*$M_PI_2)</p>
<pre>aSigR  =     aSig * cos(kPan*$M_PI_2)
       outs  aSigL, aSigR
</pre>
<p>(Note that '<span>$M_PI_2' is one of <a title="Ambisonic UDOs" href="http://www.csounds.com/manual/html/define.html">Csound's built in macros</a> and is equivalent to pi/2.)</span></p>
<p>A fourth method, devised by Michael Gogins, places the point of maximum power for each channel slightly before the panning variable reaches its extremity. The result of this is that when the sound is panned dynamically it appears to move beyond the point of the speaker it is addressing. This method is an elaboration of the previous one and makes use of a different 90 degree section of a sine wave. It is implemented using the following code:</p>
<p>Un cuarto m&eacute;todo, ideado por Michael Gogins, coloca el punto de m&aacute;xima potencia para cada canal un poco antes de que la variable de panor&aacute;mica alcance su extremidad. El resultado de esto es que cuando el sonido es explorado din&aacute;micamente parece que se mueve m&aacute;s all&aacute; del punto del altavoz que est&aacute; dirigiendo. Este m&eacute;todo es una elaboraci&oacute;n de la anterior y hace uso de una secci&oacute;n diferente de 90 grados de una onda senoidal. Se implementa con el siguiente c&oacute;digo:</p>
<p>aSigL = aSig * sin((kPan + 0.5) * $M_PI_2)</p>
<pre>aSigR  =     aSig * cos((kPan + 0.5) * $M_PI_2)
       outs  aSigL, aSigR

</pre>
<p>The following example demonstrates all three methods one after the other for comparison. Panning movement is controlled by a slow moving LFO. The input sound is filtered pink noise.</p>
<p>El siguiente ejemplo muestra los tres m&eacute;todos uno tras otro para la comparaci&oacute;n. El movimiento panor&aacute;mico es controlado por un LFO de movimiento lento. El sonido de entrada es el ruido rosa filtrado.</p>
<p><br />&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B01_Pan_stereo.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
sr = 44100
ksmps = 10
nchnls = 2
0dbfs = 1

  instr 1
imethod  =         p4 ; read panning method variable from score (p4)

;---------------- generate a source sound -------------------
a1       pinkish   0.3            ; pink noise
a1       reson     a1, 500, 30, 1 ; bandpass filtered
aPan     lfo       0.5, 1, 1      ; panning controlled by an lfo
aPan     =         aPan + 0.5     ; offset shifted +0.5
;------------------------------------------------------------

 if imethod=1 then
;------------------------ method 1 --------------------------
aPanL    =         aPan
aPanR    =         1 - aPan
;------------------------------------------------------------
 endif

 if imethod=2 then
;------------------------ method 2 --------------------------
aPanL    =       sqrt(aPan)
aPanR    =       sqrt(1 - aPan)
;------------------------------------------------------------
 endif

 if imethod=3 then
;------------------------ method 3 --------------------------
aPanL    =       sin(aPan*$M_PI_2)
aPanR    =       cos(aPan*$M_PI_2)
;------------------------------------------------------------
 endif

 if imethod=4 then
;------------------------ method 4 --------------------------
aPanL   =  sin((aPan + 0.5) * $M_PI_2)
aPanR   =  cos((aPan + 0.5) * $M_PI_2)
;------------------------------------------------------------
 endif

         outs    a1*aPanL, a1*aPanR ; audio sent to outputs
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 4 notes one after the other to demonstrate 4 different methods of panning
; p1 p2  p3   p4(method)
i 1  0   4.5  1
i 1  5   4.5  2
i 1  10  4.5  3
i 1  15  4.5  4
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>&nbsp;</p>
<p>An opcode called pan2 exists which makes it slightly easier for us to implement various methods of panning. The following example demonstrates the three methods that this opcode offers one after the other. The first is the 'equal power' method, the second 'square root' and the third is simple linear. The Csound Manual describes a fourth method but this one does not seem to function currently.</p>
<p>Existe un c&oacute;digo de operaci&oacute;n llamado pan2 que hace que sea un poco m&aacute;s f&aacute;cil para nosotros implementar varios m&eacute;todos de panoramizaci&oacute;n. El siguiente ejemplo muestra los tres m&eacute;todos que este c&oacute;digo de operaci&oacute;n ofrece uno tras otro. La primera es el m&eacute;todo de la igualdad de poder, la segunda ra&iacute;z cuadrada y la tercera es lineal simple. El Manual de Csound describe un cuarto m&eacute;todo pero &eacute;ste no parece funcionar actualmente.</p>
<p><br />&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B02_pan2.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
sr = 44100
ksmps = 10
nchnls = 2
0dbfs = 1

&nbsp; instr 1
imethod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p4 ; read panning method variable from score (p4)
;----------------------- generate a source sound ------------------------
aSig&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pinkish&nbsp;&nbsp; 0.5              ; pink noise
aSig&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reson&nbsp;&nbsp;&nbsp;&nbsp; aSig, 500, 30, 1 ; bandpass filtered
;------------------------------------------------------------------------

;---------------------------- pan the signal ----------------------------
aPan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.5, 1, 1        ; panning controlled by an lfo
aPan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aPan + 0.5       ; DC shifted + 0.5
aSigL, aSigR&nbsp;&nbsp; pan2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aSig, aPan, imethod; create stereo panned output
;------------------------------------------------------------------------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aSigL, aSigR     ; audio sent to outputs
&nbsp; endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 3 notes one after the other to demonstrate 3 methods used by pan2
;p1 p2&nbsp; p3&nbsp;&nbsp; p4
i 1&nbsp; 0&nbsp; 4.5&nbsp;&nbsp; 0 ; equal power (harmonic)
i 1&nbsp; 5&nbsp; 4.5&nbsp;&nbsp; 1 ; square root method
i 1 10&nbsp; 4.5&nbsp;&nbsp; 2 ; linear
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;&nbsp;</pre>
<p>In the next example we will generate some sounds as the primary signal. We apply some delay and reverb to this signal to produce a secondary signal. A random function will pan the primary signal between the channels, but the secondary signal remains panned in the middle all the time.</p>
<p>En el siguiente ejemplo generaremos algunos sonidos como la se&ntilde;al primaria. Aplicamos un cierto retardo y reverb a esta se&ntilde;al para producir una se&ntilde;al secundaria. Una funci&oacute;n aleatoria desplazar&aacute; la se&ntilde;al primaria entre los canales, pero la se&ntilde;al secundaria permanecer&aacute; en el centro todo el tiempo.</p>
<p><em><strong>&nbsp;&nbsp; EXAMPLE 05B03_Different_pan_layers.csd</strong> </em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac -d
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Bjorn Houdorf, March 2013

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
           seed       0

instr 1
ktrig      metro      0.8; Trigger frequency, instr. 2
           scoreline  "i 2 0 4", ktrig
endin

instr 2
ital       random     60, 72; random notes
ifrq       =          cpsmidinn(ital)
knumpart1  oscili     4, 0.1, 1
knumpart2  oscili     5, 0.11, 1
; Generate primary signal.....
asig       buzz       0.1, ifrq, knumpart1*knumpart2+1, 1
ipan       random     0, 1; ....make random function...
asigL, asigR pan2     asig, ipan, 1; ...pan it...
           outs       asigL, asigR ;.... and output it..
kran1      randomi    0,4,3
kran2      randomi    0,4,3
asigdel1   delay      asig, 0.1+i(kran1)
asigdel2   delay      asig, 0.1+i(kran2)
; Make secondary signal...
aL, aR     reverbsc   asig+asigdel1, asig+asigdel2, 0.9, 15000
           outs       aL, aR; ...and output it
endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f1 0 8192 10 1
i1 0 60
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>3D Binaural Encoding&nbsp;</h2>
<p>3D binaural encoding is available through a number of opcodes that make use of spectral data files that provide information about the filtering and inter-aural delay effects of the human head. The oldest one of these is hrtfer. Newer ones are hrtfmove, hrtfmove2 and hrtfstat. The main parameters for control of the opcodes are azimuth (the horizontal direction of the source expressed as an angle formed from the direction in which we are facing) and elevation (the angle by which the sound deviates from this horizontal plane, either above or below). Both these parameters are defined in degrees. 'Binaural' infers that the stereo output of this opcode should be listened to using headphones so that no mixing in the air of the two channels occurs before they reach our ears (although a degree of effect is still audible through speakers).</p>
<p>La codificaci&oacute;n binaural 3D est&aacute; disponible a trav&eacute;s de una serie de opcodes que hacen uso de archivos de datos espectrales que proporcionan informaci&oacute;n sobre el filtrado y los efectos de retardo interauricular de la cabeza humana. El m&aacute;s antiguo es el hrtfer. Los m&aacute;s nuevos son hrtfmove, hrtfmove2 y hrtfstat. Los principales par&aacute;metros para el control de los opcodes son azimut (la direcci&oacute;n horizontal de la fuente expresada como un &aacute;ngulo formado a partir de la direcci&oacute;n en la que nos enfrentamos) y elevaci&oacute;n (el &aacute;ngulo por el cual el sonido se desv&iacute;a de este plano horizontal, ya sea por encima o por debajo ). Ambos par&aacute;metros se definen en grados. Binaural infiere que la salida est&eacute;reo de este opcode debe ser escuchada usando auriculares de modo que no se produzca ninguna mezcla en el aire de los dos canales antes de que lleguen a nuestros o&iacute;dos (aunque un grado de efecto es todav&iacute;a audible a trav&eacute;s de altavoces).</p>
<p>The following example take a monophonic source sound of noise impulses and processes it using the hrtfmove2 opcode. First of all the sound is rotated around us in the horizontal plane then it is raised above our head then dropped below us and finally returned to be level and directly in front of us. For this example to work you will need to download the files hrtf-44100-left.dat and hrtf-44100-right.dat (a place to download them may be here) and place them in your SADIR (see setting environment variables) or in the same directory as the .csd.</p>
<p>El ejemplo siguiente toma un sonido de fuente monof&oacute;nica de impulsos de ruido y lo procesa usando el c&oacute;digo de operaci&oacute;n hrtfmove2. En primer lugar el sonido se gira alrededor de nosotros en el plano horizontal, entonces se eleva por encima de nuestra cabeza, luego cay&oacute; por debajo de nosotros y finalmente volvi&oacute; a ser nivel y directamente delante de nosotros. Para que este ejemplo funcione necesitar&aacute; descargar los archivos hrtf-44100-left.dat y hrtf-44100-right.dat (un lugar para descargarlos puede estar aqu&iacute;) y colocarlos en su SADIR (vea configuraci&oacute;n de variables de entorno) o En el mismo directorio que el archivo .csd.</p>
<p><br />&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B04_hrtfmove.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 10
nchnls = 2
0dbfs = 1

giSine         ftgen       0, 0, 2^12, 10, 1             ; sine wave
giLFOShape     ftgen       0, 0, 131072, 19, 0.5,1,180,1 ; U-shape parabola

  instr 1
; create an audio signal (noise impulses)
krate          oscil       30,0.2,giLFOShape            ; rate of impulses
; amplitude envelope: a repeating pulse
kEnv           loopseg     krate+3,0, 0,1, 0.05,0, 0.95,0,0
aSig           pinkish     kEnv                             ; noise pulses

; -- apply binaural 3d processing --
; azimuth (direction in the horizontal plane)
kAz            linseg      0, 8, 360
; elevation (held horizontal for 8 seconds then up, then down, then horizontal
kElev          linseg      0, 8,   0, 4, 90, 8, -40, 4, 0
; apply hrtfmove2 opcode to audio source - create stereo ouput
aLeft, aRight  hrtfmove2   aSig, kAz, kElev, \
                               "hrtf-44100-left.dat","hrtf-44100-right.dat"
               outs        aLeft, aRight                 ; audio to outputs
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 24 ; instr 1 plays a note for 24 seconds
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2 style="-qt-paragraph-type: empty; -qt-block-indent: 0; text-indent: 0px; margin: 0px;">Going Multichannel</h2>
<p>So far we have only considered working in 2-channels/stereo, but Csound is extremely flexible at working in more that 2 channels. By changing nchnls in the orchestra header we can specify any number of channels but we also need to ensure that we choose an audio hardware device using -odac that can handle multichannel audio. Audio channels sent from Csound, that do not address hardware channels, will simply not be reproduced. There may be some need to make adjustments to the software settings of your soundcard using its own software or the operating system's software, but due to the variety of sound hardware options available, it would be impossible to offer further specific advice here.</p>
<p>Hasta ahora s&oacute;lo hemos considerado trabajar en 2 canales / est&eacute;reo, pero Csound es extremadamente flexible al trabajar en m&aacute;s de 2 canales. Al cambiar nchnls en la cabecera de la orquesta podemos especificar cualquier n&uacute;mero de canales, pero tambi&eacute;n tenemos que asegurarnos de que elegimos un dispositivo de hardware de audio utilizando -odac que puede manejar audio multicanal. Los canales de audio enviados desde Csound, que no abordan los canales de hardware, simplemente no se reproducir&aacute;n. Puede que sea necesario realizar ajustes en la configuraci&oacute;n del software de su tarjeta de sonido utilizando su propio software o el software de los sistemas operativos, pero debido a la variedad de opciones de hardware de sonido disponibles, ser&iacute;a imposible ofrecer m&aacute;s consejos espec&iacute;ficos aqu&iacute;.</p>
<p>&nbsp;</p>
<p>Sending Multichannel Sound to the Loudspeakers</p>
<p>Env&iacute;o de sonido multicanal a los altavoces</p>
<p>In order to send multichannel audio we must use opcodes designed for that task. So far we have used outs to send stereo sound to a pair of loudspeakers. (The 's' actually stands for 'stereo'). Correspondingly there exist opcodes for quadophonic (outq), hexaphonic (outh), octophonic (outo), 16-channel sound (outx) and 32-channel sound (out32).</p>
<p>Para enviar audio multicanal debemos usar los opcodes dise&ntilde;ados para esa tarea. Hasta ahora hemos utilizado outs para enviar sonido est&eacute;reo a un par de altavoces. (El s en realidad significa est&eacute;reo). Correspondientemente existen opcodes para sonido quadof&oacute;nico (outq), hexaf&oacute;nico (outh), octophonic (outo), 16 canales (outx) y sonido de 32 canales (out32).</p>
<p>For example:</p>
<pre> outq  a1, a2, a3, a4
</pre>
<p>sends four independent audio streams to four hardware channels. Any unrequired channels still have to be given an audio signal. A typical workaround would be to give them 'silence'. For example if only 5 channels were required:</p>
<p>Env&iacute;a cuatro flujos de audio independientes a cuatro canales de hardware. Cualquier canal no requerido debe recibir una se&ntilde;al de audio. Una soluci&oacute;n t&iacute;pica ser&iacute;a darles silencio. Por ejemplo, si s&oacute;lo se necesitaban 5 canales:</p>
<p>nchnls&nbsp; =&nbsp; 6</p>
<pre>; --snip--

aSilence =&nbsp;   0
         outh a1, a2, a3, a4, a5, aSilence
</pre>
<p>These opcodes only address very specific loudspeaker arrangements (although workarounds are possible) and have been superseded, to a large extent, by newer opcodes that allow greater flexibility in the number and routing of audio to a multichannel output.</p>
<p>Estos opcodes s&oacute;lo se dirigen a arreglos de altavoz muy espec&iacute;ficos (aunque son posibles soluciones) y han sido sustituidos, en gran medida, por nuevos opcodes que permiten una mayor flexibilidad en el n&uacute;mero y enrutamiento de audio a una salida multicanal.</p>
<p>outc allows us to address any number of output audio channels, but they still need to be addressed sequentially. For example our 5-channel audio could be design as follows:</p>
<p>Outc nos permite dirigir cualquier n&uacute;mero de canales de audio de salida, pero todav&iacute;a necesitan ser dirigidos secuencialmente. Por ejemplo, nuestro audio de 5 canales podr&iacute;a ser dise&ntilde;ado de la siguiente manera:</p>
<p>nchnls&nbsp; =&nbsp; 5</p>
<pre>; --snip--

    outc a1, a2, a3, a4, a5</pre>
<p>outch allows us to direct audio to a specific channel or list of channels and takes the form:</p>
<p>Outch nos permite dirigir el audio a un canal espec&iacute;fico o una lista de canales y toma la forma:</p>
<p><span class="command"><strong>outch</strong></span> kchan1, asig1 [, kchan2] [, asig2] [...]</p>
<p>For example, our 5-channel audio system could be designed using outch as follows:</p>
<p>Por ejemplo, nuestro sistema de audio de 5 canales se puede dise&ntilde;ar utilizando outch de la siguiente manera:</p>
<p>nchnls&nbsp; =&nbsp; 5</p>
<pre>; --snip--

    outch 1,a1, 2,a2, 3,a3, 4,a4, 5,a5</pre>
<p>Note that channel numbers can be changed at k-rate thereby opening the possibility of changing the speaker configuration dynamically during performance. Channel numbers do not need to be sequential and unrequired channels can be left out completely. This can make life much easier when working with complex systems employing many channels.</p>
<p>Tenga en cuenta que los n&uacute;meros de canal se pueden cambiar a velocidad k, abriendo as&iacute; la posibilidad de cambiar din&aacute;micamente la configuraci&oacute;n del altavoz durante el rendimiento. Los n&uacute;meros de canal no necesitan ser secuenciales y los canales no requeridos pueden quedar completamente fuera. Esto puede hacer la vida mucho m&aacute;s f&aacute;cil cuando se trabaja con sistemas complejos que emplean muchos canales.</p>
<p>Flexibly Moving Between Stereo and Multichannel</p>
<p>Movimiento flexible entre est&eacute;reo y multicanal</p>
<p>It may be useful to be able to move between working in multichannel (beyond stereo) and then moving back to stereo (when, for example, a multichannel setup is not available). It won't be sufficient to simply change nchnls = 2. It will also be necessary to change all outq, outo, outch etc to outs. In complex orchestras this could laboursome and particularly so if it is required to go back to a multichannel configuration later on. In this situation conditional outputs based on the nchnls value are useful. For example:</p>
<p>Puede ser &uacute;til poder moverse entre trabajar en multicanal (m&aacute;s all&aacute; del est&eacute;reo) y volver a est&eacute;reo (cuando, por ejemplo, no est&aacute; disponible una configuraci&oacute;n multicanal). No ser&aacute; suficiente simplemente cambiar nchnls = 2. Tambi&eacute;n ser&aacute; necesario cambiar todo outq, outo, outch etc. a outs. En las orquestas complejas esto podr&iacute;a ser laborioso y particularmente si es necesario volver a una configuraci&oacute;n multicanal m&aacute;s adelante. En esta situaci&oacute;n son &uacute;tiles las salidas condicionales basadas en el valor nchnls. Por ejemplo:</p>
<p>&nbsp;</p>
<p>if nchnls==4 then</p>
<pre>     outq  a1,a2,a3,a4
 elseif nchnls==2 then
     outs  a1+a3, a2+a4
 endif
</pre>
<p>Using this method, it will only be required to change nchnls = ... in the orchestra header. In stereo mode, if nchnls = 2, at least all audio streams will be monitored, even if the results do not reflect the four channel spatial arrangement.</p>
<p>Utilizando este m&eacute;todo, s&oacute;lo ser&aacute; necesario cambiar nchnls = ... en el encabezado de la orquesta. En modo est&eacute;reo, si nchnls = 2, al menos todas las secuencias de audio ser&aacute;n monitoreadas, incluso si los resultados no reflejan la disposici&oacute;n espacial de cuatro canales.</p>
<p>&nbsp;</p>
<p>Rendering Multichannel Audio Streams as Sound Files</p>
<p>Reproducci&oacute;n de flujos de audio multicanal como archivos de sonido</p>
<p>&nbsp;</p>
<p>So far we have referred to outs, outo etc. as a means to send audio to the speakers but strictly speaking they are only sending audio to Csound's output (as specified by nchnls) and the final destination will be defined using a command line flag in . -odac will indeed instruct Csound to send audio to the audio hardware and then onto the speakers but we can alternatively send audio to a sound file using -oSoundFile.wav. Provided a file type that supports multichannel interleaved data is chosen (".wav" will work), a multichannel file will be created that can be used in some other audio applications or can be re-read by Csound later on by using, for example, diskin2. This method is useful for rendering audio that is too complex to be monitored in real-time. Only single interleaved sound files can be created, separate mono files cannot be created using this method. Simultaneously monitoring the audio generated by Csound whilst rendering will not be possible when using this method; we must choose one or the other.</p>
<p>Hasta ahora nos hemos referido a out, outo etc. como un medio para enviar audio a los altavoces, pero estrictamente hablando s&oacute;lo est&aacute;n enviando audio a la salida Csounds (como se especifica por nchnls) y el destino final se definir&aacute; usando un indicador de l&iacute;nea de comandos en CsOptions / CsOptions. -odac instruir&aacute; a Csound para enviar audio al hardware de audio y luego a los altavoces, pero podemos alternativamente enviar audio a un archivo de sonido usando -oSoundFile.wav. Siempre que se elija un tipo de archivo que admita datos entrelazados multicanal (funciona .wav), se crear&aacute; un archivo multicanal que se puede utilizar en algunas otras aplicaciones de audio o puede volver a leerlo por Csound m&aacute;s adelante usando, por ejemplo, diskin2 . Este m&eacute;todo es &uacute;til para renderizar audio que es demasiado complejo para ser monitoreado en tiempo real. S&oacute;lo se pueden crear archivos de sonido intercalados individuales, no se pueden crear archivos mono independientes utilizando este m&eacute;todo. Simult&aacute;neamente la supervisi&oacute;n del audio generado por Csound mientras que la representaci&oacute;n no ser&aacute; posible al usar este m&eacute;todo; Debemos elegir uno u otro.</p>
<p>&nbsp;</p>
<p>An alternative method of rendering audio in Csound, and one that will allow simulatenous monitoring in real-time, is to use the fout opcode. For example:</p>
<p>Un m&eacute;todo alternativo de renderizar audio en Csound, y uno que permita el monitoreo simult&aacute;neo en tiempo real, es usar el opcode fout. Por ejemplo:</p>
<p>&nbsp;</p>
<p><span class="command">fout</span> "FileName.wav", 8, a1, a2, a3, a4</p>
<pre>outq  a1, a2, a3, a4
</pre>
<p>&nbsp;</p>
<p>will render an interleaved, 24-bit, 4-channel sound file whilst simultaneously sending the quadrophonic audio to the loudspeakers.</p>
<p>Renderizar&aacute; un archivo de sonido intercalado de 24 bits y 4 canales mientras env&iacute;a simult&aacute;neamente el audio cuadraf&oacute;nico a los altavoces.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>If we wanted to de-interleave an interleaved sound file into multiple mono sound files we could use the code:</p>
<p>Si queremos desintercalar un archivo de sonido entrelazado en varios archivos de sonido mono, podr&iacute;amos usar el c&oacute;digo:</p>
<p>a1, a2, a3, a4 soundin "4ChannelSoundFile.wav"</p>
<pre><span class="command"> fout</span>      "Channel1.wav", 8, a1
<span class="command"> fout</span>      "Channel2.wav", 8, a2
<span class="command"> fout</span>      "Channel3.wav", 8, a3
<span class="command"> fout</span>      "Channel4.wav", 8, a4&nbsp;
</pre>
<h2 style="-qt-paragraph-type: empty; -qt-block-indent: 0; text-indent: 0px; margin: 0px;">VBAP</h2>
<p>Vector Base Amplitude Panning1 can be described as a method which extends stereo panning to more than two speakers. The number of speakers is, in general, arbitrary. You can configure for standard layouts such as quadrophonic, octophonic or 5.1 configuration, but in fact any number of speakers can be positioned even in irregular distances from each other. If you are fortunate enough to have speakers arranged at different heights, you can even configure VBAP for three dimensions.</p>
<p>Amplitud de base vectorial Panning1 se puede describir como un m&eacute;todo que extiende la panor&aacute;mica est&eacute;reo a m&aacute;s de dos altavoces. El n&uacute;mero de hablantes es, en general, arbitrario. Puede configurar los dise&ntilde;os est&aacute;ndar, como la configuraci&oacute;n cuadraf&oacute;nica, octof&oacute;nica o 5.1, pero de hecho cualquier n&uacute;mero de altavoces se puede colocar incluso en distancias irregulares entre s&iacute;. Si tienes la suerte de tener altavoces dispuestos a diferentes alturas, incluso puedes configurar VBAP para tres dimensiones.</p>
<p>&nbsp;</p>
<p>Basic Steps</p>
<p>First you must tell VBAP where your loudspeakers are positioned. Let us assume you have seven speakers in the positions and numberings outlined below (M = middle/centre):</p>
<p><img src="static/05B_VBAP_LS_konfig.jpg" alt="" width="600" height="424" /></p>
<p>Primero debes decirle a VBAP d&oacute;nde est&aacute;n tus altavoces. Supongamos que tiene siete oradores en las posiciones y numeraciones siguientes (M = centro / centro):</p>
<p>&nbsp;</p>
<p>The opcode vbaplsinit, which is usually placed in the header of a Csound orchestra, defines these positions as follows:</p>
<p>El opcode vbaplsinit, que normalmente se coloca en el encabezado de una orquesta Csound, define estas posiciones de la siguiente manera:</p>
<p>&nbsp;</p>
<p>vbaplsinit 2, 7, -40, 40, 70, 140, 180, -110, -70</p>
<p>The first number determines the number of dimensions (here 2). The second number states the overall number of speakers, then followed by the positions in degrees (clockwise).</p>
<p>&nbsp;</p>
<p>El primer n&uacute;mero determina el n&uacute;mero de dimensiones (aqu&iacute; 2). El segundo n&uacute;mero indica el n&uacute;mero total de altavoces, seguido de las posiciones en grados (sentido horario).</p>
<p>All that is required now is to provide vbap with a monophonic sound source to be distributed amongst the speakers according to information given about the position. Horizontal position (azimuth) is expressed in degrees clockwise just as the initial locations of the speakers were. The following would be the Csound code to play the sound file "ClassGuit.wav" once while moving it counterclockwise:&nbsp;</p>
<p>Todo lo que se requiere ahora es proporcionar a vbap una fuente de sonido monof&oacute;nica que se distribuir&aacute; entre los altavoces de acuerdo con la informaci&oacute;n proporcionada sobre la posici&oacute;n. La posici&oacute;n horizontal (acimut) se expresa en grados en el sentido de las agujas del reloj tal y como eran las localizaciones iniciales de los altavoces. Lo siguiente ser&iacute;a el c&oacute;digo Csound para reproducir el archivo de sonido ClassGuit.wav una vez mientras se mueve hacia la izquierda:</p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B05_VBAP_circle.csd</em></strong></p>
<p>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -d ;for the next line, change to your folder
--env:SSDIR+=/home/jh/Joachim/Csound/FLOSS/audio
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32	
0dbfs = 1
nchnls = 7

vbaplsinit 2, 7, -40, 40, 70, 140, 180, -110, -70

  instr 1
Sfile      =          "ClassGuit.wav"
iFilLen    filelen    Sfile
p3         =          iFilLen
aSnd, a0   soundin    Sfile
kAzim      line       0, p3, -360 ;counterclockwise
a1, a2, a3, a4, a5, a6, a7, a8 vbap8 aSnd, kAzim
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>In the CsOptions tag, you see the option --env:SSDIR+= ... as a possibility to add a folder to the path in which Csound usually looks for your samples (SSDIR = Sound Sample Directory) if you call them only by name, without the full path. To play the full length of the sound file (without prior knowledge of its duration) the filelen opcode is used to derive this duration, and then the duration of this instrument (p3) is set to this value. The p3 given in the score section (here 1) is overwritten by this value.</p>
<p>En la etiqueta CsOptions, se ve la opci&oacute;n --env: SSDIR = ... como una posibilidad de agregar una carpeta a la ruta en la que Csound suele buscar sus muestras (SSDIR = Sound Sample Directory) si las llama solo por su nombre , Sin el camino completo. Para reproducir toda la longitud del archivo de sonido (sin conocimiento previo de su duraci&oacute;n) se utiliza el opcode filelen para derivar esta duraci&oacute;n, y entonces la duraci&oacute;n de este instrumento (p3) se ajusta a este valor. El p3 dado en la secci&oacute;n de puntuaci&oacute;n (aqu&iacute; 1) se sobrescribe por este valor.</p>
<p>&nbsp;</p>
<p>The circular movement is a simple k-rate line signal, from 0 to -360 across the duration of the sound file (in this case the same as p3). Note that we have to use the opcode vbap8 here, as there is no vbap7. Just give the eighth channel a variable name (a8) and thereafter ignore it.</p>
<p>El movimiento circular es una simple se&ntilde;al de l&iacute;nea k-rate, de 0 a -360 a trav&eacute;s de la duraci&oacute;n del archivo de sonido (en este caso lo mismo que p3). Tenga en cuenta que tenemos que usar el opcode vbap8 aqu&iacute;, ya que no hay vbap7. Simplemente d&eacute; al octavo canal un nombre de variable (a8) y luego ign&oacute;relo.</p>
<p>&nbsp;</p>
<p>The Spread Parameter</p>
<p>As VBAP derives from a panning paradigm, it has one problem which becomes more serious as the number of speakers increases. Panning between two speakers in a stereo configuration means that all speakers are active. Panning between two speakers in a quadro configuration means that half of the speakers are active. Panning between two speakers in an octo configuration means that only a quarter of the speakers are active and so on; so that the actual perceived extent of the sound source becomes unintentionally smaller and smaller.</p>
<p>Como VBAP deriva de un paradigma de panoramizaci&oacute;n, tiene un problema que se vuelve m&aacute;s grave a medida que aumenta el n&uacute;mero de hablantes. El balanceo entre dos altavoces en una configuraci&oacute;n est&eacute;reo significa que todos los altavoces est&aacute;n activos. El desplazamiento entre dos altavoces en una configuraci&oacute;n de cuadro significa que la mitad de los altavoces est&aacute;n activos. El desplazamiento entre dos altavoces en una configuraci&oacute;n de octo significa que s&oacute;lo una cuarta parte de los altavoces est&aacute;n activos y as&iacute; sucesivamente; De modo que la medida percibida real de la fuente de sonido se vuelve involuntariamente m&aacute;s peque&ntilde;a y m&aacute;s peque&ntilde;a.</p>
<p>To alleviate this tendency, Ville Pulkki has introduced an additional parameter, called 'spread', which has a range of zero to hundred percent.2 The 'ascetic' form of VBAP we have seen in the previous example, means: no spread (0%). A spread of 100% means that all speakers are active, and the information about where the sound comes from is nearly lost.</p>
<p>Para aliviar esta tendencia, Ville Pulkki ha introducido un par&aacute;metro adicional, llamado spread, que tiene un rango de cero a cien por ciento.2 La forma asc&eacute;tica de VBAP que hemos visto en el ejemplo anterior, significa: no propagaci&oacute;n (0%). Una extensi&oacute;n del 100% significa que todos los altavoces est&aacute;n activos, y la informaci&oacute;n sobre d&oacute;nde viene el sonido est&aacute; casi perdida.</p>
<p>&nbsp;</p>
<p>As the kspread input to the vbap8 opcode is the second of two optional parameters, we first have to provide the first one. kelev defines the elevation of the sound - it is always zero for two dimensions, as in the speaker configuration in our example. The next example adds a spread movement to the previous one. The spread starts at zero percent, then increases to hundred percent, and then decreases back down to zero.&nbsp;</p>
<p>Como la entrada kspread al c&oacute;digo de operaci&oacute;n vbap8 es el segundo de dos par&aacute;metros opcionales, primero debemos proporcionar el primero. Kelev define la elevaci&oacute;n del sonido - siempre es cero para dos dimensiones, como en la configuraci&oacute;n de altavoces en nuestro ejemplo. El siguiente ejemplo a&ntilde;ade un movimiento de propagaci&oacute;n al anterior. El spread comienza en cero por ciento, luego aumenta a cien por ciento, y luego disminuye de nuevo a cero.</p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B06_VBAP_spread.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -d ;for the next line, change to your folder
--env:SSDIR+=/home/jh/Joachim/Csound/FLOSS/audio
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32	
0dbfs = 1
nchnls = 7

vbaplsinit 2, 7, -40, 40, 70, 140, 180, -110, -70

  instr 1
Sfile      =          "ClassGuit.wav"
iFilLen    filelen    Sfile
p3         =          iFilLen
aSnd, a0   soundin    Sfile
kAzim      line       0, p3, -360
kSpread    linseg     0, p3/2, 100, p3/2, 0
a1, a2, a3, a4, a5, a6, a7, a8 vbap8 aSnd, kAzim, 0, kSpread
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h3>New VBAP Opcodes</h3>
<p>As a response to a number of requests, John fFitch has written new VBAP opcodes in 2012 whose main goal is to allow more than one loudspeaker configuration within a single orchestra (so that you can switch between them during performance) and to provide more flexibility in the number of output channels used. Here is an example for three different configurations which are called in three different instruments:&nbsp;</p>
<p>Como respuesta a una serie de solicitudes, John fFitch ha escrito nuevos opcodes VBAP en 2012 cuyo objetivo principal es permitir m&aacute;s de una configuraci&oacute;n de altavoz dentro de una sola orquesta (para que pueda cambiar entre ellos durante el rendimiento) y proporcionar m&aacute;s flexibilidad en El n&uacute;mero de canales de salida utilizados. Aqu&iacute; hay un ejemplo para tres configuraciones diferentes que se llaman en tres instrumentos diferentes:</p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B07_VBAP_new.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -d ;for the next line, change to your folder
--env:SSDIR+=/home/jh/Joachim/Csound/FLOSS/audio
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32	
0dbfs = 1
nchnls = 7

vbaplsinit 2.01, 7, -40, 40, 70, 140, 180, -110, -70
vbaplsinit 2.02, 2, -40, 40
vbaplsinit 2.03, 3, -70, 180, 70

  instr 1
aSnd, a0   soundin    "ClassGuit.wav"
kAzim      line       0, p3, -360
a1, a2, a3, a4, a5, a6, a7 vbap aSnd, kAzim, 0, 0, 1
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7
  endin

  instr 2
aSnd, a0   soundin    "ClassGuit.wav"
kAzim      line       0, p3, -360
a1, a2     vbap       aSnd, kAzim, 0, 0, 2
           outch      1, a1, 2, a2
  endin

  instr 3
aSnd, a0   soundin    "ClassGuit.wav"
kAzim      line       0, p3, -360
a1, a2, a3 vbap       aSnd, kAzim, 0, 0, 3
           outch      7, a1, 3, a2, 5, a3
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 6
i 2 6 6
i 3 12 6
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>&nbsp;</p>
<p>Instead of just one loudspeaker configuration, as in the previous examples, there are now three configurations:&nbsp;</p>
<p>En lugar de s&oacute;lo una configuraci&oacute;n de altavoz, como en los ejemplos anteriores, ahora hay tres configuraciones:</p>
<p>&nbsp;</p>
<pre>vbaplsinit 2.01, 7, -40, 40, 70, 140, 180, -110, -70
vbaplsinit 2.02, 2, -40, 40
vbaplsinit 2.03, 3, -70, 180, 70
</pre>
<p>The first parameter (the number of dimensions) now has an additional fractional part, with a range from .01 to .99, specifying the number of the speaker layout. So 2.01 means: two dimensions, layout number one, 2.02 is layout number two, and 2.03 is layout number three. The new vbap opcode has now these parameters:</p>
<p>El primer par&aacute;metro (el n&uacute;mero de dimensiones) ahora tiene una parte fraccional adicional, con un rango de .01 a .99, especificando el n&uacute;mero del dise&ntilde;o del altavoz. As&iacute; que 2,01 significa: dos dimensiones, el n&uacute;mero de dise&ntilde;o uno, 2,02 es el n&uacute;mero de dise&ntilde;o dos, y 2,03 es el n&uacute;mero de dise&ntilde;o tres. El nuevo opcode vbap tiene ahora estos par&aacute;metros:</p>
<p>&nbsp;</p>
<p>ar1[, ar2...] <strong>vbap</strong> asig, kazim [, kelev] [, kspread] [, ilayout]</p>
<p>The last parameter ilayout refers to the speaker layout number. In the example above, instrument 1 uses layout 1, instrument 2 uses layout 2, and instrument 3 uses layout 3. Even if you do not have more than two speakers you should see in Csound's output that instrument 1 goes to all seven speakers, instrument 2 only to the first two, and instrument 3 goes to speaker 3, 5, and 7.</p>
<p>El &uacute;ltimo par&aacute;metro ilayout se refiere al n&uacute;mero de disposici&oacute;n del altavoz. En el ejemplo anterior, el instrumento 1 utiliza el dise&ntilde;o 1, el instrumento 2 utiliza el dise&ntilde;o 2 y el instrumento 3 utiliza el dise&ntilde;o 3. Incluso si no tiene m&aacute;s de dos altavoces deber&iacute;a ver en la salida Csounds que el instrumento 1 va a los siete altavoces, 2 s&oacute;lo a los dos primeros, y el instrumento 3 va al altavoz 3, 5 y 7.</p>
<p>&nbsp;</p>
<p>In addition to the new vbap opcode, vbapg has been written. The idea is to have an opcode which returns the gains (amplitudes) of the speakers instead of the audio signal:</p>
<p>Adem&aacute;s del nuevo opcode vbap, vbapg se ha escrito. La idea es tener un opcode que devuelva las ganancias (amplitudes) de los altavoces en lugar de la se&ntilde;al de audio:</p>
<p>&nbsp;</p>
<p>k1[, k2...] <span class="command"><strong>vbapg</strong></span> kazim [,kelev] [, kspread] [, ilayout]</p>
<h2>Ambisonics</h2>
<p>Ambisonics is another technique to distribute a virtual sound source in space.</p>
<p>Ambisonics es otra t&eacute;cnica para distribuir una fuente de sonido virtual en el espacio.</p>
<p>&nbsp;</p>
<p>There are excellent sources for the discussion of Ambisonics online3 and the following chapter will give a step by step introduction. We will focus just on the basic practicalities of using the Ambisonics opcodes of Csound, without going into too much detail of the concepts behind them.</p>
<p>Existen excelentes fuentes para la discusi&oacute;n de Ambisonics online3 y el siguiente cap&iacute;tulo ofrecer&aacute; una introducci&oacute;n paso a paso. Nos enfocaremos s&oacute;lo en los aspectos pr&aacute;cticos b&aacute;sicos del uso de los opcodes Ambisonics de Csound, sin entrar en demasiados detalles de los conceptos detr&aacute;s de ellos.</p>
<p>&nbsp;</p>
<p>Ambisonics works using two basic steps. In the first step you encode the sound and the spatial information (its localisation) of a virtual sound source in a so-called B-format. In the second step you decode the B-format to match your loudspeaker setup.</p>
<p>Ambisonics trabaja utilizando dos pasos b&aacute;sicos. En el primer paso se codifica el sonido y la informaci&oacute;n espacial (su localizaci&oacute;n) de una fuente de sonido virtual en un denominado formato B. En el segundo paso, usted decodifica el formato B para que coincida con la configuraci&oacute;n del altavoz.</p>
<p>&nbsp;</p>
<p>It is possible to save the B-format as its own audio file, to preserve the spatial information or you can immediately do the decoding after the encoding thereby dealing directly only with audio signals instead of Ambisonic files. The next example takes the latter approach by implementing a transformation of the VBAP circle example to Ambisonics.&nbsp;</p>
<p>Es posible guardar el formato B como su propio archivo de audio, para conservar la informaci&oacute;n espacial o puede hacer inmediatamente la decodificaci&oacute;n despu&eacute;s de la codificaci&oacute;n, tratando as&iacute; directamente s&oacute;lo con se&ntilde;ales de audio en lugar de archivos Ambisonic. El siguiente ejemplo toma este &uacute;ltimo enfoque implementando una transformaci&oacute;n del ejemplo del c&iacute;rculo VBAP a Ambisonics.</p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B08_Ambi_circle.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -d ;for the next line, change to your folder
--env:SSDIR+=/home/jh/Joachim/Csound/FLOSS/Release01/Csound_Floss_Release01/audio
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32	
0dbfs = 1
nchnls = 8

  instr 1
Sfile      =          "ClassGuit.wav"
iFilLen    filelen    Sfile
p3         =          iFilLen
aSnd, a0   soundin    Sfile
kAzim      line       0, p3, 360 ;counterclockwise (!)
iSetup     =          4 ;octogon
aw, ax, ay, az bformenc1 aSnd, kAzim, 0
a1, a2, a3, a4, a5, a6, a7, a8 bformdec1 iSetup, aw, ax, ay, az
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7, 8, a8
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>The first thing to note is that for a counterclockwise circle, the azimuth now has the line 0 -&gt; 360, instead of 0 -&gt; -360 as was used in the VBAP example. This is because Ambisonics usually reads the angle in a mathematical way: a positive angle is counterclockwise. Next, the encoding process is carried out in the line:</p>
<p>Lo primero que debe tenerse en cuenta es que para un c&iacute;rculo en sentido contrario a las agujas del reloj, el azimut ahora tiene la l&iacute;nea 0 - 360, en lugar de 0 - -360 como se us&oacute; en el ejemplo VBAP. Esto se debe a que Ambisonics generalmente lee el &aacute;ngulo de una manera matem&aacute;tica: un &aacute;ngulo positivo es a la izquierda. A continuaci&oacute;n, el proceso de codificaci&oacute;n se lleva a cabo en la l&iacute;nea:</p>
<p>&nbsp;</p>
<p>aw, ax, ay, az bformenc1 aSnd, kAzim, 0</p>
<p>Input arguments are the monophonic sound source aSnd, the xy-angle kAzim, and the elevation angle which is set to zero. Output signals are the spatial information in x-, y- and z- direction (ax, ay, az), and also an omnidirectional signal called aw.</p>
<p>Los argumentos de entrada son la fuente de sonido monof&oacute;nica aSnd, el &aacute;ngulo xy-kAzim, y el &aacute;ngulo de elevaci&oacute;n que se pone a cero. Las se&ntilde;ales de salida son la informaci&oacute;n espacial en la direcci&oacute;n x, y y z (ax, ay, az), y tambi&eacute;n una se&ntilde;al omnidireccional llamada aw.</p>
<p>Decoding is performed by the line:</p>
<p>La decodificaci&oacute;n se realiza mediante la l&iacute;nea:</p>
<p>a1, a2, a3, a4, a5, a6, a7, a8 bformdec1 iSetup, aw, ax, ay, az</p>
<p>The inputs for the decoder are the same aw, ax, ay, az, which were the results of the encoding process, and an additional iSetup parameter. Currently the Csound decoder only works with some standard setups for the speaker: iSetup = 4 refers to an octogon.4 So the final eight audio signals a1, ..., a8 are being produced using this decoder, and are then sent to the speakers in the same way using the outch opcode.</p>
<p>Las entradas para el decodificador son las mismas aw, ax, ay, az, que fueron los resultados del proceso de codificaci&oacute;n, y un par&aacute;metro iSetup adicional. En la actualidad, el decodificador Csound s&oacute;lo funciona con algunas configuraciones est&aacute;ndar para el altavoz: iSetup = 4 se refiere a un octogon.4 As&iacute; que las ocho se&ntilde;ales finales de audio a1, ..., a8 se producen utilizando este decodificador, y luego se env&iacute;an a los altavoces De la misma manera usando el c&oacute;digo de operaci&oacute;n de outch.</p>
<p>Different Orders What we have seen in this example is called 'first order' ambisonics. This means that the encoding process leads to the four basic dimensions w, x, y, z as described above.5 In "second order" ambisonics, there are additional "directions" called r, s, t, u, v. And in "third order" ambisonics again the additional k, l, m, n, o, p, q. The final example in this section shows the three orders, each of them in one instrument. If you have eight speakers in octophonic setup, you can compare the results.&nbsp;</p>
<p>Pedidos diferentes Lo que hemos visto en este ejemplo se denomina ambisonics de primer orden. Esto significa que el proceso de codificaci&oacute;n conduce a las cuatro dimensiones b&aacute;sicas w, x, y, z, como se ha descrito anteriormente.5 En ambisonics de segundo orden, hay direcciones adicionales llamadas r, s, t, u, v. El k adicional, l, m, n, o, p, q. El &uacute;ltimo ejemplo de esta secci&oacute;n muestra los tres &oacute;rdenes, cada uno de ellos en un solo instrumento. Si tiene ocho altavoces en la configuraci&oacute;n octof&oacute;nica, puede comparar los resultados.</p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp; <em>EXAMPLE 05B09_Ambi_orders.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -d ;for the next line, change to your folder
--env:SSDIR+=/home/jh/Joachim/Csound/FLOSS/Release01/Csound_Floss_Release01/audio
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32	
0dbfs = 1
nchnls = 8

  instr 1 ;first order
aSnd, a0   soundin    "ClassGuit.wav"
kAzim      line       0, p3, 360
iSetup     =          4 ;octogon
aw, ax, ay, az bformenc1 aSnd, kAzim, 0
a1, a2, a3, a4, a5, a6, a7, a8 bformdec1 iSetup, aw, ax, ay, az
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7, 8, a8
  endin

  instr 2 ;second order
aSnd, a0   soundin    "ClassGuit.wav"
kAzim      line       0, p3, 360
iSetup     =          4 ;octogon
aw, ax, ay, az, ar, as, at, au, av bformenc1 aSnd, kAzim, 0
a1, a2, a3, a4, a5, a6, a7, a8 bformdec1 iSetup, aw, ax, ay, az, ar, as, at, au, av
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7, 8, a8
  endin

  instr 3 ;third order
aSnd, a0   soundin    "ClassGuit.wav"
kAzim      line       0, p3, 360
iSetup     =          4 ;octogon
aw, ax, ay, az, ar, as, at, au, av, ak, al, am, an, ao, ap, aq bformenc1 aSnd, kAzim, 0
a1, a2, a3, a4, a5, a6, a7, a8 bformdec1 iSetup, aw, ax, ay, az, ar, as, at, au, av, ak, al, am, an, ao, ap, aq
outch 1, a1, 2, a2, 3, a3, 4, a4, 5, a5, 6, a6, 7, a7, 8, a8
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 6
i 2 6 6
i 3 12 6
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>&nbsp;</p>
<p>In theory, first-order ambisonics need at least 4 speakers to be projected correctly. Second-order ambisonics needs at least 6 speakers (9, if 3 dimensions are employed). Third-order ambisonics need at least 8 speakers (or 16 for 3d). So, although higher order should in general lead to a better result in space, you cannot expect it to work unless you have a sufficient number of speakers. Of course practice over theory may prove to be a better judge in many cases.</p>
<p>En teor&iacute;a, los ambisonics de primer orden necesitan al menos 4 altavoces para ser proyectados correctamente. Ambisonics de segundo orden necesita al menos 6 altavoces (9, si se emplean 3 dimensiones). Los ambisonics de tercer orden necesitan al menos 8 altavoces (o 16 para 3d). Por lo tanto, aunque el orden superior en general debe conducir a un mejor resultado en el espacio, no puede esperar que funcione a menos que tenga un n&uacute;mero suficiente de oradores. Por supuesto, la pr&aacute;ctica sobre la teor&iacute;a puede resultar ser un juez mejor en muchos casos.</p>
<p>&nbsp;</p>
<p>Ambisonics UDOs</p>
<p>Usage of the ambisonics UDOs</p>
<p>Uso de los UDOs ambisonics</p>
<p>This chapter gives an overview of the UDOs explained below.</p>
<p>Este cap&iacute;tulo ofrece una visi&oacute;n general de los UDOs explicados a continuaci&oacute;n.</p>
<p>&nbsp;</p>
<p>The channels of the B-format are stored in a zak space. Call zakinit only once and put it outside of any instrument definition in the orchestra file after the header. zacl clears the za space and is called after decoding. The B format of order n can be decoded in any order &lt;= n.</p>
<p>Los canales del formato B se almacenan en un espacio zak. Llame a zakinit s&oacute;lo una vez y p&oacute;ngalo fuera de cualquier definici&oacute;n de instrumento en el archivo de la orquesta despu&eacute;s del encabezado. Zacl borra el espacio za y se llama despu&eacute;s de la decodificaci&oacute;n. El formato B de orden n se puede decodificar en cualquier orden = n.</p>
<p>The text files "ambisonics_udos.txt", "ambisonics2D_udos.txt", "AEP_udos.txt" and "utilities.txt" must be located in the same folder as the csd files or included with full path.</p>
<p>Los archivos de texto ambisonics_udos.txt, ambisonics2D_udos.txt, AEP_udos.txt y utilities.txt deben estar ubicados en la misma carpeta que los archivos csd o incluidos con la ruta completa.</p>
<p>These files can be downloaded together with the entire examples (some of them for CsoundQt) from here (as of September 2015).</p>
<p>Estos archivos se pueden descargar junto con los ejemplos completos (algunos de ellos para CsoundQt) desde aqu&iacute; (a partir de septiembre de 2015).</p>
<p>&nbsp;</p>
<p><br />&nbsp;</p>
<pre>zakinit isizea, isizek    (isizea = (order + 1)^2 in ambisonics (3D); isizea = 2&middot;order + 1 in ambi2D; isizek = 1)

#include "ambisonics_udos.txt"	(order &lt;= 8)
  	ambi_encode	asnd, iorder, kazimuth, kelevation (azimuth, elevation in degrees)
  	ambi_enc_dist asnd, iorder, kazimuth, kelevation, kdistance	
a1 [, a2] ... [, a8]	ambi_decode	iorder, ifn	
a1 [, a2] ... [, a8]	ambi_dec_inph	iorder, ifn	
f ifn  0  n  -2 p1 az1 el1 az2 el2 ... (n is a power of 2 greater than 3&middot;number_of_spekers + 1) (p1 is not used)
  	ambi_write_B	"name", iorder, ifile_format	(ifile_format see fout in the csound help)	
  	ambi_read_B	"name", iorder (only &lt;= 5)
kaz, kel, kdist	xyz_to_aed	kx, ky, kz

;#include "ambisonics2D_udos.txt"	
  	ambi2D_encode	asnd, iorder, kazimuth	(any order) (azimuth in degrees)
  	ambi2D_enc_dist	asnd, iorder, kazimuth, kdistance	
a1 [, a2] ... [, a8]	ambi2D_decode	iorder, iaz1 [, iaz2] ...	[, iaz8]	
a1 [, a2] ... [, a8]	ambi2D_dec_inph	iorder, iaz1 [, iaz2] ...	[, iaz8]	(order &lt;= 12)
  	ambi2D_write_B	"name", iorder, ifile_format
  	ambi2D_read_B	"name", iorder	(order &lt;= 19)
kaz, kdist	xy_to_ad	kx, ky	

#include "AEP_udos.txt"	(any order integer or fractional)
a1 [, a2] ... [, a16] AEP_xyz	asnd, korder, ifn, kx, ky, kz, kdistance
f ifn  0  64  -2  max_speaker_distance x1 y1 z1 x2 y2 z2 ...
a1 [, a2] ... [, a8] AEP	asnd, korder, ifn, kazimuth, kelevation, kdistance (azimuth, elevation in degrees)
f ifn  0  64  -2  max_speaker_distance az1 el1 dist1 az2 el2 dist2 ...  (azimuth, elevation in degrees)

;#include "ambi_utilities.txt"
kdist	dist	kx, ky
kdist	dist	kx, ky, kz
ares	Doppler asnd, kdistance
ares	absorb	asnd, kdistance
kx, ky, kz	aed_to_xyz	kazimuth, kelevation, kdistance
ix, iy, iz	aed_to_xyz	iazimuth, ielevation, idistance
a1 [, a2] ... [, a16]	dist_corr	a1 [, a2] ... [, a16], ifn
f ifn  0  32  -2  max_speaker_distance dist1, dist2, ... (distances in m)
irad	radiani	idegree	
krad	radian	kdegree
arad	radian	adegree
idegree	degreei	irad
kdegree	degree	krad
adegree	degree	arad
</pre>
<p>Introduction</p>
<p>Introducci&oacute;n</p>
<p>&nbsp;</p>
<p>In the following introduction we will explain the principles of ambisonics step by step and write an opcode for every step. The opcodes above combine all of the functionality described. Since the two-dimensional analogy to Ambisonics is easier to understand and to implement with a simple equipment, we shall fully explain it first.</p>
<p>En la siguiente introducci&oacute;n explicaremos los principios de ambisonics paso a paso y escribiremos un opcode para cada paso. Los opcodes anteriores combinan toda la funcionalidad descrita. Dado que la analog&iacute;a bidimensional con Ambisonics es m&aacute;s f&aacute;cil de entender e implementar con un equipo sencillo, lo explicaremos en primer lugar.</p>
<p>&nbsp;</p>
<p>Ambisonics is a technique of three-dimensional sound projection. The information about the recorded or synthesized sound field is encoded and stored in several channels, taking no account of the arrangement of the loudspeakers for reproduction. The encoding of a signal's spatial information can be more or less precise, depending on the so-called order of the algorithm used. Order zero corresponds to the monophonic signal and requires only one channel for storage and reproduction. In first-order Ambisonics, three further channels are used to encode the portions of the sound field in the three orthogonal directions x, y and z. These four channels constitute the so-called first-order B-format. When Ambisonics is used for artificial spatialisation of recorded or synthesized sound, the encoding can be of an arbitrarily high order. The higher orders cannot be interpreted as easily as orders zero and one.</p>
<p>Ambisonics es una t&eacute;cnica de proyecci&oacute;n de sonido tridimensional. La informaci&oacute;n sobre el campo sonoro grabado o sintetizado se codifica y almacena en varios canales, sin tener en cuenta la disposici&oacute;n de los altavoces para la reproducci&oacute;n. La codificaci&oacute;n de una informaci&oacute;n espacial de se&ntilde;ales puede ser m&aacute;s o menos precisa, dependiendo del llamado orden del algoritmo utilizado. El orden cero corresponde a la se&ntilde;al monof&oacute;nica y s&oacute;lo requiere un canal para el almacenamiento y la reproducci&oacute;n. En Ambisonics de primer orden, se usan otros tres canales para codificar las porciones del campo sonoro en las tres direcciones ortogonales x, y y z. Estos cuatro canales constituyen el denominado formato B de primer orden. Cuando Ambisonics se utiliza para la espacializaci&oacute;n artificial del sonido grabado o sintetizado, la codificaci&oacute;n puede ser de un orden arbitrariamente alto. Los &oacute;rdenes superiores no pueden interpretarse tan f&aacute;cilmente como &oacute;rdenes cero y uno.</p>
<p>In a two-dimensional analogy to Ambisonics (called Ambisonics2D in what follows), only sound waves in the horizontal plane are encoded.</p>
<p>En una analog&iacute;a bidimensional con Ambisonics (denominada Ambisonics2D en lo que sigue), s&oacute;lo las ondas sonoras en el plano horizontal est&aacute;n codificadas.</p>
<p>The loudspeaker feeds are obtained by decoding the B-format signal. The resulting panning is amplitude panning, and only the direction to the sound source is taken into account.</p>
<p>Las alimentaciones de altavoz se obtienen descodificando la se&ntilde;al de formato B. La panoramizaci&oacute;n resultante es panor&aacute;mica de amplitud, y s&oacute;lo se tiene en cuenta la direcci&oacute;n a la fuente de sonido.</p>
<p>The illustration below shows the principle of Ambisonics. First a sound is generated and its position determined. The amplitude and spectrum are adjusted to simulate distance, the latter using a low-pass filter. Then the Ambisonic encoding is computed using the sound's coordinates. Encoding mth order B-format requires n = (m+1)^2 channels (n = 2m + 1 channels in Ambisonics2D). By decoding the B-format, one can obtain the signals for any number (&gt;= n) of loudspeakers in any arrangement. Best results are achieved with symmetrical speaker arrangements.</p>
<p>La siguiente ilustraci&oacute;n muestra el principio de Ambisonics. Primero se genera un sonido y se determina su posici&oacute;n. La amplitud y el espectro se ajustan para simular la distancia, utilizando un filtro de paso bajo. A continuaci&oacute;n, la codificaci&oacute;n Ambisonic se calcula utilizando las coordenadas de sonidos. Encoding mth order El formato B requiere n = (m 1) ^ 2 canales (n = 2m 1 canales en Ambisonics2D). Mediante la decodificaci&oacute;n del formato B, se pueden obtener las se&ntilde;ales para cualquier n&uacute;mero (= n) de altavoces en cualquier disposici&oacute;n. Los mejores resultados se obtienen con arreglos de altavoz sim&eacute;tricos.</p>
<p>If the B-format does not need to be recorded the speaker signals can be calculated at low cost and arbitrary order using so-called ambisonics equivalent panning (AEP).</p>
<p>Si no es necesario grabar el formato B, las se&ntilde;ales de los altavoces se pueden calcular a bajo costo y en orden arbitrario utilizando la llamada panor&aacute;mica equivalente de ambisonics (AEP).</p>
<p><br />&nbsp;</p>
<p><img src="static/ambi%20fig1%20intro.png" alt="" width="582" height="118" /></p>
<p><span class="Apple-style-span" style="font-size: 12px; font-weight: normal; line-height: normal;"><strong><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;">Ambisonics2D&nbsp;</span></strong></span></p>
<p>Introduction Introducci&oacute;n</p>
<p>We will first explain the encoding process in Ambisonics2D. The position of a sound source in the horizontal plane is given by two coordinates. In Cartesian coordinates (x, y) the listener is at the origin of the coordinate system (0, 0), and the x-coordinate points to the front, the y-coordinate to the left. The position of the sound source can also be given in polar coordinates by the angle &psi; between the line of vision of the listener (front) and the direction to the sound source, and by their distance r. Cartesian coordinates can be converted to polar coordinates by the formulae:</p>
<p>Primero explicaremos el proceso de codificaci&oacute;n en Ambisonics2D. La posici&oacute;n de una fuente de sonido en el plano horizontal est&aacute; dada por dos coordenadas. En coordenadas cartesianas (x, y) el oyente est&aacute; en el origen del sistema de coordenadas (0, 0), y la coordenada x apunta al frente, la coordenada y a la izquierda. La posici&oacute;n de la fuente de sonido tambi&eacute;n se puede dar en coordenadas polares por el &aacute;ngulo &psi; entre la l&iacute;nea de visi&oacute;n del oyente (frontal) y la direcci&oacute;n a la fuente de sonido, y por su distancia r. Las coordenadas cartesianas pueden convertirse en coordenadas polares mediante las f&oacute;rmulas:</p>
<p>&nbsp;</p>
<p>&nbsp; r = &nbsp; &nbsp;and &nbsp;&psi; = arctan(x, y),&nbsp;</p>
<p>polar to Cartesian coordinates by</p>
<p>Coordenadas polares a cartesianas por</p>
<p>&nbsp; x = r&middot;cos(&psi;) and y = r&middot;sin(&psi;).&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;">&nbsp;<img src="static/ambi%20fig2%202D.png" alt="" /></span></p>
<p>&nbsp;The 0th order B-Format of a signal S of a sound source on the unit circle is just the mono signal: W0 = W = S. The first order B-Format contains two additional channels: W1,1 = X = S&middot;cos(&psi;) = S&middot;x and W1,2 = Y = S&middot;sin(&psi;) = S&middot;y, i.e. the product of the Signal S with the sine and the cosine of the direction &psi; of the sound source. The B-Format higher order contains two additional channels per order m: Wm, 1 = S&middot;cos(m&psi;) and Wm, 2 = S&middot;sin(m&psi;).</p>
<p>El formato B de orden 0 de una se&ntilde;al S de una fuente de sonido en el c&iacute;rculo unitario es s&oacute;lo la se&ntilde;al mono: W0 = W = S. El formato B de primer orden contiene dos canales adicionales: W1,1 = X = S &middot; cos (&Psi;) = S &middot; x y W1,2 = Y = S &middot; sen (&psi;) = S &middot; y, es decir, el producto de la Se&ntilde;al S con el seno y el coseno de la direcci&oacute;n &psi; de la fuente sonora. El orden superior B-Form contiene dos canales adicionales por orden m: Wm, 1 = S &middot; cos (m&psi;) y Wm, 2 = S &middot; sin (m&psi;).</p>
<p>&nbsp;</p>
<p>&nbsp;W0 = S</p>
<p>&nbsp;W<span class="Apple-style-span" style="font-size: xx-small;">1,1</span>&nbsp;= X = S&middot;cos(&psi;) = S&middot;x W<span class="Apple-style-span" style="font-size: xx-small;">1,2</span>&nbsp;= Y = S&middot;sin(&psi;) = S&middot;y</p>
<p>&nbsp;W<span class="Apple-style-span" style="font-size: xx-small;">2,1</span>&nbsp;= S&middot;cos(2&psi;) W<span class="Apple-style-span" style="font-size: xx-small;">2,2</span>&nbsp;= S&middot;sin(2&psi;)</p>
<p>&nbsp;...</p>
<p>&nbsp;W<span class="Apple-style-span" style="font-size: xx-small;">m,1</span>&nbsp;= S&middot;cos(m&psi;) &nbsp; &nbsp;W<span class="Apple-style-span" style="font-size: xx-small;">m,2</span>&nbsp;= S&middot;sin(m&psi;)&nbsp;</p>
<p>&nbsp;</p>
<p>From the n = 2m + 1 B-Format channels the loudspeaker signals pi of n loudspeakers which are set up symmetrically on a circle (with angle ϕi) are:</p>
<p>A partir de los canales de formato n = 2m 1 B, las se&ntilde;ales de altavoz pi de n altavoces que est&aacute;n configuradas sim&eacute;tricamente en un c&iacute;rculo (con &aacute;ngulo &phi;i) son:</p>
<p>&nbsp;&nbsp; p<span class="Apple-style-span" style="font-size: xx-small;">i</span> = 1/n(W<span class="Apple-style-span" style="font-size: xx-small;">0</span> + 2W<span class="Apple-style-span" style="font-size: xx-small;">1,1</span>cos(ϕ<span class="Apple-style-span" style="font-size: x-small;">i</span>) + 2W<span class="Apple-style-span" style="font-size: xx-small;">1,2</span>sin(ϕ<span class="Apple-style-span" style="font-size: x-small;">i</span>) + 2W<span class="Apple-style-span" style="font-size: xx-small;">2,1</span>cos(2ϕ<span class="Apple-style-span" style="font-size: x-small;">i</span>) + 2W<span class="Apple-style-span" style="font-size: xx-small;">2,2</span>sin(2ϕ<span class="Apple-style-span" style="font-size: xx-small;">i</span>) + ...)</p>
<p><span class="Apple-style-span">&nbsp;&nbsp;= 2/n(1/2 W<span class="Apple-style-span" style="font-size: xx-small;">0</span> + W<span class="Apple-style-span" style="font-size: xx-small;">1,1</span>cos(ϕ</span><span class="Apple-style-span" style="font-size: x-small;">i</span><span class="Apple-style-span">) + W<span class="Apple-style-span" style="font-size: xx-small;">1,2</span>sin(ϕ</span><span class="Apple-style-span" style="font-size: x-small;">i</span><span class="Apple-style-span">) + W<span class="Apple-style-span" style="font-size: xx-small;">2,1</span>cos(2ϕ</span><span class="Apple-style-span" style="font-size: x-small;">i</span><span class="Apple-style-span">) + W<span class="Apple-style-span" style="font-size: xx-small;">2,2</span>sin(2</span>ϕ<span class="Apple-style-span" style="font-size: xx-small;">i</span><span class="Apple-style-span">) + ...)</span></p>
<p>(If more than n speakers are used, we can use the same formula)</p>
<p>(Si se utilizan m&aacute;s de n altavoces, podemos usar la misma f&oacute;rmula)</p>
<p>&nbsp;</p>
<p>In the Csound example udo_ambisonics2D_1.csd the opcode ambi2D_encode_1a produces the 3 channels W, X and Y (a0, a11, a12) from an input sound and the angle &psi; (azmuth kaz), the opcode ambi2D_decode_1_8 decodes them to 8 speaker signals a1, a2, ..., a8. The inputs of the decoder are the 3 channels a0, a11, a12 and the 8 angles of the speakers.</p>
<p>En el ejemplo de Csound udo_ambisonics2D_1.csd el c&oacute;digo de operaci&oacute;n ambi2D_encode_1a produce los 3 canales W, X e Y (a0, a11, a12) de un sonido de entrada y el &aacute;ngulo &psi; (azmuth kaz), el c&oacute;digo de operaci&oacute;n ambi2D_decode_1_8 los descodifica a 8 se&ntilde;ales de altavoz a1, A2, ..., a8. Las entradas del decodificador son los 3 canales a0, a11, a12 y los 8 &aacute;ngulos de los altavoces.</p>
<p><strong><em>&nbsp; EXAMPLE 05B10_udo_ambisonics2D_1.csd</em></strong></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  8
0dbfs 	 = 1

; ambisonics2D first order without distance encoding
; decoding for 8 speakers symmetrically positioned on a circle

; produces the 3 channels 1st order; input: asound, kazimuth
opcode	ambi2D_encode_1a, aaa, ak	
asnd,kaz	xin
kaz = $M_PI*kaz/180
a0	=	asnd
a11	=	cos(kaz)*asnd
a12	=	sin(kaz)*asnd
		xout		a0,a11,a12
endop

; decodes 1st order to a setup of 8 speakers at angles i1, i2, ...
opcode	ambi2D_decode_1_8, aaaaaaaa, aaaiiiiiiii		
a0,a11,a12,i1,i2,i3,i4,i5,i6,i7,i8	xin
i1 = $M_PI*i1/180
i2 = $M_PI*i2/180
i3 = $M_PI*i3/180
i4 = $M_PI*i4/180
i5 = $M_PI*i5/180
i6 = $M_PI*i6/180
i7 = $M_PI*i7/180
i8 = $M_PI*i8/180
a1	=	(.5*a0 + cos(i1)*a11 + sin(i1)*a12)*2/3			
a2	=	(.5*a0 + cos(i2)*a11 + sin(i2)*a12)*2/3	
a3	=	(.5*a0 + cos(i3)*a11 + sin(i3)*a12)*2/3	
a4	=	(.5*a0 + cos(i4)*a11 + sin(i4)*a12)*2/3	
a5	=	(.5*a0 + cos(i5)*a11 + sin(i5)*a12)*2/3	
a6	=	(.5*a0 + cos(i6)*a11 + sin(i6)*a12)*2/3	
a7	=	(.5*a0 + cos(i7)*a11 + sin(i7)*a12)*2/3	
a8	=	(.5*a0 + cos(i8)*a11 + sin(i8)*a12)*2/3				
		xout			a1,a2,a3,a4,a5,a6,a7,a8
endop

instr 1
asnd	rand	.05
kaz   	line	0,p3,3*360 ;turns around 3 times in p3 seconds
a0,a11,a12 ambi2D_encode_1a asnd,kaz
a1,a2,a3,a4,a5,a6,a7,a8 \
        ambi2D_decode_1_8  a0,a11,a12,
                           0,45,90,135,180,225,270,315
        outc    a1,a2,a3,a4,a5,a6,a7,a8
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i1 0 40
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p>&nbsp;</p>
<p>The B-format of all events of all instruments can be summed before decoding. Thus in the example udo_ambisonics2D_2.csd we create a zak space with 21 channels (zakinit 21, 1) for the 2D B-format up to 10th order where the encoded signals are accumulated. The opcode ambi2D_encode_3 shows how to produce the 7 B-format channels a0, a11, a12, ..., a32 for third order. The opcode ambi2D_encode_n produces the 2(n+1) channels a0, a11, a12, ..., a32 for any order n (needs zakinit 2(n+1), 1). The opcode ambi2D_decode_basic is an overloaded function i.e. it decodes to n speaker signals depending on the number of in- and outputs given (in this example only for 1 or 2 speakers). Any number of instruments can play arbitrary often. Instrument 10 decodes for the first 4 speakers of an 18 speaker setup.</p>
<p>El formato B de todos los eventos de todos los instrumentos puede sumarse antes de la decodificaci&oacute;n. As&iacute;, en el ejemplo udo_ambisonics2D_2.csd creamos un espacio zak con 21 canales (zakinit 21, 1) para el formato 2D B hasta el 10&ordm; orden en el que se acumulan las se&ntilde;ales codificadas. El c&oacute;digo de operaci&oacute;n ambi2D_encode_3 muestra c&oacute;mo producir los 7 canales de formato B a0, a11, a12, ..., a32 para el tercer orden. El c&oacute;digo de operaci&oacute;n ambi2D_encode_n produce los 2 (n 1) canales a0, a11, a12, ..., a32 para cualquier orden n (necesita zakinit 2 (n 1), 1). El c&oacute;digo de operaci&oacute;n ambi2D_decode_basic es una funci&oacute;n sobrecargada, es decir, decodifica a n se&ntilde;ales de altavoz dependiendo del n&uacute;mero de entradas y salidas dadas (en este ejemplo s&oacute;lo para 1 o 2 altavoces). Cualquier n&uacute;mero de instrumentos puede jugar arbitrariamente a menudo. El instrumento 10 decodifica para los primeros 4 altavoces de una configuraci&oacute;n de 18 altavoces.</p>
<p>&nbsp;</p>
<p><strong><em>&nbsp; EXAMPLE 05B11_udo_ambisonics2D_2.csd</em></strong>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;

sr      =  44100
ksmps   =  32
nchnls  =  4
0dbfs 	 = 1

; ambisonics2D encoding fifth order
; decoding for 8 speakers symmetrically positioned on a circle
; all instruments write the B-format into a buffer (zak space)
; instr 10 decodes

; zak space with the 21 channels of the B-format up to 10th order
zakinit 21, 1	

;explicit encoding third order
opcode	ambi2D_encode_3, 0, ak	
asnd,kaz	xin	

kaz = $M_PI*kaz/180

		zawm		asnd,0
		zawm		cos(kaz)*asnd,1		;a11
		zawm		sin(kaz)*asnd,2		;a12
		zawm		cos(2*kaz)*asnd,3	;a21
		zawm		sin(2*kaz)*asnd,4	;a22
		zawm		cos(3*kaz)*asnd,5	;a31
		zawm		sin(3*kaz)*asnd,6	;a32
		
endop

; encoding arbitrary order n(zakinit 2*n+1, 1)
opcode	ambi2D_encode_n, 0, aik		
asnd,iorder,kaz	xin
kaz = $M_PI*kaz/180
kk =	iorder
c1:
   	zawm	cos(kk*kaz)*asnd,2*kk-1
   	zawm	sin(kk*kaz)*asnd,2*kk
kk =		kk-1

if	kk &gt; 0 goto c1
	zawm	asnd,0	
endop

; basic decoding for arbitrary order n for 1 speaker
opcode	ambi2D_decode_basic, a, ii		
iorder,iaz	xin
iaz = $M_PI*iaz/180
igain	=	2/(2*iorder+1)
kk =	iorder
a1	=	.5*zar(0)
c1:
a1 +=	cos(kk*iaz)*zar(2*kk-1)
a1 +=	sin(kk*iaz)*zar(2*kk)
kk =		kk-1
if	kk &gt; 0 goto c1
		xout			igain*a1
endop

; decoding for 2 speakers
opcode	ambi2D_decode_basic, aa, iii	
iorder,iaz1,iaz2	xin
iaz1 = $M_PI*iaz1/180
iaz2 = $M_PI*iaz2/180
igain	=	2/(2*iorder+1)
kk =	iorder
a1	=	.5*zar(0)
c1:
a1 +=	cos(kk*iaz1)*zar(2*kk-1)
a1 +=	sin(kk*iaz1)*zar(2*kk)
kk =		kk-1
if	kk &gt; 0 goto c1

kk =	iorder
a2	=	.5*zar(0)
c2:
a2 +=	cos(kk*iaz2)*zar(2*kk-1)
a2 +=	sin(kk*iaz2)*zar(2*kk)
kk =		kk-1
if	kk &gt; 0 goto c2
		xout			igain*a1,igain*a2
endop

instr 1
asnd	rand		p4
ares 	reson		asnd,p5,p6,1
kaz   	line		0,p3,p7*360		;turns around p7 times in p3 seconds
 		ambi2D_encode_n	asnd,10,kaz
endin

instr 2
asnd	oscil		p4,p5,1
kaz   	line		0,p3,p7*360		;turns around p7 times in p3 seconds
		ambi2D_encode_n	asnd,10,kaz
endin

instr 10	;decode all insruments (the first 4 speakers of a 18 speaker setup)
a1,a2		ambi2D_decode_basic 	10,0,20
a3,a4		ambi2D_decode_basic 	10,40,60
		outc	a1,a2,a3,a4			
		zacl 	0,20		; clear the za variables
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 32768 10 1
;			amp	 cf 	bw		turns
i1 0 3 	.7 	 1500 	12 		1
i1 2 18 	.1  2234 	34 		-8
;			amp		fr	0	turns
i2 0 3   .1	 	440	0	2
i10 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p style="-qt-block-indent: 0; text-indent: 0px; -qt-user-state: 0; margin: 0px;">&nbsp;</p>
<p>&nbsp;</p>
<p>In-phase Decoding</p>
<p>Decodificaci&oacute;n en fase</p>
<p>The left figure below shows a symmetrical arrangement of 7 loudspeakers. If the virtual sound source is precisely in the direction of a loudspeaker, only this loudspeaker gets a signal (center figure). If the virtual sound source is between two loudspeakers, these loudspeakers receive the strongest signals; all other loudspeakers have weaker signals, some with negative amplitude, that is, reversed phase (right figure).</p>
<p>La figura a la izquierda muestra una disposici&oacute;n sim&eacute;trica de 7 altavoces. Si la fuente de sonido virtual es precisamente en la direcci&oacute;n de un altavoz, s&oacute;lo este altavoz recibe una se&ntilde;al (figura central). Si la fuente de sonido virtual est&aacute; entre dos altavoces, estos altavoces reciben las se&ntilde;ales m&aacute;s fuertes; Todos los dem&aacute;s altavoces tienen se&ntilde;ales m&aacute;s d&eacute;biles, algunos con amplitud negativa, es decir, fase inversa (figura derecha).</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span class="Apple-style-span" style="line-height: normal; font-family: verdana, arial, helvetica, sans-serif;"><img src="static/ambi%20fig3%20in-phase.png" alt="" width="577" height="136" /></span></p>
<p>To avoid having loudspeaker sounds that are far away from the virtual sound source and to ensure that negative amplitudes (inverted phase) do not arise, the B-format channels can be weighted before being decoded. The weighting factors depend on the highest order used (M) and the order of the particular channel being decoded (m).</p>
<p>Para evitar que haya sonidos de altavoz que est&eacute;n lejos de la fuente de sonido virtual y para asegurar que no surgen amplitudes negativas (fase invertida), los canales de formato B pueden ponderarse antes de ser descodificados. Los factores de ponderaci&oacute;n dependen del orden m&aacute;s alto utilizado (M) y del orden del canal particular que se decodifica (m).</p>
<p><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;">&nbsp;g<span class="Apple-style-span" style="font-size: xx-small;">m</span> = &nbsp;(M!)^2/((M + m)!&middot;(M - m)!)&nbsp;</span></p>
<p><img src="static/ambi%20fig8%20tab1.png" alt="" width="587" height="183" /></p>
<p>&nbsp;</p>
<p>The decoded signal can be normalised with the factor gnorm(M) = (2M + 1) !/(4^M (M!)^2)</p>
<p>La se&ntilde;al decodificada puede normalizarse con el factor gnorm (M) = (2M1)! / (4 ^ M (M!) ^ 2)</p>
<p>&nbsp;</p>
<p><img src="static/ambi%20fig9%20tab2.png" alt="" /></p>
<p>The illustration below shows a third-order B-format signal decoded to 13 loudspeakers first uncorrected (so-called basic decoding, left), then corrected by weighting (so-called in-phase decoding, right).</p>
<p>La siguiente ilustraci&oacute;n muestra una se&ntilde;al de tercer orden de formato B decodificada a 13 altavoces sin corregir primero (llamada descodificaci&oacute;n b&aacute;sica, a la izquierda), y luego corregida por ponderaci&oacute;n (llamada descodificaci&oacute;n en fase, a la derecha).</p>
<p><img src="static/ambi%20fig4%20in-phase2.png" alt="" width="593" height="141" /></p>
<p>Example udo_ambisonics2D_3.csd shows in-phase decoding. The weights and norms up to 12th order are saved in the arrays iWeight2D[][] and iNorm2D[] respectively. Instrument 11 decodes third order for 4 speakers in a square.</p>
<p>Ejemplo udo_ambisonics2D_3.csd muestra la descodificaci&oacute;n en fase. Los pesos y las normas hasta el 12&ordm; orden se guardan en los arrays iWeight2D [] [] e iNorm2D [] respectivamente. El instrumento 11 decodifica el tercer orden para 4 altavoces en un cuadrado.</p>
<p>&nbsp;<strong><em> EXAMPLE 05B12_udo_ambisonics2D_3.csd</em></strong>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;

sr      =  44100
ksmps   =  32
nchnls  =  4
0dbfs 	 = 1

opcode	ambi2D_encode_n, 0, aik		
asnd,iorder,kaz	xin
kaz = $M_PI*kaz/180
kk =	iorder
c1:
   	zawm	cos(kk*kaz)*asnd,2*kk-1
   	zawm	sin(kk*kaz)*asnd,2*kk
kk =		kk-1

if	kk &gt; 0 goto c1
	zawm	asnd,0	

endop

;in-phase-decoding
opcode	ambi2D_dec_inph, a, ii	
; weights and norms up to 12th order
iNorm2D[] array 1,0.75,0.625,0.546875,0.492188,0.451172,0.418945,
					0.392761,0.370941,0.352394,0.336376,0.322360
iWeight2D[][] init   12,12
iWeight2D     array  0.5,0,0,0,0,0,0,0,0,0,0,0,
	0.666667,0.166667,0,0,0,0,0,0,0,0,0,0,
	0.75,0.3,0.05,0,0,0,0,0,0,0,0,0,
	0.8,0.4,0.114286,0.0142857,0,0,0,0,0,0,0,0,
	0.833333,0.47619,0.178571,0.0396825,0.00396825,0,0,0,0,0,0,0,
	0.857143,0.535714,0.238095,0.0714286,0.012987,0.00108225,0,0,0,0,0,0,
	0.875,0.583333,0.291667,0.1060601,0.0265152,0.00407925,0.000291375,0,0,0,0,0,
	0.888889,0.622222,0.339394,0.141414,0.043512,0.009324,0.0012432,
	0.0000777,0,0,0,0,
	0.9,0.654545,0.381818,0.176224,0.0629371,0.0167832,0.00314685,
	0.000370218,0.0000205677,0,0,0,
	0.909091,0.681818,0.41958,0.20979,0.0839161,0.0262238,0.0061703,
	0.00102838,0.000108251,0.00000541254,0,0,
	0.916667,0.705128,0.453297,0.241758,0.105769,0.0373303,0.0103695,
	0.00218306,0.000327459,0.0000311866,0.00000141757,0,
	0.923077,0.725275,0.483516,0.271978,0.12799,0.0497738,0.015718,
	0.00392951,0.000748478,0.000102065,0.00000887523,0.000000369801

iorder,iaz1	xin
iaz1 = $M_PI*iaz1/180
kk =	iorder
a1	=	.5*zar(0)
c1:
a1 +=	cos(kk*iaz1)*iWeight2D[iorder-1][kk-1]*zar(2*kk-1)
a1 +=	sin(kk*iaz1)*iWeight2D[iorder-1][kk-1]*zar(2*kk)
kk =		kk-1
if	kk &gt; 0 goto c1
		xout			iNorm2D[iorder-1]*a1
endop

zakinit 7, 1		

instr 1
asnd	rand		p4
ares 	reson		asnd,p5,p6,1
kaz   	line		0,p3,p7*360		;turns around p7 times in p3 seconds
 		ambi2D_encode_n		asnd,3,kaz
endin

instr 11		

a1 		ambi2D_dec_inph 	3,0
a2 		ambi2D_dec_inph 	3,90
a3 		ambi2D_dec_inph 	3,180
a4 		ambi2D_dec_inph 	3,270
		outc	a1,a2,a3,a4
		zacl 	0,6		; clear the za variables
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;			amp	 cf 	bw		turns
i1 0 3 	.1 	 1500 	12 		1
i11 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p style="-qt-block-indent: 0; text-indent: 0px; -qt-user-state: 0; margin: 0px;">&nbsp;</p>
<p>Distance Distancia</p>
<p>&nbsp;</p>
<p>In order to simulate distances and movements of sound sources, the signals have to be treated before being encoded. The main perceptual cues for the distance of a sound source are reduction of the amplitude, filtering due to the absorbtion of the air and the relation between direct and indirect sound. We will implement the first two of these cues. The amplitude arriving at a listener is inversely proportional to the distance of the sound source. If the distance is larger than the unit circle (not necessarily the radius of the speaker setup, which does not need to be known when encoding sounds) we can simply divide the sound by the distance. With this calculation inside the unit circle the amplitude is amplified and becomes infinite when the distance becomes zero. Another problem arises when a virtual sound source passes the origin. The amplitude of the speaker signal in the direction of the movement suddenly becomes maximal and the signal of the opposite speaker suddenly becomes zero. A simple solution for these problems is to limit the gain of the channel W inside the unit circle to 1 (f1 in the figure below) and to fade out all other channels (f2). By fading out all channels except channel W the information about the direction of the sound source is lost and all speaker signals are the same and the sum of the speaker signals reaches its maximum when the distance is 0.</p>
<p>Para simular distancias y movimientos de fuentes sonoras, las se&ntilde;ales tienen que ser tratadas antes de ser codificadas. Las principales se&ntilde;ales perceptivas para la distancia de una fuente sonora son la reducci&oacute;n de la amplitud, el filtrado debido a la absorci&oacute;n del aire y la relaci&oacute;n entre el sonido directo e indirecto. Vamos a implementar las dos primeras de estas se&ntilde;ales. La amplitud que llega a un oyente es inversamente proporcional a la distancia de la fuente de sonido. Si la distancia es mayor que el c&iacute;rculo de la unidad (no necesariamente el radio de la configuraci&oacute;n del altavoz, que no necesita ser conocido al codificar los sonidos) podemos simplemente dividir el sonido por la distancia. Con este c&aacute;lculo dentro del c&iacute;rculo unitario la amplitud se amplifica y se hace infinita cuando la distancia se convierte en cero. Otro problema surge cuando una fuente de sonido virtual pasa el origen. La amplitud de la se&ntilde;al del altavoz en la direcci&oacute;n del movimiento de repente se vuelve m&aacute;xima y la se&ntilde;al del altavoz opuesto se convierte repentinamente en cero. Una soluci&oacute;n simple para estos problemas es limitar la ganancia del canal W dentro del c&iacute;rculo unitario a 1 (f1 en la figura siguiente) y atenuar todos los dem&aacute;s canales (f2). Al atenuar todos los canales excepto el canal W la informaci&oacute;n sobre la direcci&oacute;n de la fuente de sonido se pierde y todas las se&ntilde;ales de los altavoces son iguales y la suma de las se&ntilde;ales del altavoz alcanza su m&aacute;ximo cuando la distancia es 0.</p>
<p><br />&nbsp;</p>
<p><img src="static/ambi%20fig5%20dist.png" alt="" />&nbsp;</p>
<p>Now, we are looking for gain functions that are smoother at d = 1. The functions should be differentiable and the slope of f1 at distance d = 0 should be 0. For distances greater than 1 the functions should be approximately 1/d. In addition the function f1 should continuously grow with decreasing distance and reach its maximum at d = 0. The maximal gain must be 1. The function atan(d&middot;&pi;/2)/(d&middot;&pi;/2) fulfills these constraints. We create a function f2 for the fading out of the other channels by multiplying f1 by the factor (1 &ndash; E^(-d)).</p>
<p>Ahora, estamos buscando funciones de ganancia que sean m&aacute;s suaves en d = 1. Las funciones deben ser diferenciables y la pendiente de f1 a la distancia d = 0 debe ser 0. Para distancias mayores que 1 las funciones deben ser aproximadamente 1 / d. Adem&aacute;s, la funci&oacute;n f1 debe crecer continuamente con una distancia decreciente y alcanzar su m&aacute;ximo en d = 0. La ganancia m&aacute;xima debe ser 1. La funci&oacute;n atan (d &middot; &pi; / 2) / (d &pi; / 2) cumple estas restricciones. Creamos una funci&oacute;n f2 para el desvanecimiento de los otros canales multiplicando f1 por el factor (1 - E ^ (- d)).</p>
<p><img src="static/ambi%20fig6%20dist2.png" alt="" />&nbsp;</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px 'Times New Roman'; min-height: 15.0px;"><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;"><span class="Apple-style-span" style="font-family: trebuchet, verdana, sans-serif; line-height: 17px;"><strong><em>EXAMPLE 05B13_udo_ambisonics2D_4.csd</em></strong></span><span class="Apple-style-span" style="font-family: trebuchet, verdana, sans-serif; line-height: 17px;">&nbsp;</span></span></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;

sr      =  44100
ksmps   =  32
nchnls  =  8
0dbfs 	 = 1

#include "ambisonics2D_udos.txt"

; distance encoding
; with any distance (includes zero and negative distance)

opcode	ambi2D_enc_dist_n, 0, aikk		
asnd,iorder,kaz,kdist	xin
kaz = $M_PI*kaz/180
kaz	=			(kdist &lt; 0 ? kaz + $M_PI : kaz)
kdist =		abs(kdist)+0.0001
kgainW	=		taninv(kdist*1.5707963) / (kdist*1.5708)		;pi/2
kgainHO =	(1 - exp(-kdist))*kgainW
kk =	iorder
asndW	=	kgainW*asnd
asndHO	=	kgainHO*asndW
c1:
   	zawm	cos(kk*kaz)*asndHO,2*kk-1
   	zawm	sin(kk*kaz)*asndHO,2*kk
kk =		kk-1

if	kk &gt; 0 goto c1
	zawm	asndW,0	
	
endop

zakinit 17, 1		

instr 1
asnd	rand		p4
;asnd	soundin	"/Users/user/csound/ambisonic/violine.aiff"
kaz   	line		0,p3,p5*360		;turns around p5 times in p3 seconds
kdist	line		p6,p3,p7			
        ambi2D_enc_dist_n asnd,8,kaz,kdist
endin

instr 10		
a1,a2,a3,a4,
a5,a6,a7,a8 		ambi2D_decode		8,0,45,90,135,180,225,270,315
		outc	a1,a2,a3,a4,a5,a6,a7,a8
		zacl 	0,16		
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 32768 10 1
;        amp turns dist1 dist2
i1 0 4   1   0     2     -2
;i1 0 4  1   1     1     1
i10 0 4
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p>&nbsp;</p>
<p>In order to simulate the absorption of the air we introduce a very simple lowpass filter with a distance depending cutoff frequency. We produce a Doppler-shift with a distance dependent delay of the sound. Now, we have to determine our unit since the delay of the sound wave is calculated as distance divided by sound velocity. In our example udo_ambisonics2D_5.csd we set the unit to 1 metre. These procedures are performed before the encoding. In instrument 1 the movement of the sound source is defined in Cartesian coordinates. The UDO xy_to_ad transforms them into polar coordinates. The B-format channels can be written to a sound file with the opcode fout. The UDO write_ambi2D_2 writes the channels up to second order into a sound file.</p>
<p>Con el fin de simular la absorci&oacute;n del aire introducimos un filtro de paso bajo muy simple con una distancia dependiendo de la frecuencia de corte. Producimos un cambio Doppler con un retraso dependiente de la distancia del sonido. Ahora, tenemos que determinar nuestra unidad ya que el retardo de la onda sonora se calcula como la distancia dividida por la velocidad del sonido. En nuestro ejemplo udo_ambisonics2D_5.csd ajustamos la unidad a 1 metro. Estos procedimientos se realizan antes de la codificaci&oacute;n. En el instrumento 1 el movimiento de la fuente sonora se define en coordenadas cartesianas. El UDO xy_to_ad los transforma en coordenadas polares. Los canales de formato B se pueden escribir en un archivo de sonido con el opcode fout. El UDO write_ambi2D_2 escribe los canales hasta el segundo orden en un archivo de sonido.</p>
<p><strong><em>&nbsp; EXAMPLE 05B14_udo_ambisonics2D_5.csd</em></strong>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  8
0dbfs 	 = 1

#include "ambisonics2D_udos.txt"
#include "ambisonics_utilities.txt" ;opcodes Absorb and Doppler

/* these opcodes are included in "ambisonics2D_udos.txt"
opcode xy_to_ad, kk, kk
kx,ky		xin
kdist =	sqrt(kx*kx+ky*ky)
kaz 		taninv2	ky,kx
			xout		180*kaz/$M_PI, kdist
endop

opcode Absorb, a, ak
asnd,kdist	xin
aabs 		tone 		5*asnd,20000*exp(-.1*kdist)	
			xout 		aabs
endop

opcode Doppler, a, ak
asnd,kdist	xin
abuf		delayr 	.5
adop		deltapi	interp(kdist)*0.0029137529 + .01 ; 1/343.2
			delayw 	asnd 	
			xout		adop
endop
*/
opcode	write_ambi2D_2, 0,	S		
Sname			xin
fout 	Sname,12,zar(0),zar(1),zar(2),zar(3),zar(4)
endop

zakinit 17, 1		; zak space with the 17 channels of the B-format

instr 1
asnd    buzz     p4,p5,50,1
;asnd   soundin  "/Users/user/csound/ambisonic/violine.aiff"
kx      line     p7,p3,p8		
ky      line     p9,p3,p10		
kaz,kdist xy_to_ad kx,ky
aabs    absorb   asnd,kdist
adop    Doppler  .2*aabs,kdist
        ambi2D_enc_dist adop,5,kaz,kdist
endin

instr 10		;decode all insruments
a1,a2,a3,a4,
a5,a6,a7,a8     ambi2D_dec_inph 5,0,45,90,135,180,225,270,315
                outc            a1,a2,a3,a4,a5,a6,a7,a8
;               fout "B_format2D.wav",12,zar(0),zar(1),zar(2),zar(3),zar(4),
;                                zar(5),zar(6),zar(7),zar(8),zar(9),zar(10)
                write_ambi2D_2  "ambi_ex5.wav"	
                zacl            0,16 ; clear the za variables
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 32768 10 1
;			amp	 	f 		0		x1	x2	y1	y2
i1 0 5 	.8  200 		0 		40	-20	1	.1
i10 0 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p>The position of a point in space can be given by its Cartesian coordinates x, y and z or by its spherical coordinates the radial distance r from the origin of the coordinate system, the elevation &delta; (which lies between &ndash;&pi; and &pi;) and the azimuth angle &theta;.</p>
<p>La posici&oacute;n de un punto en el espacio puede ser dada por sus coordenadas cartesianas x, yyz o por sus coordenadas esf&eacute;ricas la distancia radial r del origen del sistema de coordenadas, la elevaci&oacute;n &delta; (que est&aacute; entre -&pi; y &pi;) y la posici&oacute;n &Aacute;ngulo azimutal &theta;.</p>
<p><img src="static/ambi%20fig7%203D.png" alt="" /></p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px Times;"><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;">The formulae for transforming coordinates are as follows:</span></p>
<p>&nbsp;</p>
<p><img src="static/ambi%20fig12%20formulas.png" alt="" width="672" height="84" /></p>
<p>&nbsp;</p>
<p>The channels of the Ambisonic B-format are computed as the product of the sounds themselves and the so-called spherical harmonics representing the direction to the virtual sound sources. The spherical harmonics can be normalised in various ways. We shall use the so-called semi-normalised spherical harmonics. The following table shows the encoding functions up to the third order as function of azimuth and elevation Ymn(&theta;,&delta;) and as function of x, y and z Ymn(x,y,z) for sound sources on the unit sphere. The decoding formulae for symmetrical speaker setups are the same.</p>
<p>Los canales del formato Ambisonic B se calculan como el producto de los propios sonidos y los llamados arm&oacute;nicos esf&eacute;ricos que representan la direcci&oacute;n de las fuentes de sonido virtuales. Los arm&oacute;nicos esf&eacute;ricos pueden normalizarse de varias maneras. Utilizaremos los llamados arm&oacute;nicos esf&eacute;ricos semi-normalizados. La siguiente tabla muestra las funciones de codificaci&oacute;n hasta el tercer orden en funci&oacute;n de azimut y elevaci&oacute;n Ymn (&theta;, &delta;) y como funci&oacute;n de x, yyz Ymn (x, y, z) para fuentes de sonido en la esfera unitaria. Las f&oacute;rmulas de decodificaci&oacute;n para configuraciones de altavoces sim&eacute;tricas son las mismas.</p>
<p><br />&nbsp;</p>
<p><img src="static/ambi%20fig10%20tab3.png" alt="" />&nbsp;</p>
<p>In the first 3 of the following examples we will not produce sound but display in number boxes (for example using CsoundQt widgets) the amplitude of 3 speakers at positions (1, 0, 0), (0, 1, 0) and (0, 0, 1) in Cartesian coordinates. The position of the sound source can be changed with the two scroll numbers. The example udo_ambisonics_1.csd shows encoding up to second order. The decoding is done in two steps. First we decode the B-format for one speaker. In the second step, we create a overloaded opcode for n speakers. The number of output signals determines which version of the opcode is used. The opcodes ambi_encode and ambi_decode up to 8th order are saved in the text file "ambisonics_udos.txt".</p>
<p>En los primeros 3 de los siguientes ejemplos no produciremos sonido sino que mostraremos en cajas de n&uacute;meros (por ejemplo, utilizando widgets CsoundQt) la amplitud de 3 altavoces en las posiciones (1, 0, 0), (0, 1, 0) y (0 , 0, 1) en coordenadas cartesianas. La posici&oacute;n de la fuente de sonido se puede cambiar con los dos n&uacute;meros de desplazamiento. El ejemplo udo_ambisonics_1.csd muestra la codificaci&oacute;n hasta el segundo orden. La decodificaci&oacute;n se realiza en dos pasos. Primero descodificamos el formato B para un altavoz. En el segundo paso, creamos un opcode sobrecargado para n altavoces. El n&uacute;mero de se&ntilde;ales de salida determina qu&eacute; versi&oacute;n del c&oacute;digo de operaci&oacute;n se utiliza. Los c&oacute;digos de operaci&oacute;n ambi_encode y ambi_decode hasta el octavo orden se guardan en el archivo de texto ambisonics_udos.txt.</p>
<p><strong><em>&nbsp; EXAMPLE 05B15_udo_ambisonics_1.csd</em></strong>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  1
0dbfs 	 = 1

zakinit 9, 1	; zak space with the 9 channel B-format second order

opcode	ambi_encode, 0, aikk		
asnd,iorder,kaz,kel	xin
kaz = $M_PI*kaz/180
kel = $M_PI*kel/180
kcos_el = cos(kel)
ksin_el = sin(kel)
kcos_az = cos(kaz)
ksin_az = sin(kaz)

	zawm	asnd,0							; W
	zawm	kcos_el*ksin_az*asnd,1		; Y	 = Y(1,-1)
	zawm	ksin_el*asnd,2 				; Z	 = Y(1,0)
	zawm	kcos_el*kcos_az*asnd,3		; X	 = Y(1,1)

	if		iorder &lt; 2 goto	end

i2	= sqrt(3)/2
kcos_el_p2 = kcos_el*kcos_el
ksin_el_p2 = ksin_el*ksin_el
kcos_2az = cos(2*kaz)
ksin_2az = sin(2*kaz)
kcos_2el = cos(2*kel)
ksin_2el = sin(2*kel)

	zawm i2*kcos_el_p2*ksin_2az*asnd,4	; V = Y(2,-2)
	zawm i2*ksin_2el*ksin_az*asnd,5		; S = Y(2,-1)
	zawm .5*(3*ksin_el_p2 - 1)*asnd,6		; R = Y(2,0)
	zawm i2*ksin_2el*kcos_az*asnd,7		; S = Y(2,1)
	zawm i2*kcos_el_p2*kcos_2az*asnd,8	; U = Y(2,2)
end:

endop

; decoding of order iorder for 1 speaker at position iaz,iel,idist
opcode	ambi_decode1, a, iii		
iorder,iaz,iel	xin
iaz = $M_PI*iaz/180
iel = $M_PI*iel/180
a0=zar(0)
	if	iorder &gt; 0 goto c0
aout = a0
	goto	end
c0:
a1=zar(1)
a2=zar(2)
a3=zar(3)
icos_el = cos(iel)
isin_el = sin(iel)
icos_az = cos(iaz)
isin_az = sin(iaz)
i1	=	icos_el*isin_az			; Y	 = Y(1,-1)
i2	=	isin_el					; Z	 = Y(1,0)
i3	=	icos_el*icos_az			; X	 = Y(1,1)
	if iorder &gt; 1 goto c1
aout	=	(1/2)*(a0 + i1*a1 + i2*a2 + i3*a3)
	goto end
c1:
a4=zar(4)
a5=zar(5)
a6=zar(6)
a7=zar(7)
a8=zar(8)

ic2	= sqrt(3)/2

icos_el_p2 = icos_el*icos_el
isin_el_p2 = isin_el*isin_el
icos_2az = cos(2*iaz)
isin_2az = sin(2*iaz)
icos_2el = cos(2*iel)
isin_2el = sin(2*iel)


i4 = ic2*icos_el_p2*isin_2az	; V = Y(2,-2)
i5	= ic2*isin_2el*isin_az		; S = Y(2,-1)
i6 = .5*(3*isin_el_p2 - 1)		; R = Y(2,0)
i7 = ic2*isin_2el*icos_az		; S = Y(2,1)
i8 = ic2*icos_el_p2*icos_2az	; U = Y(2,2)
	
aout	=	(1/9)*(a0 + 3*i1*a1 + 3*i2*a2 + 3*i3*a3 + 5*i4*a4 + 5*i5*a5 + 5*i6*a6 + 5*i7*a7 + 5*i8*a8)

end:
		xout			aout
endop

; overloaded opcode for decoding of order iorder
; speaker positions in function table ifn
opcode	ambi_decode,	a,ii
iorder,ifn xin
		xout		ambi_decode1(iorder,table(1,ifn),table(2,ifn))
endop
opcode	ambi_decode,	aa,ii
iorder,ifn xin
		xout				ambi_decode1(iorder,table(1,ifn),table(2,ifn)),
		ambi_decode1(iorder,table(3,ifn),table(4,ifn))
endop
opcode	ambi_decode,	aaa,ii
iorder,ifn xin
		xout		ambi_decode1(iorder,table(1,ifn),table(2,ifn)),
		ambi_decode1(iorder,table(3,ifn),table(4,ifn)),
		ambi_decode1(iorder,table(5,ifn),table(6,ifn))
endop

instr 1
asnd	init		1
;kdist	init		1
kaz		invalue	"az"
kel		invalue	"el"

 	    ambi_encode asnd,2,kaz,kel

ao1,ao2,ao3 	ambi_decode	2,17
		outvalue "sp1", downsamp(ao1)
		outvalue "sp2", downsamp(ao2)	
		outvalue "sp3", downsamp(ao3)	
		zacl 	0,8
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;f1 0 1024 10 1
f17 0 64 -2 0  0 0   90 0   0 90   0 0  0 0  0 0
i1 0 100
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p>Example udo_ambisonics_2.csd shows in-phase decoding. The weights up to 8th order are stored in the arrays iWeight3D[][].</p>
<p>Ejemplo udo_ambisonics_2.csd muestra la descodificaci&oacute;n en fase. Los pesos hasta el octavo orden se almacenan en los arrays iWeight3D [] [].</p>
<p>&nbsp; <strong><em>EXAMPLE 05B16_udo_ambisonics_2.csd</em></strong>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  1
0dbfs 	 = 1

zakinit 81, 1 ; zak space for up to 81 channels of the 8th order B-format

; the opcodes used below are safed in "ambisonics_udos.txt"
#include "ambisonics_udos.txt"

; in-phase decoding up to third order for one speaker
opcode	ambi_dec1_inph3, a, iii		
; weights up to 8th order
iWeight3D[][] init   8,8
iWeight3D     array  0.333333,0,0,0,0,0,0,0,
	0.5,0.1,0,0,0,0,0,0,
	0.6,0.2,0.0285714,0,0,0,0,0,
	0.666667,0.285714,0.0714286,0.0079365,0,0,0,0,
	0.714286,0.357143,0.119048,0.0238095,0.0021645,0,0,0,
	0.75,0.416667,0.166667,0.0454545,0.00757576,0.00058275,0,0,
	0.777778,0.466667,0.212121,0.0707071,0.016317,0.002331,0.0001554,0,
  	0.8,0.509091,0.254545,0.0979021,0.027972,0.0055944,0.0006993,0.00004114

iorder,iaz,iel	xin
iaz = $M_PI*iaz/180
iel = $M_PI*iel/180
a0=zar(0)
	if	iorder &gt; 0 goto c0
aout = a0
	goto	end
c0:
a1=iWeight3D[iorder-1][0]*zar(1)
a2=iWeight3D[iorder-1][0]*zar(2)
a3=iWeight3D[iorder-1][0]*zar(3)
icos_el = cos(iel)
isin_el = sin(iel)
icos_az = cos(iaz)
isin_az = sin(iaz)
i1	=	icos_el*isin_az			; Y	 = Y(1,-1)
i2	=	isin_el					; Z	 = Y(1,0)
i3	=	icos_el*icos_az			; X	 = Y(1,1)
	if iorder &gt; 1 goto c1
aout	=	(3/4)*(a0 + i1*a1 + i2*a2 + i3*a3)
	goto end
c1:
a4=iWeight3D[iorder-1][1]*zar(4)
a5=iWeight3D[iorder-1][1]*zar(5)
a6=iWeight3D[iorder-1][1]*zar(6)
a7=iWeight3D[iorder-1][1]*zar(7)
a8=iWeight3D[iorder-1][1]*zar(8)

ic2	= sqrt(3)/2

icos_el_p2 = icos_el*icos_el
isin_el_p2 = isin_el*isin_el
icos_2az = cos(2*iaz)
isin_2az = sin(2*iaz)
icos_2el = cos(2*iel)
isin_2el = sin(2*iel)


i4 = ic2*icos_el_p2*isin_2az	; V = Y(2,-2)
i5	= ic2*isin_2el*isin_az		; S = Y(2,-1)
i6 = .5*(3*isin_el_p2 - 1)		; R = Y(2,0)
i7 = ic2*isin_2el*icos_az		; S = Y(2,1)
i8 = ic2*icos_el_p2*icos_2az	; U = Y(2,2)
aout	=	(1/3)*(a0 + 3*i1*a1 + 3*i2*a2 + 3*i3*a3 + 5*i4*a4 + 5*i5*a5 + 5*i6*a6 + 5*i7*a7 + 5*i8*a8)

end:
		xout			aout
endop

; overloaded opcode for decoding for 1 or 2 speakers
; speaker positions in function table ifn
opcode	ambi_dec2_inph,	a,ii
iorder,ifn xin
		xout		ambi_dec1_inph(iorder,table(1,ifn),table(2,ifn))
endop
opcode	ambi_dec2_inph,	aa,ii
iorder,ifn xin
		xout		ambi_dec1_inph(iorder,table(1,ifn),table(2,ifn)),
		ambi_dec1_inph(iorder,table(3,ifn),table(4,ifn))
endop
opcode	ambi_dec2_inph,	aaa,ii
iorder,ifn xin
		xout		ambi_dec1_inph(iorder,table(1,ifn),table(2,ifn)),
		ambi_dec1_inph(iorder,table(3,ifn),table(4,ifn)),
		ambi_dec1_inph(iorder,table(5,ifn),table(6,ifn))
endop

instr 1
asnd    init       1
kdist   init       1
kaz     invalue    "az"
kel     invalue    "el"

        ambi_encode asnd,8,kaz,kel
ao1,ao2,ao3 ambi_dec_inph 8,17
        outvalue   "sp1", downsamp(ao1)
        outvalue   "sp2", downsamp(ao2)
        outvalue   "sp3", downsamp(ao3)
        zacl       0,80
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 1024 10 1
f17 0 64 -2 0  0 0   90 0   0 90  0 0  0 0  0 0  0 0  0 0
i1 0 100
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p style="-qt-block-indent: 0; text-indent: 0px; -qt-user-state: 0; margin: 0px;">&nbsp;</p>
<p>The weighting factors for in-phase decoding of Ambisonics (3D) are:</p>
<p>&nbsp;</p>
<p>Los factores de ponderaci&oacute;n para la decodificaci&oacute;n en fase de Ambisonics (3D) son:</p>
<p><img src="static/ambi%20fig11%20tab4.png" alt="" width="571" height="168" /></p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; text-align: justify; font: 12.0px 'Times New Roman';"><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;">Example udo_ambisonics_3.csd shows distance encoding.&nbsp;</span></p>
<p><strong><em>&nbsp; EXAMPLE 05B17_udo_ambisonics_3.csd</em></strong>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  2
0dbfs 	 = 1

zakinit 81, 1		; zak space with the 11 channels of the B-format

#include "ambisonics_udos.txt"

opcode	ambi3D_enc_dist1, 0, aikkk		
asnd,iorder,kaz,kel,kdist	xin
kaz = $M_PI*kaz/180
kel = $M_PI*kel/180
kaz	=		(kdist &lt; 0 ? kaz + $M_PI : kaz)
kel	=		(kdist &lt; 0 ? -kel : kel)
kdist =	abs(kdist)+0.00001
kgainW	=	taninv(kdist*1.5708) / (kdist*1.5708)		
kgainHO =	(1 - exp(-kdist)) ;*kgainW
	outvalue "kgainHO", kgainHO
	outvalue "kgainW", kgainW
kcos_el = cos(kel)
ksin_el = sin(kel)
kcos_az = cos(kaz)
ksin_az = sin(kaz)
asnd =		kgainW*asnd
	zawm	asnd,0							; W
asnd = 	kgainHO*asnd
	zawm	kcos_el*ksin_az*asnd,1		; Y	 = Y(1,-1)
	zawm	ksin_el*asnd,2 				; Z	 = Y(1,0)
	zawm	kcos_el*kcos_az*asnd,3		; X	 = Y(1,1)
	if		iorder &lt; 2 goto	end
/*
...
*/
end:

endop

instr 1
asnd    init      1
kaz     invalue "az"
kel     invalue "el"
kdist   invalue "dist"
        ambi_enc_dist asnd,5,kaz,kel,kdist
ao1,ao2,ao3,ao4 ambi_decode 5,17
        outvalue "sp1", downsamp(ao1)
        outvalue "sp2", downsamp(ao2)
        outvalue "sp3", downsamp(ao3)
        outvalue "sp4", downsamp(ao4)
        outc      0*ao1,0*ao2;,2*ao3,2*ao4
        zacl      0,80
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f17 0 64 -2 0  0 0  90 0   180 0 	 0 90  0 0	0 0
i1 0 100
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p>In example udo_ambisonics_4.csd a buzzer with the three-dimensional trajectory shown below is encoded in third order and decoded for a speaker setup in a cube (f17).</p>
<p>En el ejemplo udo_ambisonics_4.csd un zumbador con la trayectoria tridimensional que se muestra a continuaci&oacute;n se codifica en tercer orden y se decodifica para una configuraci&oacute;n de altavoz en un cubo (f17).</p>
<p><strong><em>&nbsp; EXAMPLE 05B18_udo_ambisonics_4.csd</em></strong>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  8
0dbfs 	 = 1

zakinit 16, 1	

#include "ambisonics_udos.txt"
#include "ambisonics_utilities.txt"

instr 1
asnd    buzz    p4,p5,p6,1
kt      line    0,p3,p3
kaz,kel,kdist xyz_to_aed 10*sin(kt),10*sin(.78*kt),10*sin(.43*kt)
adop Doppler asnd,kdist
        ambi_enc_dist adop,3,kaz,kel,kdist
a1,a2,a3,a4,a5,a6,a7,a8 ambi_decode 3,17
;k0		ambi_write_B	"B_form.wav",8,14
        outc    a1,a2,a3,a4,a5,a6,a7,a8
        zacl    0,15
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 32768 10 1
f17 0 64 -2 0 -45 35.2644  45 35.2644  135 35.2644  225 35.2644  -45 -35.2644  .7854 -35.2644  135 -35.2644  225 -35.2644
i1 0 40 .5 300 40
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p><span class="Apple-style-span" style="font-family: verdana,arial,helvetica,sans-serif;"><span class="Apple-style-span" style="line-height: normal;"><strong>Ambisonics Equivalent Panning (AEP)&nbsp;</strong></span><span class="Apple-style-span" style="line-height: normal;"><strong>&nbsp;</strong></span></span></p>
<p>If we combine encoding and in-phase decoding, we obtain the following panning function (a gain function for a speaker depending on its distance to a virtual sound source):</p>
<p>Si combinamos la codificaci&oacute;n y la decodificaci&oacute;n en fase, obtenemos la siguiente funci&oacute;n de panoramizaci&oacute;n (una funci&oacute;n de ganancia para un altavoz dependiendo de su distancia a una fuente de sonido virtual):</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; P(&gamma;, m) = (1/2+ 1/2 cos &gamma;)^m&nbsp;</p>
<p>In contrast to Ambisonics the order indicated in the function does not have to be an integer. This means that the order can be continuously varied during decoding. The function can be used in both Ambisonics and Ambisonics2D.</p>
<p>A diferencia de Ambisonics, el orden indicado en la funci&oacute;n no tiene que ser un entero. Esto significa que el orden se puede variar continuamente durante la decodificaci&oacute;n. La funci&oacute;n se puede utilizar tanto en Ambisonics como en Ambisonics2D.</p>
<p>This system of panning is called Ambisonics Equivalent Panning. It has the disadvantage of not producing a B-format representation, but its implementation is straightforward and the computation time is short and independent of the Ambisonics order simulated. Hence it is particularly useful for real-time applications, for panning in connection with sequencer programs and for experimentation with high and non-integral Ambisonic orders.</p>
<p>Este sistema de panoramizaci&oacute;n se llama Ambisonics Equivalent Panning. Tiene la desventaja de no producir una representaci&oacute;n en formato B, pero su implementaci&oacute;n es sencilla y el tiempo de c&aacute;lculo es corto e independiente del orden Ambisonics simulado. Por lo tanto, es particularmente &uacute;til para aplicaciones en tiempo real, para panor&aacute;mica en conexi&oacute;n con programas secuenciadores y para la experimentaci&oacute;n con &oacute;rdenes Ambisonic alto y no integral.</p>
<p>The opcode AEP1 in the example udo_AEP.csd shows the calculation of ambisonics equivalent panning for one speaker. The opcode AEP then uses AEP1 to produce the signals for several speakers. In the text file "AEP_udos.txt" AEP ist implemented for up to 16 speakers. The position of the speakers must be written in a function table. As the first parameter in the function table the maximal speaker distance must be given.</p>
<p>El c&oacute;digo de operaci&oacute;n AEP1 en el ejemplo udo_AEP.csd muestra el c&aacute;lculo de panor&aacute;mica equivalente de ambisonics para un altavoz. El c&oacute;digo de operaci&oacute;n AEP utiliza AEP1 para producir las se&ntilde;ales para varios altavoces. En el archivo de texto AEP_udos.txt AEP est&aacute; implementado para un m&aacute;ximo de 16 altavoces. La posici&oacute;n de los altavoces debe escribirse en una tabla de funciones. Como primer par&aacute;metro en la tabla de funciones se debe indicar la distancia m&aacute;xima del altavoz.</p>
<p><strong><em>&nbsp; EXAMPLE 05B19_udo_AEP.csd</em></strong>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr      =  44100
ksmps   =  32
nchnls  =  4
0dbfs 	 = 1

;#include "ambisonics_udos.txt"

; opcode AEP1 is the same as in udo_AEP_xyz.csd

opcode	AEP1, a, akiiiikkkkkk ; soundin, order, ixs, iys, izs, idsmax, kx, ky, kz
ain,korder,ixs,iys,izs,idsmax,kx,ky,kz,kdist,kfade,kgain	xin
idists =		sqrt(ixs*ixs+iys*iys+izs*izs)
kpan =			kgain*((1-kfade+kfade*(kx*ixs+ky*iys+kz*izs)/(kdist*idists))^korder)
		xout	ain*kpan*idists/idsmax
endop

; opcode AEP calculates ambisonics equivalent panning for n speaker
; the number n of output channels defines the number of speakers (overloaded function)
; inputs: sound ain, order korder (any real number &gt;= 1)
; ifn = number of the function containing the speaker positions
; position and distance of the sound source kaz,kel,kdist in degrees

opcode AEP, aaaa, akikkk
ain,korder,ifn,kaz,kel,kdist	xin
kaz = $M_PI*kaz/180
kel = $M_PI*kel/180
kx = kdist*cos(kel)*cos(kaz)
ky = kdist*cos(kel)*sin(kaz)
kz = kdist*sin(kel)
ispeaker[] array 0,
  table(3,ifn)*cos(($M_PI/180)*table(2,ifn))*cos(($M_PI/180)*table(1,ifn)),
  table(3,ifn)*cos(($M_PI/180)*table(2,ifn))*sin(($M_PI/180)*table(1,ifn)),
  table(3,ifn)*sin(($M_PI/180)*table(2,ifn)),
  table(6,ifn)*cos(($M_PI/180)*table(5,ifn))*cos(($M_PI/180)*table(4,ifn)),
  table(6,ifn)*cos(($M_PI/180)*table(5,ifn))*sin(($M_PI/180)*table(4,ifn)),
  table(6,ifn)*sin(($M_PI/180)*table(5,ifn)),
  table(9,ifn)*cos(($M_PI/180)*table(8,ifn))*cos(($M_PI/180)*table(7,ifn)),
  table(9,ifn)*cos(($M_PI/180)*table(8,ifn))*sin(($M_PI/180)*table(7,ifn)),
  table(9,ifn)*sin(($M_PI/180)*table(8,ifn)),
  table(12,ifn)*cos(($M_PI/180)*table(11,ifn))*cos(($M_PI/180)*table(10,ifn)),
  table(12,ifn)*cos(($M_PI/180)*table(11,ifn))*sin(($M_PI/180)*table(10,ifn)),
  table(12,ifn)*sin(($M_PI/180)*table(11,ifn))

idsmax   table   0,ifn
kdist    =       kdist+0.000001
kfade    =       .5*(1 - exp(-abs(kdist)))
kgain    =       taninv(kdist*1.5708)/(kdist*1.5708)

a1       AEP1    ain,korder,ispeaker[1],ispeaker[2],ispeaker[3],
                   idsmax,kx,ky,kz,kdist,kfade,kgain
a2       AEP1    ain,korder,ispeaker[4],ispeaker[5],ispeaker[6],
                   idsmax,kx,ky,kz,kdist,kfade,kgain
a3       AEP1    ain,korder,ispeaker[7],ispeaker[8],ispeaker[9],
                   idsmax,kx,ky,kz,kdist,kfade,kgain
a4       AEP1    ain,korder,ispeaker[10],ispeaker[11],ispeaker[12],
                   idsmax,kx,ky,kz,kdist,kfade,kgain	
         xout    a1,a2,a3,a4
endop

instr 1
ain      rand    1
;ain		soundin	"/Users/user/csound/ambisonic/violine.aiff"
kt       line    0,p3,360
korder   init    24
;kdist 	Dist kx, ky, kz	
a1,a2,a3,a4 AEP  ain,korder,17,kt,0,1
         outc    a1,a2,a3,a4
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;

;fuction for speaker positions
; GEN -2, parameters: max_speaker_distance, xs1,ys1,zs1,xs2,ys2,zs2,...
;octahedron
;f17 0 32 -2 1 1 0 0  -1 0 0  0 1 0  0 -1 0  0 0 1  0 0 -1
;cube
;f17 0 32 -2 1,732 1 1 1  1 1 -1  1 -1 1  -1 1 1
;octagon
;f17 0 32 -2 1 0.924 -0.383 0 0.924 0.383 0 0.383 0.924 0 -0.383 0.924 0 -0.924 0.383 0 -0.924 -0.383 0 -0.383 -0.924 0 0.383 -0.924 0
;f17 0 32 -2 1  0 0 1  45 0 1  90 0 1  135 0 1  180 0 1  225 0 1  270 0 1  315 0 1
;f17 0 32 -2 1  0 -90 1  0 -70 1  0 -50 1  0 -30 1  0 -10 1  0 10 1  0 30 1  0 50 1
f17 0 32 -2 1   -45 0 1   45 0 1   135 0 1  225 0 1
i1 0 2

&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by martin neukom
</pre>
<p style="-qt-block-indent: 0; text-indent: 0px; -qt-user-state: 0; margin: 0px;">&nbsp;</p>
<p style="-qt-block-indent: 0; text-indent: 0px; -qt-user-state: 0; margin: 0px;">&nbsp;</p>
<p>Utilities Utilidades</p>
<p>The file utilities.txt contains the following opcodes:</p>
<p>El archivo utilities.txt contiene los siguientes opcodes:</p>
<p>dist computes the distance from the origin (0, 0) or (0, 0, 0) to a point (x, y) or (x, y, z)</p>
<p>Dist calcula la distancia desde el origen (0, 0) o (0, 0, 0) a un punto (x, y) o (x, y, z)</p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">kdist dist kx, ky</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">kdist dist kx, ky, kz</span></p>
<p>&nbsp;</p>
<p>Doppler simulates the Doppler-shift</p>
<p>Doppler simula el cambio Doppler</p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">ares Doppler &nbsp;asnd, kdistance &nbsp;</span></p>
<p>&nbsp;</p>
<p>absorb is a very simple simulation of the frequency dependent absorption</p>
<p>Absorber es una simulaci&oacute;n muy simple de la absorci&oacute;n dependiente de la frecuencia</p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">ares absorb asnd, kdistance</span></p>
<p>&nbsp;</p>
<p>aed_to_xyz converts polar coordinates to Cartesian coordinates</p>
<p>Aed_to_xyz convierte las coordenadas polares en coordenadas cartesianas</p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">kx, ky, kz aed_to_xyz kazimuth, kelevation, kdistance</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">ix, iy, iz aed_to_xyz iazimuth, ielevation, idistance</span></p>
<p>&nbsp;</p>
<p>dist_corr induces a delay and reduction of the speaker signals relative to the most distant speaker.</p>
<p>Dist_corr induce un retardo y una reducci&oacute;n de las se&ntilde;ales del altavoz en relaci&oacute;n con el altavoz m&aacute;s distante.</p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">a1 [, a2] ... [, a16] dist_corr a1 [, a2] ... [, a16], ifn</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">&nbsp;f ifn &nbsp;0 &nbsp;32 &nbsp;-2 &nbsp;max_speaker_distance dist1, dist2, ... ;distances in m</span></p>
<p>&nbsp;</p>
<p>radian (radiani) converts degrees to radians.</p>
<p>Radian (radiani) convierte grados en radianes.</p>
<p>i<span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">rad radiani idegree&nbsp;</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">krad radian kdegree</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">arad radian adegree</span></p>
<p>degree (degreei) converts radian to degrees</p>
<p>Grado (degreei) convierte radian a grados</p>
<p>i<span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">degree degreei irad</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">kdegree degree krad</span></p>
<p><span class="Apple-style-span" style="font-family: 'courier new',courier,monospace;">adegree degree arad&nbsp;</span></p>
<p>VBAP or Ambisonics?</p>
<p>VBAP o Ambisonics?</p>
<p>Csound offers a simple and reliable way to access two standard methods for multi-channel spatialisation. Both have different qualities and follow different aesthetics. VBAP can perhaps be described as clear, rational and direct. It combines simplicity with flexibility. It gives a reliable sound projection even for rather asymmetric speaker setups. Ambisonics on the other hand offers a very soft sound image, in which the single speaker becomes part of a coherent sound field. The B-format offers the possibility to store the spatial information independently from any particular speaker configuration.</p>
<p>Csound ofrece una forma sencilla y fiable de acceder a dos m&eacute;todos est&aacute;ndar para la espacializaci&oacute;n multicanal. Ambos tienen cualidades diferentes y siguen una est&eacute;tica diferente. VBAP tal vez puede ser descrito como claro, racional y directo. Combina simplicidad y flexibilidad. Proporciona una proyecci&oacute;n de sonido fiable incluso para configuraciones de altavoces bastante asim&eacute;tricas. Ambisonics por otro lado ofrece una imagen de sonido muy suave, en el que el solo altavoz se convierte en parte de un campo de sonido coherente. El formato B ofrece la posibilidad de almacenar la informaci&oacute;n espacial independientemente de cualquier configuraci&oacute;n de altavoz en particular.</p>
<p>The composer, or spatial interpreter, can choose one or the other technique depending on the music and the context. Or (s)he can design a personal approach to spatialisation by combining the different techniques described in this chapter.</p>
<p>El compositor, o int&eacute;rprete espacial, puede elegir una u otra t&eacute;cnica dependiendo de la m&uacute;sica y el contexto. O bien puede dise&ntilde;ar un enfoque personal de la espacializaci&oacute;n combinando las diferentes t&eacute;cnicas descritas en este cap&iacute;tulo.</p>
<p><br />&nbsp;</p>
<ol id="InsertNote_NoteList">
<li id="InsertNoteID_6">First described by Ville Pulkki in 1997: Ville Pulkki, Virtual source positioning using vector base amplitude panning, in: Journal of the Audio Engeneering Society, 45(6), 456-466<span id="InsertNoteID_6_LinkBacks"><sup><a title="Ambisonic UDOs" href="b-panning-and-spatialization#InsertNoteID_6_marker7">^</a></sup></span></li>
<li id="InsertNoteID_8">Ville Pulkki, Uniform spreading of amplitude panned virtual sources, in: Proceedings of the 1999 IEEE Workshop on Applications of Signal Processing to Audio and Acoustics, Mohonk Montain House, New Paltz<span id="InsertNoteID_8_LinkBacks"><sup><a title="Ambisonic UDOs" href="b-panning-and-spatialization#InsertNoteID_8_marker9">^</a></sup></span></li>
<li id="InsertNoteID_10">For instance www.ambisonic.net or www.icst.net/research/projects/ambisonics-theory<span id="InsertNoteID_10_LinkBacks"><sup><a title="Ambisonic UDOs" href="b-panning-and-spatialization#InsertNoteID_10_marker11">^</a></sup></span></li>
<li id="InsertNoteID_12">See www.csounds.com/manual/html/bformdec1.html for more details.<span id="InsertNoteID_12_LinkBacks"><sup><a title="Ambisonic UDOs" href="b-panning-and-spatialization#InsertNoteID_12_marker13">^</a></sup></span></li>
<li id="InsertNoteID_24">Which in turn then are taken by the decoder as input.<span id="InsertNoteID_24_LinkBacks"><sup><a title="Ambisonic UDOs" href="b-panning-and-spatialization#InsertNoteID_24_marker25">^</a></sup></span></li>
</ol>
<p>Amplitud de base vectorial Panning1 se puede describir como un m&eacute;todo que extiende la panor&aacute;mica est&eacute;reo a m&aacute;s de dos altavoces. El n&uacute;mero de hablantes es, en general, arbitrario. Puede configurar los dise&ntilde;os est&aacute;ndar, como la configuraci&oacute;n cuadraf&oacute;nica, octof&oacute;nica o 5.1, pero de hecho cualquier n&uacute;mero de altavoces se puede colocar incluso en distancias irregulares entre s&iacute;. Si tienes la suerte de tener altavoces</p>
<p>Amplitud de base vectorial Panning1 se puede describir como un m&eacute;todo que extiende la panor&aacute;mica est&eacute;reo a m&aacute;s de dos altavoces. El n&uacute;mero de hablantes es, en general, arbitrario. Puede configurar los dise&ntilde;os est&aacute;ndar, como la configuraci&oacute;n cuadraf&oacute;nica, octof&oacute;nica o 5.1, pero de hecho cualquier n&uacute;mero de altavoces se puede colocar tambi&eacute;n en distancias irregulares entre s&iacute;. Si tienes la suerte de tener altavoces</p>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

