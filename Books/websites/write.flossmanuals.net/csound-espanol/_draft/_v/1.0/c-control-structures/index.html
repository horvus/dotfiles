
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: C-Control-Structures / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter C. CONTROL STRUCTURES" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter C. CONTROL STRUCTURES" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/c-control-structures/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <p>Csound: CONTROLSTRUCTURES</p>
<h1>CONTROL STRUCTURES</h1>
<p>In a way, control structures are the core of a programming language. The fundamental element in each language is the conditional if branch. Actually all other control structures like for-, until- or while-loops can be traced back to if-statements.</p>
<p>En cierto modo, las estructuras de control son el n&uacute;cleo de un lenguaje de programaci&oacute;n. El elemento fundamental en cada lengua es el condicional si rama. En realidad, todas las dem&aacute;s estructuras de control como for-, until o while-loops pueden rastrearse hasta if-statements.</p>
<p>&nbsp;</p>
<p><strong>So, Csound provides mainly the if-statement; either in the usual if-then-else form, or in the older way of an if-goto statement. These will be covered first. Though all necessary loops can be built just by if-statements, Csound's while, until and loop facility offer a more comfortable way of performing loops. They will be introduced later, in the Loop and the While / Until section of this chapter. Finally, time loops are shown, which are particulary important in audio programming languages. </strong></p>
<p><strong>Por lo tanto, Csound proporciona principalmente la instrucci&oacute;n if; Ya sea en la forma usual if-then-else, o en la forma m&aacute;s antigua de una sentencia if-goto. Estos ser&aacute;n cubiertos en primer lugar. Aunque todos los bucles necesarios pueden ser construidos por if-statements, Csounds while, hasta y loop facility ofrecen una forma m&aacute;s c&oacute;moda de realizar bucles. Se presentar&aacute;n m&aacute;s adelante, en la secci&oacute;n Loop y en la secci&oacute;n While / Until de este cap&iacute;tulo. Finalmente, se muestran los bucles de tiempo, que son particularmente importantes en los lenguajes de programaci&oacute;n de audio. </strong></p>
<h2>If i-Time Then Not k-Time!</h2>
<p>The fundamental difference in Csound between i-time and k-time which has been explained in chapter 03A, must be regarded very carefully when you work with control structures. If you make a conditional branch at i-time, the condition will be tested just once for each note, at the initialization pass. If you make a conditional branch at k-time, the condition will be tested again and again in each control-cycle.</p>
<p>La diferencia fundamental en Csound entre i-time y k-time que se ha explicado en el cap&iacute;tulo 03A, debe considerarse con mucho cuidado cuando se trabaja con estructuras de control. Si realiza una rama condicional en i-time, la condici&oacute;n se probar&aacute; una vez para cada nota, en el paso de inicializaci&oacute;n. Si usted hace una rama condicional en k-tiempo, la condici&oacute;n ser&aacute; probada una y otra vez en cada ciclo de control.</p>
<p>For instance, if you test a soundfile whether it is mono or stereo, this is done at init-time. If you test an amplitude value to be below a certain threshold, it is done at performance time (k-time). If you get user-input by a scroll number, this is also a k-value, so you need a k-condition.</p>
<p>Por ejemplo, si prueba un archivo de sonido si es mono o est&eacute;reo, esto se hace a init-time. Si se prueba un valor de amplitud por debajo de cierto umbral, se realiza en el tiempo de ejecuci&oacute;n (k-time). Si obtiene la entrada de usuario por un n&uacute;mero de desplazamiento, esto tambi&eacute;n es un valor k, por lo que necesita una condici&oacute;n k.</p>
<p>Thus, all if and loop opcodes have an "i" and a "k" descendant. In the next few sections, a general introduction into the different control tools is given, followed by examples both at i-time and at k-time for each tool.</p>
<p>Por lo tanto, todos los opcodes if y loop poseen un i y un descendiente k. En las siguientes secciones, se proporciona una introducci&oacute;n general a las diferentes herramientas de control, seguida de ejemplos tanto en i-tiempo como en k-time para cada herramienta.</p>
<h2>If - then - [elseif - then -] else</h2>
<p>The use of the if-then-else statement is very similar to other programming languages. Note that in Csound, "then" must be written in the same line as "if" and the expression to be tested, and that you must close the if-block with an "endif" statement on a new line:</p>
<p>El uso de la instrucci&oacute;n if-then-else es muy similar a otros lenguajes de programaci&oacute;n. Tenga en cuenta que en Csound, entonces debe escribirse en la misma l&iacute;nea que if y la expresi&oacute;n a probar, y que debe cerrar el if-block con una instrucci&oacute;n endif en una nueva l&iacute;nea:</p>
<pre>if &lt;condition&gt; then
...
else
...
endif
</pre>
<p>It is also possible to have no "else" statement:</p>
<p>Tambi&eacute;n es posible no tener otra declaraci&oacute;n:</p>
<pre>if &lt;condition&gt; then
...
endif
</pre>
<p>Or you can have one or more "elseif-then" statements in between:</p>
<p>O puede tener una o m&aacute;s declaraciones elseif-then entre ellas:</p>
<p>if &lt;condition1&gt; then</p>
<pre>...
elseif &lt;condition2&gt; then
...
else
...
endif
</pre>
<p>If statements can also be nested. Each level must be closed with an "endif". This is an example with three levels:</p>
<p>Si las sentencias tambi&eacute;n pueden anidarse. Cada nivel debe estar cerrado con un endif. Este es un ejemplo con tres niveles:</p>
<pre>if &lt;condition1&gt; then; first condition opened
 if &lt;condition2&gt; then; second condition openend
  if &lt;condition3&gt; then; third condition openend
  ...
  else
  ...
  endif; third condition closed
 elseif &lt;condition2a&gt; then
 ...
 endif; second condition closed
else
...
endif; first condition closed
</pre>
<h3>i-Rate Examples</h3>
<p>A typical problem in Csound: You have either mono or stereo files, and want to read both with a stereo output. For the real stereo ones that means: use soundin (diskin / diskin2) with two output arguments. For the mono ones it means: use soundin / diskin / diskin2 with one output argument, and throw it to both output channels:</p>
<p>Un problema t&iacute;pico en Csound: Usted tiene archivos mono o est&eacute;reo, y quiere leer ambos con una salida est&eacute;reo. Para los estereof&oacute;nicos reales que significa: use soundin (diskin / diskin2) con dos argumentos de salida. Para los mono esto significa: use soundin / diskin / diskin2 con un argumento de salida, y l&aacute;nzalo a ambos canales de salida:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C01_IfThen_i.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1
Sfile     =          "/my/file.wav" ;your soundfile path here
ifilchnls filenchnls Sfile
 if ifilchnls == 1 then ;mono
aL        soundin    Sfile
aR        =          aL
 else	;stereo
aL, aR    soundin    Sfile
 endif
          outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>If you use CsoundQt, you can browse in the widget panel for the soundfile. See the corresponding example in the CsoundQt Example menu.</p>
<p>Si utiliza CsoundQt, puede explorar el panel de widgets para el archivo de sonido. Consulte el ejemplo correspondiente en el men&uacute; de ejemplo CsoundQt.</p>
<h3>k-Rate Examples</h3>
<p>The following example establishes a moving gate between 0 and 1. If the gate is above 0.5, the gate opens and you hear a tone. If the gate is equal or below 0.5, the gate closes, and you hear nothing.</p>
<p>El siguiente ejemplo establece una puerta m&oacute;vil entre 0 y 1. Si la compuerta est&aacute; por encima de 0,5, la compuerta se abre y se oye un tono. Si la compuerta es igual o inferior a 0,5, la compuerta se cierra y no se oye nada.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C02_IfThen_k.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random values each time different
giTone    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1

; move between 0 and 1 (3 new values per second)
kGate     randomi   0, 1, 3
; move between 300 and 800 hz (1 new value per sec)
kFreq     randomi   300, 800, 1
; move between -12 and 0 dB (5 new values per sec)
kdB       randomi   -12, 0, 5
aSig      oscil3    1, kFreq, giTone
kVol      init      0
 if kGate &gt; 0.5 then; if kGate is larger than 0.5
kVol      =         ampdb(kdB); open gate
 else
kVol      =         0; otherwise close gate
 endif
kVol      port      kVol, .02; smooth volume curve to avoid clicks
aOut      =         aSig * kVol
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>Short Form: (a v b ? x : y)</h3>
<p>If you need an if-statement to give a value to an (i- or k-) variable, you can also use a traditional short form in parentheses: (a v b ? x : y).1 It asks whether the condition a or b is true. If a, the value is set to x; if b, to y. For instance, the last example could be written in this way:</p>
<p>Si necesita una instrucci&oacute;n if para dar un valor a una variable (i- o k-), tambi&eacute;n puede usar un formulario corto tradicional entre par&eacute;ntesis: (avb? X: y) .1 Pregunta si la condici&oacute;n a o b es verdad. Si a, el valor se establece en x; Si b, a y. Por ejemplo, el &uacute;ltimo ejemplo podr&iacute;a escribirse de esta manera:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C03_IfThen_short_form.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0
giTone    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kGate     randomi   0, 1, 3; moves between 0 and 1 (3 new values per second)
kFreq     randomi   300, 800, 1; moves between 300 and 800 hz
                               ;(1 new value per sec)
kdB       randomi   -12, 0, 5; moves between -12 and 0 dB
                             ;(5 new values per sec)
aSig      oscil3    1, kFreq, giTone
kVol      init      0
kVol      =         (kGate &gt; 0.5 ? ampdb(kdB) : 0); short form of condition
kVol      port      kVol, .02; smooth volume curve to avoid clicks
aOut      =         aSig * kVol
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 20
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>If - goto</h2>
<p>An older way of performing a conditional branch - but still useful in certain cases - is an "if" statement which is not followed by a "then", but by a label name. The "else" construction follows (or doesn't follow) in the next line. Like the if-then-else statement, the if-goto works either at i-time or at k-time. You should declare the type by either using igoto or kgoto. Usually you need an additional igoto/kgoto statement for omitting the "else" block if the first condition is true. This is the general syntax:</p>
<p>Una forma m&aacute;s antigua de realizar una rama condicional, pero a&uacute;n &uacute;til en ciertos casos, es una instrucci&oacute;n if que no es seguida por un then, sino por un nombre de etiqueta. La otra construcci&oacute;n sigue (o no sigue) en la l&iacute;nea siguiente. Al igual que la instrucci&oacute;n if-then-else, el if-goto funciona en i-time o en k-time. Debe declarar el tipo utilizando igoto o kgoto. Por lo general, necesita una instrucci&oacute;n igoto / kgoto adicional para omitir el bloque else si la primera condici&oacute;n es verdadera. Esta es la sintaxis general:</p>
<p>i-time</p>
<pre>if &lt;condition&gt; igoto this; same as if-then
 igoto that; same as else
this: ;the label "this" ...
...
igoto continue ;skip the "that" block
that: ; ... and the label "that" must be found
...
continue: ;go on after the conditional branch
...
</pre>
<p>k-time</p>
<pre>if &lt;condition&gt; kgoto this; same as if-then
 kgoto that; same as else
this: ;the label "this" ...
...
kgoto continue ;skip the "that" block
that: ; ... and the label "that" must be found
...
continue: ;go on after the conditional branch
...
</pre>
<h3>i-Rate Examples</h3>
<p>This is the same example as above in the if-then-else syntax for a branch depending on a mono or stereo file. If you just want to know whether a file is mono or stereo, you can use the "pure" if-igoto statement:</p>
<p>Este es el mismo ejemplo que el anterior en la sintaxis if-then-else para una rama dependiendo de un archivo mono o est&eacute;reo. Si s&oacute;lo desea saber si un archivo es mono o est&eacute;reo, puede utilizar la instrucci&oacute;n if-igoto pura:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C04_IfGoto_i.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1
Sfile     = "/Joachim/Materialien/SamplesKlangbearbeitung/Kontrabass.aif"
ifilchnls filenchnls Sfile
if ifilchnls == 1 igoto mono; condition if true
 igoto stereo; else condition
mono:
          prints     "The file is mono!%n"
          igoto      continue
stereo:
          prints     "The file is stereo!%n"
continue:
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>But if you want to play the file, you must also use a k-rate if-kgoto, because, not only do you have an event at i-time (initializing the soundin opcode) but also at k-time (producing an audio signal). So the code in this case is much more cumbersome, or obfuscated, than the previous if-then-else example.</p>
<p>Pero si quieres reproducir el archivo, tambi&eacute;n debes usar k-rate if-kgoto, porque no solo tienes un evento en i-time (inicializando el opcode de soundin), sino tambi&eacute;n en k-time (produciendo un audio se&ntilde;al). Por lo tanto, el c&oacute;digo en este caso es mucho m&aacute;s engorroso u ofuscado que el anterior ejemplo if-then-else.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C05_IfGoto_ik.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1
Sfile     =          "my/file.wav"
ifilchnls filenchnls Sfile
 if ifilchnls == 1 kgoto mono
  kgoto stereo
 if ifilchnls == 1 igoto mono; condition if true
  igoto stereo; else condition
mono:
aL        soundin    Sfile
aR        =          aL
          igoto      continue
          kgoto      continue
stereo:
aL, aR    soundin    Sfile
continue:
          outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>k-Rate Examples</h3>
<p>This is the same example as above (03C02) in the if-then-else syntax for a moving gate between 0 and 1:</p>
<p>&nbsp;</p>
<p>Este es el mismo ejemplo que el anterior (03C02) en la sintaxis if-then-else para una puerta en movimiento entre 0 y 1:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C06_IfGoto_k.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0
giTone    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kGate     randomi   0, 1, 3; moves between 0 and 1 (3 new values per second)
kFreq     randomi   300, 800, 1; moves between 300 and 800 hz
                              ;(1 new value per sec)
kdB       randomi   -12, 0, 5; moves between -12 and 0 dB
                             ;(5 new values per sec)
aSig      oscil3    1, kFreq, giTone
kVol      init      0
 if kGate &gt; 0.5 kgoto open; if condition is true
  kgoto close; "else" condition
open:
kVol      =         ampdb(kdB)
kgoto continue
close:
kVol      =         0
continue:
kVol      port      kVol, .02; smooth volume curve to avoid clicks
aOut      =         aSig * kVol
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Loops</h2>
<p>Loops can be built either at i-time or at k-time just with the "if" facility. The following example shows an i-rate and a k-rate loop created using the if-i/kgoto facility:</p>
<p>Los bucles pueden ser construidos ya sea en i-time o en k-time s&oacute;lo con la instalaci&oacute;n if. El siguiente ejemplo muestra un bucle i-rate y k-rate creado usando la funci&oacute;n if-i / kgoto:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C07_Loops_with_if.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  instr 1 ;i-time loop: counts from 1 until 10 has been reached
icount    =         1
count:
          print     icount
icount    =         icount + 1
 if icount &lt; 11 igoto count
          prints    "i-END!%n"
  endin

  instr 2 ;k-rate loop: counts in the 100th k-cycle from 1 to 11
kcount    init      0
ktimek    timeinstk ;counts k-cycle from the start of this instrument
 if ktimek == 100 kgoto loop
  kgoto noloop
loop:
          printks   "k-cycle %d reached!%n", 0, ktimek
kcount    =         kcount + 1
          printk2   kcount
 if kcount &lt; 11 kgoto loop
          printks   "k-END!%n", 0
noloop:
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>But Csound offers a slightly simpler syntax for this kind of i-rate or k-rate loops. There are four variants of the loop opcode. All four refer to a label as the starting point of the loop, an index variable as a counter, an increment or decrement, and finally a reference value (maximum or minimum) as comparision:</p>
<p>Pero Csound ofrece una sintaxis ligeramente m&aacute;s simple para este tipo de bucles de i-rate o k-rate. Hay cuatro variantes del c&oacute;digo de bucle. Los cuatro se refieren a una etiqueta como punto de partida del bucle, una variable de &iacute;ndice como un contador, un incremento o decremento y finalmente un valor de referencia (m&aacute;ximo o m&iacute;nimo) como comparaci&oacute;n:</p>
<ul>
<li>loop_lt counts upwards and looks if the index variable is lower than the reference value;</li>
<li>Loop_lt cuenta hacia arriba y busca si la variable de &iacute;ndice es menor que el valor de referencia;</li>
<li>loop_le also counts upwards and looks if the index is lower than or equal to the reference value;</li>
<li>Loop_le tambi&eacute;n cuenta hacia arriba y busca si el &iacute;ndice es menor o igual al valor de referencia;</li>
<li>loop_gt counts downwards and looks if the index is greater than the reference value;</li>
<li>Loop_gt cuenta hacia abajo y busca si el &iacute;ndice es mayor que el valor de referencia;</li>
<li>loop_ge also counts downwards and looks if the index is greater than or equal to the reference value.</li>
<li>Loop_ge tambi&eacute;n cuenta hacia abajo y busca si el &iacute;ndice es mayor o igual al valor de referencia.</li>
</ul>
<p>As always, all four opcodes can be applied either at i-time or at k-time. Here are some examples, first for i-time loops, and then for k-time loops.</p>
<p>Como siempre, los cuatro opcodes se pueden aplicar en i-time o en k-time. Aqu&iacute; hay algunos ejemplos, primero para bucles de i-tiempo, y luego para k-tiempo bucles.</p>
<h3>i-Rate Examples</h3>
<p>The following .csd provides a simple example for all four loop opcodes:</p>
<p>El siguiente .csd proporciona un ejemplo sencillo para los cuatro opcodes de bucle:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C08_Loop_opcodes_i.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  instr 1 ;loop_lt: counts from 1 upwards and checks if &lt; 10
icount    =         1
loop:
          print     icount
          loop_lt   icount, 1, 10, loop
          prints    "Instr 1 terminated!%n"
  endin

  instr 2 ;loop_le: counts from 1 upwards and checks if &lt;= 10
icount    =         1
loop:
          print     icount
          loop_le   icount, 1, 10, loop
          prints    "Instr 2 terminated!%n"
  endin

  instr 3 ;loop_gt: counts from 10 downwards and checks if &gt; 0
icount    =         10
loop:
          print     icount
          loop_gt   icount, 1, 0, loop
          prints    "Instr 3 terminated!%n"
  endin

  instr 4 ;loop_ge: counts from 10 downwards and checks if &gt;= 0
icount    =         10
loop:
          print     icount
          loop_ge   icount, 1, 0, loop
          prints    "Instr 4 terminated!%n"
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
i 3 0 0
i 4 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The next example produces a random string of 10 characters and prints it out:</p>
<p>El siguiente ejemplo produce una cadena aleatoria de 10 caracteres e imprime:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C09_Random_string.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  instr 1
icount    =         0
Sname     =         ""; starts with an empty string
loop:
ichar     random    65, 90.999
Schar     sprintf   "%c", int(ichar); new character
Sname     strcat    Sname, Schar; append to Sname
          loop_lt   icount, 1, 10, loop; loop construction
          printf_i  "My name is '%s'!\n", 1, Sname; print result
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; call instr 1 ten times
r 10
i 1 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p><strong>You can also use an i-rate loop to fill a function table (= buffer) with any kind of values. This table can then be read, or manipulated and then be read again. In the next example, a function table with 20 positions (indices) is filled with random integers between 0 and 10 by instrument 1. Nearly the same loop construction is used afterwards to read these values by instrument 2.</strong></p>
<p><strong> Tambi&eacute;n puede utilizar un bucle i-rate para llenar una tabla de funciones (= buffer) con cualquier tipo de valores. Esta tabla puede ser le&iacute;da o manipulada y le&iacute;da de nuevo. En el siguiente ejemplo, una tabla de funciones con 20 posiciones (&iacute;ndices) se rellena con n&uacute;meros enteros aleatorios entre 0 y 10 por el instrumento 1. Casi la misma construcci&oacute;n de bucle se utiliza despu&eacute;s para leer estos valores por el instrumento 2. </strong></p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C10_Random_ftable_fill.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giTable   ftgen     0, 0, -20, -2, 0; empty function table with 20 points
          seed      0; each time different seed

  instr 1 ; writes in the table
icount    =         0
loop:
ival      random    0, 10.999 ;random value
; --- write in giTable at first, second, third ... position
          tableiw   int(ival), icount, giTable
          loop_lt   icount, 1, 20, loop; loop construction
  endin

  instr 2; reads from the table
icount    =         0
loop:
; --- read from giTable at first, second, third ... position
ival      tablei    icount, giTable
          print     ival; prints the content
          loop_lt   icount, 1, 20, loop; loop construction
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>k-Rate Examples</h3>
<p>The next example performs a loop at k-time. Once per second, every value of an existing function table is changed by a random deviation of 10%. Though there are some vectorial opcodes for this task (and in Csound 6 probably array), it can also be done by a k-rate loop like the one shown here:</p>
<p>El siguiente ejemplo realiza un bucle en k-time. Una vez por segundo, cada valor de una tabla de funciones existente se cambia por una desviaci&oacute;n aleatoria de 10%. Aunque hay algunos opcodes vectoriales para esta tarea (y en Csound 6 probablemente matriz), tambi&eacute;n puede hacerse mediante un k-rate loop como el mostrado aqu&iacute;:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C11_Table_random_dev.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 441
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 256, 10, 1; sine wave
          seed      0; each time different seed

  instr 1
ktiminstk timeinstk ;time in control-cycles
kcount    init      1
 if ktiminstk == kcount * kr then; once per second table values manipulation:
kndx      =         0
loop:
krand     random    -.1, .1;random factor for deviations
kval      table     kndx, giSine; read old value
knewval   =         kval + (kval * krand); calculate new value
          tablew    knewval, kndx, giSine; write new value
          loop_lt   kndx, 1, 256, loop; loop construction
kcount    =         kcount + 1; increase counter
 endif
asig      poscil    .2, 400, giSine
          outs      asig, asig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>&nbsp;</h3>
<h2>While / Until</h2>
<p>Since the release of Csound 6, it has been possible to write loops in a manner similar to that used by many other programming languages, using the keywords while or until. The general syntax is:2</p>
<p>Desde el lanzamiento de Csound 6, ha sido posible escribir bucles de una manera similar a la utilizada por muchos otros lenguajes de programaci&oacute;n, usando las palabras clave mientras o hasta. La sintaxis general es: 2</p>
<p>while &lt;condition&gt; do</p>
<pre>   ...
od
until &lt;condition&gt; do
   ...
od
</pre>
<p>The body of the while loop will be performed again and again, as long as is true. The body of the until loop will be performed, as long as is false (not true). This is a simple example at i-rate:</p>
<p>El cuerpo del bucle while se realizar&aacute; una y otra vez, siempre y cuando la condici&oacute;n sea verdadera. El cuerpo del bucle hasta se realizar&aacute;, siempre y cuando la condici&oacute;n sea falsa (no es verdadera). Este es un ejemplo simple en i-rate:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C12_while_until_i-rate.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

instr 1
iCounter = 0
while iCounter &lt; 5 do
  print iCounter
iCounter += 1
od
prints "\n"
endin

instr 2
iCounter = 0
until iCounter &gt;= 5 do
  print iCounter
iCounter += 1
od
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 .1
i 2 .1 .1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Prints:</p>
<p><span style="font-size: small;"><span style="font-family: courier new,courier,monospace;">instr 1:&nbsp; iprint = 0.000 <br />instr 1:&nbsp; iprint = 1.000 <br />instr 1:&nbsp; iprint = 2.000 <br />instr 1:&nbsp; iprint = 3.000 <br />instr 1:&nbsp; iprint = 4.000 <br /><br />instr 2:&nbsp; iprint = 0.000 <br />instr 2:&nbsp; iprint = 1.000 <br />instr 2:&nbsp; iprint = 2.000 <br />instr 2:&nbsp; iprint = 3.000 <br />instr 2:&nbsp; iprint = 4.000</span></span></p>
<p>The most important thing in using the while/until loop is to increment the variable you are using in the loop (here: iCounter). This is done by the statement</p>
<p>Lo m&aacute;s importante al usar el bucle while / until es incrementar la variable que est&aacute; utilizando en el bucle (aqu&iacute;: iCounter). Esto se hace mediante la declaraci&oacute;n</p>
<pre>iCounter += 1
</pre>
<p>which is equivalent to the "old" way of writing as</p>
<p>Que es equivalente a la vieja manera de escribir como</p>
<pre>iCounter = iCounter + 1
</pre>
<p>If you miss this increment, Csound will perform an endless loop, and you will have to terminate it by the operating system.</p>
<p>Si pierde este incremento, Csound realizar&aacute; un bucle interminable, y tendr&aacute; que terminarlo por el sistema operativo.</p>
<p>The next example shows a similar process at k-rate. It uses a while loop to print the values of an array, and also set new values. As this procedure is repeated in each control cycle, the instrument is being turned off after the third cycle.</p>
<p>El siguiente ejemplo muestra un proceso similar a k-rate. Utiliza un bucle while para imprimir los valores de una matriz y tambi&eacute;n establece nuevos valores. Como este procedimiento se repite en cada ciclo de control, el instrumento se apaga despu&eacute;s del tercer ciclo.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C13_while_until_k-rate.csd</strong></em>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

  ;create and fill an array
gkArray[] fillarray 1, 2, 3, 4, 5

instr 1
  ;count performance cycles and print it
kCycle timeinstk
printks "kCycle = %d\n", 0, kCycle
  ;set index to zero
kIndex = 0
  ;perform the loop
while kIndex &lt; lenarray(gkArray) do
    ;print array value
  printf "  gkArray[%d] = %d\n", kIndex+1, kIndex, gkArray[kIndex]
    ;square array value
  gkArray[kIndex] = gkArray[kIndex] * gkArray[kIndex]
  ;increment index
kIndex += 1
od
  ;stop after third control cycle
if kCycle == 3 then
  turnoff
endif
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Prints:</p>
<p><span style="font-size: small;"><span style="font-family: courier new,courier,monospace;">kCycle = 1 <br />&nbsp; gkArray[0] = 1 <br />&nbsp; gkArray[1] = 2 <br />&nbsp; gkArray[2] = 3 <br />&nbsp; gkArray[3] = 4 <br />&nbsp; gkArray[4] = 5 <br />kCycle = 2 <br />&nbsp; gkArray[0] = 1 <br />&nbsp; gkArray[1] = 4 <br />&nbsp; gkArray[2] = 9 <br />&nbsp; gkArray[3] = 16 <br />&nbsp; gkArray[4] = 25 <br />kCycle = 3 <br />&nbsp; gkArray[0] = 1 <br />&nbsp; gkArray[1] = 16 <br />&nbsp; gkArray[2] = 81 <br />&nbsp; gkArray[3] = 256 <br />&nbsp; gkArray[4] = 625</span></span></p>
<h2>Time Loops</h2>
<p>Until now, we have just discussed loops which are executed "as fast as possible", either at i-time or at k-time. But, in an audio programming language, time loops are of particular interest and importance. A time loop means, repeating any action after a certain amount of time. This amount of time can be equal to or different to the previous time loop. The action can be, for instance: playing a tone, or triggering an instrument, or calculating a new value for the movement of an envelope.</p>
<p>Hasta ahora, acabamos de hablar de loops que se ejecutan lo m&aacute;s r&aacute;pido posible, ya sea en i-time o en k-time. Pero, en un lenguaje de programaci&oacute;n de audio, los bucles de tiempo son de particular inter&eacute;s e importancia. Un lazo de tiempo significa repetir cualquier acci&oacute;n despu&eacute;s de cierto tiempo. Esta cantidad de tiempo puede ser igual o diferente al bucle de tiempo anterior. La acci&oacute;n puede ser, por ejemplo: tocar un tono, activar un instrumento o calcular un nuevo valor para el movimiento de un sobre.</p>
<p>In Csound, the usual way of performing time loops, is the timout facility. The use of timout is a bit intricate, so some examples are given, starting from very simple to more complex ones.</p>
<p>En Csound, la forma habitual de realizar bucles de tiempo, es la facilidad de tiempo. El uso de timout es un poco intrincado, por lo que algunos ejemplos se dan, a partir de muy simple a los m&aacute;s complejos.</p>
<p>Another way of performing time loops is by using a measurement of time or k-cycles. This method is also discussed and similar examples to those used for the timout opcode are given so that both methods can be compared.</p>
<p>Otra forma de realizar bucles de tiempo es usando una medici&oacute;n de tiempo o ciclos k. Este m&eacute;todo tambi&eacute;n se discute y se dan ejemplos similares a los utilizados para el c&oacute;digo de operaci&oacute;n de temporizaci&oacute;n para que ambos m&eacute;todos puedan compararse.</p>
<h3>timout Basics</h3>
<p>The timout opcode refers to the fact that in the traditional way of working with Csound, each "note" (an "i" score event) has its own time. This is the duration of the note, given in the score by the duration parameter, abbreviated as "p3". A timout statement says: "I am now jumping out of this p3 duration and establishing my own time." This time will be repeated as long as the duration of the note allows it.</p>
<p>El opcode timout se refiere al hecho de que en la forma tradicional de trabajar con Csound, cada nota (un evento de puntuaci&oacute;n i) tiene su propio tiempo. Esta es la duraci&oacute;n de la nota, dada en la partitura por el par&aacute;metro duraci&oacute;n, abreviado como p3. Una declaraci&oacute;n de timout dice: Ahora estoy saltando de esta duraci&oacute;n de p3 y estableciendo mi propio tiempo. Este tiempo se repetir&aacute; siempre y cuando la duraci&oacute;n de la nota lo permita.</p>
<p>Let's see an example. This is a sine tone with a moving frequency, starting at 400 Hz and ending at 600 Hz. The duration of this movement is 3 seconds for the first note, and 5 seconds for the second note:</p>
<p>Veamos un ejemplo. Se trata de un tono seno con una frecuencia de movimiento, que comienza en 400 Hz y termina en 600 Hz. La duraci&oacute;n de este movimiento es de 3 segundos para la primera nota y de 5 segundos para la segunda nota:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C14_Timout_pre.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
kFreq     expseg    400, p3, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Now we perform a time loop with timout which is 1 second long. So, for the first note, it will be repeated three times, and five times for the second note:</p>
<p>Ahora realizamos un bucle de tiempo con temporizaci&oacute;n que es de 1 segundo de largo. Por lo tanto, para la primera nota, se repetir&aacute; tres veces y cinco veces para la segunda nota:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C15_Timout_basics.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
          timout    0, 1, play
          reinit    loop
play:
kFreq     expseg    400, 1, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>This is the general syntax of timout:</p>
<p>Esta es la sintaxis general de timout:</p>
<p>&nbsp;</p>
<pre>first_label:
          timout    istart, idur, second_label
          reinit    first_label
second_label:
... &lt;any action you want to have here&gt;
</pre>
<p>The first_label is an arbitrary word (followed by a colon) to mark the beginning of the time loop section. The istart argument for timout tells Csound, when the second_label section is to be executed. Usually istart is zero, telling Csound: execute the second_label section immediately, without any delay. The idur argument for timout defines for how many seconds the second_label section is to be executed before the time loop begins again. Note that the reinit first_label is necessary to start the second loop after idur seconds with a resetting of all the values. (See the explanations about reinitialization in the chapter Initialization And Performance Pass section 03A.)</p>
<p>La primera etiqueta es una palabra arbitraria (seguida de dos puntos) para marcar el comienzo de la secci&oacute;n de lazo de tiempo. El argumento istart para timout le dice a Csound, cuando se va a ejecutar la secci&oacute;n second_label. Usualmente istart es cero, dici&eacute;ndole a Csound: ejecute la secci&oacute;n second_label inmediatamente, sin demora alguna. El argumento idur para timout define durante cu&aacute;ntos segundos la secci&oacute;n second_label debe ejecutarse antes de que el bucle de tiempo comience de nuevo. Tenga en cuenta que el reinit first_label es necesario para iniciar el segundo bucle despu&eacute;s de idur segundos con un restablecimiento de todos los valores. (Consulte las explicaciones sobre la reinicializaci&oacute;n en el cap&iacute;tulo Inicializaci&oacute;n y paso de rendimiento, secci&oacute;n 03A).</p>
<p>As usual when you work with the reinit opcode, you can use a rireturn statement to constrain the reinit-pass. In this way you can have both, the timeloop section and the non-timeloop section in the body of an instrument:</p>
<p>Como de costumbre cuando se trabaja con el opcode reinit, se puede usar una sentencia rireturn para restringir el reinit-pass. De esta manera puede tener tanto la secci&oacute;n timeloop como la secci&oacute;n no timeloop en el cuerpo de un instrumento:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C16_Timeloop_and_not.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
          timout    0, 1, play
          reinit    loop
play:
kFreq1    expseg    400, 1, 600
aTone1    oscil3    .2, kFreq1, giSine
          rireturn  ;end of the time loop
kFreq2    expseg    400, p3, 600
aTone2    poscil    .2, kFreq2, giSine

          outs      aTone1+aTone2, aTone1+aTone2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>timout Applications</h3>
<p>In a time loop, it is very important to change the duration of the loop. This can be done either by referring to the duration of this note (p3) ...</p>
<p>En un bucle de tiempo, es muy importante cambiar la duraci&oacute;n del bucle. Esto puede hacerse refiri&eacute;ndose a la duraci&oacute;n de esta nota (p3) ...</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C17_Timout_different_durations.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
          timout    0, p3/5, play
          reinit    loop
play:
kFreq     expseg    400, p3/5, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>... or by calculating new values for the loop duration on each reinit pass, for instance by random values:</p>
<p>... o calculando nuevos valores para la duraci&oacute;n del bucle en cada paso reinit, por ejemplo mediante valores aleatorios:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C18_Timout_random_durations.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
idur      random    .5, 3 ;new value between 0.5 and 3 seconds each time
          timout    0, idur, play
          reinit    loop
play:
kFreq     expseg    400, idur, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 20
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The applications discussed so far have the disadvantage that all the signals inside the time loop must definitely be finished or interrupted, when the next loop begins. In this way it is not possible to have any overlapping of events. To achieve this, the time loop can be used to simply trigger an event. This can be done with event_i or scoreline_i. In the following example, the time loop in instrument 1 triggers a new instance of instrument 2 with a duration of 1 to 5 seconds, every 0.5 to 2 seconds. So in most cases, the previous instance of instrument 2 will still be playing when the new instance is triggered. Random calculations are executed in instrument 2 so that each note will have a different pitch,creating a glissando effect:</p>
<p>Las aplicaciones discutidas hasta ahora tienen la desventaja de que todas las se&ntilde;ales dentro del bucle de tiempo definitivamente deben ser terminadas o interrumpidas, cuando comienza el siguiente bucle. De esta manera no es posible tener ninguna superposici&oacute;n de eventos. Para lograr esto, el bucle de tiempo puede usarse para simplemente disparar un evento. Esto se puede hacer con event_i o scoreline_i. En el ejemplo siguiente, el bucle de tiempo del instrumento 1 activa una nueva instancia del instrumento 2 con una duraci&oacute;n de 1 a 5 segundos, cada 0,5 a 2 segundos. Por lo tanto, en la mayor&iacute;a de los casos, la instancia anterior del instrumento 2 seguir&aacute; reproduci&eacute;ndose cuando se active la nueva instancia. Los c&aacute;lculos aleatorios se ejecutan en el instrumento 2 para que cada nota tenga un tono diferente, creando un efecto glissando:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C19_Timout_trigger_events.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
idurloop  random    .5, 2 ;duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
idurins   random    1, 5 ;duration of the triggered instrument
          event_i   "i", 2, 0, idurins ;triggers instrument 2
  endin

  instr 2
ifreq1    random    600, 1000 ;starting frequency
idiff     random    100, 300 ;difference to final frequency
ifreq2    =         ifreq1 - idiff ;final frequency
kFreq     expseg    ifreq1, p3, ifreq2 ;glissando
iMaxdb    random    -12, 0 ;peak randomly between -12 and 0 dB
kAmp      transeg   ampdb(iMaxdb), p3, -10, 0 ;envelope
aTone     poscil    kAmp, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The last application of a time loop with the timout opcode which is shown here, is a randomly moving envelope. If you want to create an envelope in Csound which moves between a lower and an upper limit, and has one new random value in a certain time span (for instance, once a second), the time loop with timout is one way to achieve it. A line movement must be performed in each time loop, from a given starting value to a new evaluated final value. Then, in the next loop, the previous final value must be set as the new starting value, and so on. Here is a possible solution:</p>
<p>La &uacute;ltima aplicaci&oacute;n de un bucle de tiempo con el c&oacute;digo de operaci&oacute;n de temporizaci&oacute;n que se muestra aqu&iacute;, es un envolvente que se mueve aleatoriamente. Si desea crear un envolvente en Csound que se mueve entre un l&iacute;mite inferior y un l&iacute;mite superior y tiene un nuevo valor aleatorio en un cierto intervalo de tiempo (por ejemplo, una vez por segundo), el bucle de tiempo con temporizaci&oacute;n es una forma de lograrlo . Se debe realizar un movimiento de l&iacute;nea en cada ciclo de tiempo, desde un valor inicial dado hasta un nuevo valor final evaluado. A continuaci&oacute;n, en el siguiente ciclo, el valor final anterior debe establecerse como el nuevo valor inicial, y as&iacute; sucesivamente. He aqu&iacute; una posible soluci&oacute;n:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C20_Timout_random_envelope.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  instr 1
iupper    =         0; upper and ...
ilower    =         -24; ... lower limit in dB
ival1     random    ilower, iupper; starting value
loop:
idurloop  random    .5, 2; duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
ival2     random    ilower, iupper; final value
kdb       linseg    ival1, idurloop, ival2
ival1     =         ival2; let ival2 be ival1 for next loop
          rireturn  ;end reinit section
aTone     poscil    ampdb(kdb), 400, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>Note that in this case the oscillator has been put after the time loop section (which is terminated by the rireturn statement. Otherwise the oscillator would start afresh with zero phase in each time loop, thus producing clicks.</p>
<p>Tenga en cuenta que en este caso el oscilador se ha puesto despu&eacute;s de la secci&oacute;n de bucle de tiempo (que se termina por la declaraci&oacute;n de rieturn), de lo contrario el oscilador empezar&iacute;a de nuevo con fase cero en cada ciclo de tiempo, produciendo as&iacute; clics.</p>
<h3>Time Loops by using the <em>metro</em> Opcode</h3>
<p>The metro opcode outputs a "1" at distinct times, otherwise it outputs a "0". The frequency of this "banging" (which is in some way similar to the metro objects in PD or Max) is given by the kfreq input argument. So the output of metro offers a simple and intuitive method for controlling time loops, if you use it to trigger a separate instrument which then carries out another job. Below is a simple example for calling a subinstrument twice per second:</p>
<p>El opcode de metro emite un 1 en momentos distintos, de lo contrario emite un 0. La frecuencia de este golpeo (que es de alguna manera similar a los objetos de metro en PD o Max) es dada por el argumento de entrada kfreq. As&iacute; que la salida del metro ofrece un m&eacute;todo simple e intuitivo para controlar los bucles de tiempo, si se utiliza para activar un instrumento separado que luego lleva a cabo otro trabajo. A continuaci&oacute;n se muestra un ejemplo sencillo para llamar a un subinstrumento dos veces por segundo:</p>
<p>&nbsp; <em><strong>EXAMPLE 03C21_Timeloop_metro.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1; triggering instrument
kTrig     metro     2; outputs "1" twice a second
 if kTrig == 1 then
          event     "i", 2, 0, 1
 endif
  endin

  instr 2; triggered instrument
aSig      oscils    .2, 400, 0
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The example which is given above (03C19_Timout_trigger_events.csd) as a flexible time loop by timout, can be done with the metro opcode in this way:</p>
<p>El ejemplo que se da arriba (03C19_Timout_trigger_events.csd) como un bucle de tiempo flexible por timout, se puede hacer con el opcode metro de esta manera:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03C22_Metro_trigger_events.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  instr 1
kfreq     init      1; give a start value for the trigger frequency
kTrig     metro     kfreq
 if kTrig == 1 then ;if trigger impulse:
kdur      random    1, 5; random duration for instr 2
          event     "i", 2, 0, kdur; call instr 2
kfreq     random    .5, 2; set new value for trigger frequency
 endif
  endin

  instr 2
ifreq1    random    600, 1000; starting frequency
idiff     random    100, 300; difference to final frequency
ifreq2    =         ifreq1 - idiff; final frequency
kFreq     expseg    ifreq1, p3, ifreq2; glissando
iMaxdb    random    -12, 0; peak randomly between -12 and 0 dB
kAmp      transeg   ampdb(iMaxdb), p3, -10, 0; envelope
aTone     poscil    kAmp, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; &nbsp;
</pre>
<p>Note the differences in working with the metro opcode compared to the timout feature:</p>
<p>Tenga en cuenta las diferencias en el trabajo con el opcode metro en comparaci&oacute;n con la caracter&iacute;stica de tiempo de espera:</p>
<p>As metro works at k-time, you must use the k-variants of event or scoreline to call the subinstrument. With timout you must use the i-variants of event or scoreline (event_i and scoreline_i), because it uses reinitialization for performing the time loops.</p>
<p>Como el metro trabaja en k-time, debe usar las variantes k de evento o scoreline para llamar al subinstrumento. Con timout debes utilizar las i-variantes del evento o scoreline (event_i y scoreline_i), porque utiliza la reinicializaci&oacute;n para realizar los bucles de tiempo.</p>
<p>You must select the one k-cycle where the metro opcode sends a "1". This is done with an if-statement. The rest of the instrument is not affected. If you use timout, you usually must seperate the reinitialized from the not reinitialized section by a rireturn statement.</p>
<p>Debe seleccionar el ciclo k en el que el opcode metro env&iacute;a un 1. Esto se hace con una sentencia if. El resto del instrumento no se ve afectado. Si utiliza timout, por lo general debe separar la reinicializada de la secci&oacute;n no reinicializada por una declaraci&oacute;n rireturn.</p>
<p>Links</p>
<p>Steven Yi: Control Flow (<a href="http://www.csounds.com/journal/2006spring/controlFlow.html">Part I</a> = Csound Journal Spring 2006, <a href="http://www.csounds.com/journal/2006summer/controlFlow_part2.html">Part 2</a> = Csound Journal Summer 2006)</p>
<p>&nbsp;</p>
<ol id="InsertNote_NoteList">
<li id="InsertNoteID_12">Since the release of the new parser (Csound 5.14), you can also write without parentheses.<span id="InsertNoteID_12_LinkBacks"><sup><a href="c-control-structures/c-control-structures#InsertNoteID_12_marker13">^</a></sup></span></li>
<li id="InsertNoteID_6">Instead of using "od" you can also use "enduntil" in the until loop.<span id="InsertNoteID_6_LinkBacks"><sup><a href="c-control-structures/c-control-structures#InsertNoteID_6_marker7">^</a></sup></span></li>
</ol>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

