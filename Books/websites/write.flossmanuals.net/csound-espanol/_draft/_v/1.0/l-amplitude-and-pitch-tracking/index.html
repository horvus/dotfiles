
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: L-Amplitude-And-Pitch-Tracking / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter L. AMPLITUDE AND PITCH TRACKING" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter L. AMPLITUDE AND PITCH TRACKING" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <p>AMPLITUDE AND PITCH TRACKING SEGUIMIENTO DE LA AMPLITUD Y DEL PITCH</p>
<p>&nbsp;</p>
<p>Tracking the amplitude of an audio signal is a relatively simple procedure but simply following the amplitude values of the waveform is unlikely to be useful. An audio waveform will be bipolar, expressing both positive and negative values, so to start with, some sort of rectifying of the negative part of the signal will be required. The most common method of achieving this is to square it (raise to the power of 2) and then to take the square root. Squaring any negative values will provide positive results (-2 squared equals 4). Taking the square root will restore the absolute values.</p>
<p>El seguimiento de la amplitud de una se&ntilde;al de audio es un procedimiento relativamente simple, pero simplemente seguir los valores de amplitud de la forma de onda es poco probable que sea &uacute;til. Una forma de onda de audio ser&aacute; bipolar, expresando valores positivos y negativos, por lo que para empezar, se requerir&aacute; alg&uacute;n tipo de rectificaci&oacute;n de la parte negativa de la se&ntilde;al. El m&eacute;todo m&aacute;s com&uacute;n para lograr esto es cuadrar (aumentar a la potencia de 2) y luego tomar la ra&iacute;z cuadrada. La cuadratura de cualquier valor negativo proporcionar&aacute; resultados positivos (-2 cuadrados es igual a 4). Tomar la ra&iacute;z cuadrada restaurar&aacute; los valores absolutos.</p>
<p>An audio signal is an oscillating signal, periodically passing through amplitude zero but these zero amplitudes do not necessarily imply that the signal has decayed to silence as our brain perceives it. Some sort of averaging will be required so that a tracked amplitude of close to zero will only be output when the signal has settled close to zero for some time. Sampling a set of values and outputting their mean will produce a more acceptable sequence of values over time for a signal's change in amplitude. Sample group size will be important: too small a sample group may result in some residual ripple in the output signal, particularly in signals with only low frequency content, whereas too large a group may result in a sluggish response to sudden changes in amplitude. Some judgement and compromise is required.</p>
<p>Una se&ntilde;al de audio es una se&ntilde;al oscilante, que pasa peri&oacute;dicamente a trav&eacute;s de la amplitud cero, pero estas amplitudes cero no implican necesariamente que la se&ntilde;al ha deca&iacute;do para silenciar como nuestro cerebro lo percibe. Se requerir&aacute; alg&uacute;n tipo de promediaci&oacute;n para que una amplitud de seguimiento cercana a cero s&oacute;lo se emita cuando la se&ntilde;al se ha establecido cerca de cero durante alg&uacute;n tiempo. El muestreo de un conjunto de valores y la salida de su media producir&aacute; una secuencia de valores m&aacute;s aceptable en el tiempo para un cambio de la amplitud de las se&ntilde;ales. El tama&ntilde;o del grupo de muestra ser&aacute; importante: un grupo de muestras demasiado peque&ntilde;o puede dar lugar a una ondulaci&oacute;n residual en la se&ntilde;al de salida, en particular en se&ntilde;ales con s&oacute;lo contenido de baja frecuencia, mientras que un grupo demasiado grande puede resultar en una respuesta lenta a cambios bruscos de amplitud. Se requiere un cierto juicio y compromiso.</p>
<p>The procedure described above is implemented in the following example. A simple audio note is created that ramps up and down according to a linseg envelope. In order to track its amplitude, audio values are converted to k-rate values and are then squared, then square rooted and then written into sequential locations of an array 31 values long. The mean is calculated by summing all values in the array and divided by the length of the array. This procedure is repeated every k-cycle. The length of the array will be critical in fine tuning the response for the reasons described in the preceding paragraph. Control rate (kr) will also be a factor therefore is taken into consideration when calculating the size of the array. Changing control rate (kr) or number of audio samples in a control period (ksmps) will then no longer alter response behaviour.</p>
<p>El procedimiento descrito anteriormente se implementa en el siguiente ejemplo. Se crea una nota de audio simple que sube y baja de acuerdo con un sobre de linseg. Con el fin de realizar un seguimiento de su amplitud, los valores de audio se convierten en valores de k-velocidad y luego se cuadran, luego ra&iacute;z cuadrada y luego escritos en ubicaciones secuenciales de una matriz de 31 valores de largo. La media se calcula sumando todos los valores en la matriz y dividido por la longitud de la matriz. Este procedimiento se repite cada ciclo k. La longitud de la matriz ser&aacute; cr&iacute;tica en el ajuste fino de la respuesta por las razones descritas en el p&aacute;rrafo anterior. La velocidad de control (kr) tambi&eacute;n ser&aacute; un factor por lo que se tiene en cuenta al calcular el tama&ntilde;o de la matriz. Cambiar la velocidad de control (kr) o el n&uacute;mero de muestras de audio en un per&iacute;odo de control (ksmps) ya no alterar&aacute; el comportamiento de la respuesta.</p>
<p><em><strong>EXAMPLE 05L01_Amplitude_Tracking_First_Principles.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-dm0 -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr = 44100
ksmps = 16
nchnls = 1
0dbfs = 1

; a rich waveform
giwave ftgen 1,0, 512, 10, 1,1/2,1/3,1/4,1/5

instr   1
 ; create an audio signal
 aenv    linseg     0,p3/2,1,p3/2,0  ; triangle shaped envelope
 aSig    poscil     aenv,300,giwave  ; audio oscillator
         out        aSig             ; send audio to output

 ; track amplitude
 kArr[]   init  500 / ksmps     ; initialise an array
 kNdx     init  0               ; initialise index for writing to array
 kSig     downsamp        aSig  ; create k-rate version of audio signal
 kSq      =     kSig ^ 2        ; square it (negatives become positive)
 kRoot    =     kSq ^ 0.5       ; square root it (restore absolute values)
 kArr[kNdx] =   kRoot           ; write result to array
 kMean      =   sumarray(kArr) / lenarray(kArr) ; calculate mean of array
                printk  0.1,kMean   ; print mean to console
; increment index and wrap-around if end of the array is met
 kNdx           wrap    kNdx+1, 0, lenarray(kArr)
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 5
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;
</pre>
<p>In practice it is not necessary for us to build our own amplitude tracker as Csound already offers several opcodes for the task. rms outputs a k-rate amplitude tracking signal by employing mathematics similar to those described above. follow outputs at a-rate and uses a sample and hold method as it outputs data, probably necessitating some sort of low-pass filtering of the output signal. follow2 also outputs at a-rate but smooths the output signal by different amounts depending on whether the amplitude is rising or falling.</p>
<p>En la pr&aacute;ctica no es necesario para nosotros construir nuestro propio tracker de amplitud ya que Csound ya ofrece varios opcodes para la tarea. Rms emite una se&ntilde;al de seguimiento de amplitud k-rate empleando matem&aacute;ticas similares a las descritas anteriormente. Siguen las salidas a una velocidad y usan un m&eacute;todo de muestreo y retenci&oacute;n a medida que emite datos, probablemente requiriendo alg&uacute;n tipo de filtrado de paso bajo de la se&ntilde;al de salida. Follow2 tambi&eacute;n da salida a una velocidad, pero suaviza la se&ntilde;al de salida en diferentes cantidades dependiendo de si la amplitud est&aacute; subiendo o bajando.</p>
<p>A quick comparison of these three opcodes and the original method from first principles is given below:</p>
<p>Una comparaci&oacute;n r&aacute;pida de estos tres opcodes y el m&eacute;todo original de los primeros principios se da a continuaci&oacute;n:</p>
<p>&nbsp;</p>
<p>The sound file used in all three comparisons is 'fox.wav' which can be found as part of the Csound HTML Manual download. This sound is someone saying: &ldquo;the quick brown fox jumps over the lazy dog&rdquo;.</p>
<p>El archivo de sonido utilizado en las tres comparaciones es fox.wav que se puede encontrar como parte de la descarga del manual Csound HTML. Este sonido es alguien que dice: \This sound is someone saying: &ldquo;the quick brown fox jumps over the lazy dog&rdquo;.</p>
<p><img src="static/fox.png" alt="" /></p>
<p>First of all by employing the the technique exemplified in example 05L01, the amplitude following signal is overlaid upon the source signal:</p>
<p>En primer lugar empleando la t&eacute;cnica ejemplificada en el ejemplo 05L01, la se~nal de seguimiento de amplitud se superpone a la se~nal fuente:</p>
<p><img src="static/Homebrew.png" alt="" /></p>
<p>&nbsp;</p>
<p>It can be observed that the amplitude tracking signal follows the amplitudes of the input signal reasonably well. A slight delay in response at sound onsets can be observed as the array of values used by the averaging mechanism fills with appropriately high values. As discussed earlier, reducing the size of the array will improve response at the risk of introducing ripple. Another approach to dealing with the issue of ripple is to low-pass filter the signal output by the amplitude follower. This is an approach employed by the follow2 opcode. The second thing that is apparent is that the amplitude following signal does not attain the peak value of the input signal. At its peaks, the amplitude following signal is roughly 1/3 of the absolute peak value of the input signal. How close it gets to the absolute peak amplitude depends somewhat on the dynamic nature of the input signal. If an input signal sustains a peak amplitude for some time then the amplitude following signal will tend to this peak value.</p>
<p>Se puede observar que la se&ntilde;al de seguimiento de amplitud sigue razonablemente bien las amplitudes de la se&ntilde;al de entrada. Se puede observar un ligero retraso en la respuesta en los ensayos de sonido cuando la matriz de valores utilizada por el mecanismo de promediado se llena con valores apropiadamente altos. Como se discuti&oacute; anteriormente, la reducci&oacute;n del tama&ntilde;o de la matriz mejorar&aacute; la respuesta con el riesgo de introducir ondulaci&oacute;n. Otra aproximaci&oacute;n para tratar la cuesti&oacute;n de la ondulaci&oacute;n es el filtro de paso bajo la salida de se&ntilde;al por el seguidor de amplitud. Este es un enfoque empleado por el c&oacute;digo de operaci&oacute;n follow2. La segunda cosa que es evidente es que la se&ntilde;al de amplitud siguiente no alcanza el valor de pico de la se&ntilde;al de entrada. En sus picos, la se&ntilde;al de amplitud siguiente es aproximadamente 1/3 del valor de pico absoluto de la se&ntilde;al de entrada. La proximidad de la amplitud de pico absoluto depende en cierta medida de la naturaleza din&aacute;mica de la se&ntilde;al de entrada. Si una se&ntilde;al de entrada sostiene una amplitud de pico durante alg&uacute;n tiempo, entonces la se&ntilde;al de amplitud siguiente tender&aacute; a este valor de pico.</p>
<p>The rms opcode employs a method similar to that used in the previous example but with the convenience of an encapsulated opcode. Its output superimposed upon the waveform is shown below:</p>
<p>El opcode rms emplea un m&eacute;todo similar al utilizado en el ejemplo anterior pero con la conveniencia de un c&oacute;digo de operaci&oacute;n encapsulado. Su salida superpuesta a la forma de onda se muestra a continuaci&oacute;n:</p>
<p><img src="static/rms.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Its method of averaging uses filtering rather than simply taking a mean of a buffer of amplitude values. rms allows us to set the cutoff frequency (kCf) of its internal filter:</p>
<p>Su m&eacute;todo de promediaci&oacute;n utiliza el filtrado en lugar de simplemente tomar una media de un buffer de valores de amplitud. Rms nos permite establecer la frecuencia de corte (kCf) de su filtro interno:</p>
<p>kRms&nbsp; rms&nbsp; aSig, kCf</p>
<p>This is an optional argument which defaults to 10. Lowering this value will dampen changes in rms and smooth out ripple, raising it will improve the response but increase the audibility of ripple. A choice can be made based on some foreknowledge of the input audio signal: dynamic percussive input audio might demand faster response whereas audio that dynamically evolves gradually might demand greater smoothing.</p>
<p>Este es un argumento opcional cuyo valor por defecto es 10. Bajar este valor amortiguar&aacute; los cambios en rms y suavizar&aacute; la ondulaci&oacute;n, elevarla mejorar&aacute; la respuesta pero aumentar&aacute; la audibilidad de la ondulaci&oacute;n. Una elecci&oacute;n puede hacerse bas&aacute;ndose en alg&uacute;n conocimiento previo de la se&ntilde;al de audio de entrada: el audio de entrada de percusi&oacute;n din&aacute;mica puede exigir una respuesta m&aacute;s r&aacute;pida, mientras que el audio que evoluciona din&aacute;micamente gradualmente puede exigir un mayor suavizado.</p>
<p>&nbsp;</p>
<p>The follow opcode uses a sample-and-hold mechanism when outputting the tracked amplitude. This can result in a stepped output that might require addition lowpass filtering before use. We actually defined the period, the duration for which values are held, using its second input argument. The update rate will be one over the period. In the following example the audio is amplitude tracked using the following line:</p>
<p>El opcode de seguimiento utiliza un mecanismo de muestreo y retenci&oacute;n cuando se emite la amplitud de seguimiento. Esto puede resultar en una salida escalonada que podr&iacute;a requerir un filtro de paso bajo de adici&oacute;n antes del uso. De hecho, definimos el per&iacute;odo, la duraci&oacute;n para la cual los valores se mantienen, utilizando su segundo argumento de entrada. La tasa de actualizaci&oacute;n ser&aacute; una durante el per&iacute;odo. En el siguiente ejemplo, el audio se controla mediante la siguiente l&iacute;nea:</p>
<p>&nbsp;</p>
<p>aRms&nbsp;&nbsp;&nbsp; follow&nbsp;&nbsp;&nbsp; aSig, 0.01</p>
<p>with the following result:</p>
<p>Con el siguiente resultado:</p>
<p><img src="static/follow.png" alt="" /></p>
<p>The hump over the word spoken during the third and fourth time divisions initially seem erroneous but it is a result of greater amplitude excursion into the negative domain. follow provides a better reflection of absolute peak amplitude.</p>
<p>La joroba sobre la palabra hablada durante la tercera y cuarta divisiones de tiempo inicialmente parece err&oacute;nea, pero es el resultado de una mayor excursi&oacute;n de amplitud en el dominio negativo. Proporciona una mejor reflexi&oacute;n de la amplitud de pico absoluta.</p>
<p>follow2 uses a different algorithm with smoothing on both upward and downward slopes of the tracked amplitude. We can define different values for attack and decay time. In the following example the decay time is much longer than the attack time. The relevant line of code is:</p>
<p>Follow2 utiliza un algoritmo diferente con suavizado en pendientes hacia arriba y hacia abajo de la amplitud de seguimiento. Podemos definir diferentes valores para el tiempo de ataque y decadencia. En el ejemplo siguiente, el tiempo de decaimiento es mucho m&aacute;s largo que el tiempo de ataque. La l&iacute;nea de c&oacute;digo relevante es:</p>
<p>iAtt&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.04</p>
<pre>iRel&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.5
aTrk&nbsp; follow2&nbsp; aSig, 0.04, 0.5</pre>
<p>and the result of amplitude tracking is:</p>
<p>Y el resultado del seguimiento de amplitud es:</p>
<p><img src="static/follow2.png" alt="" /></p>
<p>This technique can be used to extend the duration of short input sound events or triggers. Note that the attack and release times for follow2 can also be modulated at k-rate.</p>
<p>Esta t&eacute;cnica se puede utilizar para ampliar la duraci&oacute;n de los eventos de sonido de entrada corta o disparadores. Tenga en cuenta que los tiempos de ataque y liberaci&oacute;n para follow2 tambi&eacute;n se pueden modular en k-rate.</p>
<p>&nbsp;</p>
<p>Dynamic Gating and Amplitude Triggering</p>
<p>Gating din&aacute;mico y amplitud de disparo</p>
<p>Once we have traced the changing amplitude of an audio signal it is straightforward to use specific changes in that function to trigger other events within Csound. The simplest technique would be to simply define a threshold above which one thing happens and below which something else happens. A crude dynamic gating of the signal above could be implemented thus:</p>
<p>Una vez que hemos rastreado la amplitud cambiante de una se&ntilde;al de audio, es f&aacute;cil utilizar cambios espec&iacute;ficos en esa funci&oacute;n para activar otros eventos dentro de Csound. La t&eacute;cnica m&aacute;s simple ser&iacute;a simplemente definir un umbral por encima del cual sucede una cosa y por debajo de la cual algo m&aacute;s sucede. Un cruce din&aacute;mico crudo de la se&ntilde;al anterior podr&iacute;a ser implementado as&iacute;:</p>
<p><em><strong>EXAMPLE 05L02_Simple_Dynamic_Gate.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;&nbsp;&nbsp;
-dm0 -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

ksmps = 32
0dbfs = 1&nbsp;
; this is a necessary definition,
;         otherwise amplitude will be -32768 to 32767

instr&nbsp;&nbsp;&nbsp; 1
&nbsp;aSig&nbsp;&nbsp;&nbsp; diskin&nbsp; "fox.wav", 1&nbsp;&nbsp;      ; read sound file
&nbsp;kRms&nbsp;&nbsp;&nbsp; rms&nbsp;    aSig&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;   ; scan rms
&nbsp;iThreshold =    0.1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;   ; rms threshold
&nbsp;kGate&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;    kRms &gt; iThreshold ? 1 : 0&nbsp; ; gate either 1 or zero
&nbsp;aGate&nbsp;&nbsp; interp&nbsp; kGate&nbsp;&nbsp; ; interpolate to create smoother on-&gt;off-&gt;on switching
&nbsp;aSig&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;    aSig * aGate&nbsp;&nbsp;&nbsp; &nbsp;   ; multiply signal by gate
&nbsp;&nbsp;&nbsp;&nbsp;     out&nbsp;    aSig&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  ; send to output
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;
</pre>
<p>Once a dynamic threshold has been defined, in this case 0.1, the RMS value is interrogated every k-cycle as to whether it is above or below this value. If it is above, then the variable kGate adopts a value of '1' (open) or if below, kGate is zero (closed). This on/off switch could just be multiplied to the audio signal to turn it on or off according to the status of the gate but clicks would manifest each time the gates opens or closes so some sort of smoothing or ramping of the gate signal is required. In this example I have simply interpolated it using the 'interp' opcode to create an a-rate signal which is then multiplied to the original audio signal. This means that a linear ramp with be added across the duration of a k-cycle in audio samples &ndash; in this case 32 samples. A more elaborate approach might involve portamento and low-pass filtering. The results of this dynamic gate are shown below:</p>
<p>Una vez que se ha definido un umbral din&aacute;mico, en este caso 0,1, el valor RMS es interrogado cada ciclo k en cuanto a si est&aacute; por encima o por debajo de este valor. Si est&aacute; arriba, entonces la variable kGate adopta un valor de 1 (abierto) o si est&aacute; por debajo, kGate es cero (cerrado). Este interruptor de encendido / apagado s&oacute;lo podr&iacute;a multiplicarse a la se&ntilde;al de audio para encender o apagar seg&uacute;n el estado de la puerta, pero los clics se manifiestan cada vez que las puertas se abre o se cierra por lo que alg&uacute;n tipo de suavizado o ramping de la se&ntilde;al de la puerta se requiere . En este ejemplo, simplemente lo he interpolado usando el c&oacute;digo de operaci&oacute;n interp para crear una se&ntilde;al a-rate que se multiplica a la se&ntilde;al de audio original. Esto significa que se a&ntilde;ade una rampa lineal con la duraci&oacute;n de un ciclo k en muestras de audio - en este caso 32 muestras. Un enfoque m&aacute;s elaborado podr&iacute;a implicar el portamento y el filtrado de paso bajo. Los resultados de esta puerta din&aacute;mica se muestran a continuaci&oacute;n:</p>
<p><img src="static/Gate.png" alt="" /></p>
<p>The threshold is depicted as a red line. It can be seen that each time the RMS value (the black line) drops below the threshold the audio signal (blue waveform) is muted.</p>
<p>El umbral se representa como una l&iacute;nea roja. Se puede ver que cada vez que el valor RMS (la l&iacute;nea negra) cae por debajo del umbral, la se&ntilde;al de audio (forma de onda azul) se silencia.</p>
<p>The simple solution described above can prove adequate in applications where the user wishes to sense sound event onsets and convert them to triggers but in more complex situations, in particular when a new sound event occurs whilst the previous event is still sounding and pushing the RMS above the threshold, this mechanism will fail. In these cases triggering needs to depend upon dynamic change rather than absolute RMS values. If we consider a two-event sound file where two notes sound on a piano, the second note sounding while the first is still decaying, triggers generated using the RMS threshold mechanism from the previous example will only sense the first note onset. (In the diagram below this sole trigger is illustrated by the vertical black line.) Raising the threshold might seem to be remedial action but is not ideal as this will prevent quietly played notes from generating triggers.</p>
<p>La soluci&oacute;n simple descrita anteriormente puede resultar adecuada en aplicaciones en las que el usuario desea detectar los eventos de eventos sonoros y convertirlos en activadores, pero en situaciones m&aacute;s complejas, en particular cuando un nuevo evento de sonido se produce mientras el evento anterior sigue sonando y empujando el RMS anterior El umbral, este mecanismo fallar&aacute;. En estos casos, la activaci&oacute;n debe depender de cambios din&aacute;micos en lugar de valores RMS absolutos. Si consideramos un archivo de sonido de dos eventos en el que dos notas sonan en un piano, la segunda nota sonando mientras la primera est&aacute; todav&iacute;a en decadencia, los disparadores generados usando el mecanismo de umbral de RMS del ejemplo anterior s&oacute;lo detectar&aacute;n el inicio de la primera nota. (En el diagrama de abajo, este &uacute;nico disparador se ilustra con la l&iacute;nea negra vertical). Elevar el umbral puede parecer una acci&oacute;n correctiva, pero no es ideal, ya que esto evitar&aacute; que las notas reproducidas en silencio generen disparadores.</p>
<p><img src="static/ThresholdTriggering.png" alt="" /></p>
<p>&nbsp;</p>
<p>It will often be more successful to use magnitudes of amplitude increase to decide whether to generate a trigger or not. The two critical values in implementing such a mechanism are the time across which a change will be judged ('iSampTim' in the example) and the amount of amplitude increase that will be required to generate a trigger (iThresh). An additional mechanism to prevent double triggerings if an amplitude continues to increase beyond the time span of a single sample period will also be necessary. What this mechanism will do is to bypass the amplitude change interrogation code for a user-definable time period immediately after a trigger has been generated (iWait). A timer which counts elapsed audio samples (kTimer) is used to time how long to wait before retesting amplitude changes.</p>
<p>A menudo ser&aacute; m&aacute;s exitoso utilizar magnitudes de aumento de amplitud para decidir si se genera un gatillo o no. Los dos valores cr&iacute;ticos en la implementaci&oacute;n de dicho mecanismo son el tiempo a trav&eacute;s del cual se juzgar&aacute; un cambio (iSampTim en el ejemplo) y la cantidad de aumento de amplitud que se requerir&aacute; para generar un disparo (iThresh). Tambi&eacute;n ser&aacute; necesario un mecanismo adicional para evitar disparos dobles si una amplitud contin&uacute;a aumentando m&aacute;s all&aacute; del tiempo de un solo per&iacute;odo de muestra. Lo que este mecanismo har&aacute; es pasar por alto el c&oacute;digo de interrogaci&oacute;n de cambio de amplitud para un per&iacute;odo de tiempo definido por el usuario inmediatamente despu&eacute;s de que se haya generado un disparador (iWait). Se utiliza un temporizador que cuenta las muestras de audio transcurridas (kTimer) para medir el tiempo de espera antes de que cambie la amplitud de la prueba.</p>
<p>If we pass our piano sound file through this instrument, the results look like this:</p>
<p>Si pasamos nuestro archivo de sonido de piano a trav&eacute;s de este instrumento, los resultados se ven as&iacute;:</p>
<p><img src="/csound/_edit/static/DynamicTrigger.png" alt="" /></p>
<p>This time we correctly receive two triggers, one at the onset of each note. The example below tracks audio from the sound-card input channel 1 using this mechanism.</p>
<p>Esta vez recibimos correctamente dos disparadores, uno al inicio de cada nota. El siguiente ejemplo reproduce el audio del canal de entrada 1 de la tarjeta de sonido utilizando este mecanismo.</p>
<p><em><strong>EXAMPLE 05L03_Dynamic_Trigger.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;&nbsp;&nbsp;
-dm0 -iadc -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 44100
ksmps&nbsp; =&nbsp; 32
nchnls =&nbsp; 2
0dbfs&nbsp; =&nbsp; 1

instr&nbsp;&nbsp; 1
&nbsp;iThresh&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; change threshold
&nbsp;aSig&nbsp;&nbsp;&nbsp;&nbsp; inch&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; live audio in
&nbsp;iWait&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    ; prevent repeats wait time (in samples)
&nbsp;kTimer&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp; 1001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; initial timer value
&nbsp;kRms&nbsp;&nbsp;&nbsp;&nbsp; rms&nbsp;&nbsp;&nbsp;&nbsp; aSig, 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; track amplitude
&nbsp;iSampTim =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.01&nbsp;&nbsp;&nbsp; ; time across which change in RMS will be measured
&nbsp;kRmsPrev delayk&nbsp; kRms, iSampTim&nbsp;&nbsp;&nbsp;&nbsp; ; delayed RMS (previous)
&nbsp;kChange&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kRms - kRmsPrev&nbsp;&nbsp;&nbsp; ; change
&nbsp;if(kTimer&gt;iWait) then&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; if we are beyond the wait time...
&nbsp; kTrig&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kChange &gt; iThresh ? 1 : 0 ; trigger if threshold exceeded
&nbsp; kTimer&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kTrig == 1 ? 0 : kTimer ; reset timer when a trigger generated
&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ; otherwise (we are within the wait time buffer)
&nbsp; kTimer&nbsp; +=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ksmps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; increment timer
&nbsp; kTrig&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cancel trigger
&nbsp;endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedkwhen kTrig,0,0,2,0,0.1 ; trigger a note event
endin

instr&nbsp;&nbsp; 2
&nbsp;aEnv&nbsp;&nbsp;&nbsp;&nbsp; transeg&nbsp;&nbsp; 0.2, p3, -4, 0&nbsp;&nbsp;&nbsp;&nbsp; ; decay envelope
&nbsp;aSig&nbsp;&nbsp;&nbsp;&nbsp; poscil&nbsp;&nbsp;&nbsp; aEnv, 400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 'ping' sound indicator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aSig&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; send audio to output
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 [3600*24*7]
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;&nbsp;
</pre>
<p>&nbsp;</p>
<p>Pitch Tracking</p>
<p>Pitch Tracking</p>
<p>Csound currently provides five opcode options for pitch tracking. In ascending order of newness they are: pitch, pitchamdf, pvspitch, ptrack and plltrack. Related to these opcodes are pvscent and centroid but rather than track the harmonic fundamental, they track the spectral centroid of a signal. An example and suggested application for centroid is given a little later on in this chapter.</p>
<p>Csound actualmente ofrece cinco opciones de opcode para el seguimiento de tono. En orden ascendente de novedad son: pitch, pitchamdf, pvspitch, ptrack y plltrack. Relacionados con estos opcodes son pvscent y centroide, pero en lugar de rastrear la fundamental arm&oacute;nica, rastrean el centroide espectral de una se&ntilde;al. Un ejemplo y la aplicaci&oacute;n sugerida para el centroide se da un poco m&aacute;s adelante en este cap&iacute;tulo.</p>
<p>Each offers a slightly different set of features &ndash; some offer simultaneous tracking of both amplitude and pitch, some only pitch tracking. None of these opcodes provide more than one output for tracked frequency therefore none offer polyphonic tracking although in a polyphonic tone the fundamental of the strongest tone will most likely be tracked. Pitch tracking presents many more challenges than amplitude tracking therefore a degree of error can be expected and will be an issue that demands addressing. To get the best from any pitch tracker it is important to consider preparation of the input signal &ndash; either through gating or filtering &ndash; and also processing of the output tracking data, for example smoothing changes through the use of filtering opcode such as port, median filtering to remove erratic and erroneous data and a filter to simply ignore obviously incorrect data.</p>
<p>Cada uno ofrece un conjunto ligeramente diferente de caracter&iacute;sticas - algunas ofrecen un seguimiento simult&aacute;neo de la amplitud y el tono, algunos seguimiento solo. Ninguno de estos opcodes proporciona m&aacute;s de una salida para la frecuencia seguida, por lo tanto, ninguno ofrece un seguimiento polif&oacute;nico, aunque en un tono polif&oacute;nico es muy probable que se rastree el fundamental del tono m&aacute;s fuerte. El seguimiento del tono presenta muchos m&aacute;s desaf&iacute;os que el seguimiento de la amplitud, por lo tanto, se puede esperar un grado de error y ser&aacute; un problema que exige abordar. Para obtener lo mejor de cualquier rastreador de tono, es importante considerar la preparaci&oacute;n de la se&ntilde;al de entrada, ya sea a trav&eacute;s de gating o filtrado, y tambi&eacute;n el procesamiento de los datos de seguimiento de salida, por ejemplo, los cambios de suavizado mediante el uso de opcode de filtrado, Para eliminar datos err&aacute;ticos y err&oacute;neos y un filtro simplemente ignorar datos obviamente incorrectos.</p>
<p>Parameters for these procedures will rely upon some prior knowledge of the input signal, the pitch range of an instrument for instance. A particularly noisy environment or a distant microphone placement might demand more aggressive noise gating. In general some low-pass filtering of the input signal will always help in providing a more stable frequency tracking signal. Something worth considering is that the attack portion of a note played on an acoustic instrument generally contains a lot of noisy, harmonically chaotic material. This will tend to result in slightly chaotic movement in the pitch tracking signal, we may therefore wish to sense the onset of a note and only begin tracking pitch once the sustain portion has begun. This may be around 0.05 seconds after the note has begun but will vary from instrument to instrument and from note to note. In general lower notes will have a longer attack. However we do not really want to overestimate the duration of this attack stage as this will result in a sluggish pitch tracker. Another specialised situation is the tracking of pitch in singing &ndash; we may want to gate sibilant elements ('sss', 't' etc.). pvscent can be useful in detecting the difference between vowels and sibilants.</p>
<p>Los par&aacute;metros para estos procedimientos se basar&aacute;n en alg&uacute;n conocimiento previo de la se&ntilde;al de entrada, el rango de tono de un instrumento, por ejemplo. Un entorno particularmente ruidoso o una colocaci&oacute;n de micr&oacute;fono distante podr&iacute;a exigir un gating m&aacute;s agresivo del ruido. En general, algunos filtros de paso bajo de la se&ntilde;al de entrada siempre ayudar&aacute;n a proporcionar una se&ntilde;al de seguimiento de frecuencia m&aacute;s estable. Algo que vale la pena considerar es que la porci&oacute;n de ataque de una nota tocada en un instrumento ac&uacute;stico generalmente contiene un mont&oacute;n de material ruidoso, arm&oacute;nicamente ca&oacute;tico. Esto tender&aacute; a dar lugar a un movimiento ligeramente ca&oacute;tico en la se&ntilde;al de seguimiento de tono, por lo tanto, puede que desee detectar el inicio de una nota y s&oacute;lo comenzar el paso de seguimiento una vez que la parte de sost&eacute;n ha comenzado. Esto puede ser alrededor de 0,05 segundos despu&eacute;s de que la nota haya comenzado, pero variar&aacute; de instrumento a instrumento y de nota a nota. En general, las notas inferiores tendr&aacute;n un ataque m&aacute;s largo. Sin embargo, realmente no queremos sobrestimar la duraci&oacute;n de esta etapa de ataque, ya que esto dar&aacute; lugar a un rastreador pitch lento. Otra situaci&oacute;n especializada es el seguimiento del tono en el canto - es posible que desee a la puerta elementos sibilantes (sss, t, etc). Pvscent puede ser &uacute;til en la detecci&oacute;n de la diferencia entre vocales y sibilantes.</p>
<p>'pitch' is the oldest of the pitch tracking opcodes on offer and provides the widest range of input parameters.</p>
<p>Pitch es el m&aacute;s antiguo de los opcodes de seguimiento de tono ofrecidos y ofrece la m&aacute;s amplia gama de par&aacute;metros de entrada.</p>
<p>koct, kamp pitch asig, iupdte, ilo, ihi, idbthresh [, ifrqs] [, iconf] \</p>
<pre>      [, istrt] [, iocts] [, iq] [, inptls] [, irolloff] [, iskip]
</pre>
<p>This makes it somewhat more awkward to use initially (although many of its input parameters are optional) but some of its options facilitate quite specialised effects. Firstly it outputs its tracking signal in 'oct' format. This might prove to be a useful format but conversion to other formats is easy anyway. Apart from a number of parameters intended to fine tune the production of an accurate signal it allows us to specify the number of octave divisions used in quantising the output. For example if we give this a value of 12 we have created the basis of a simple chromatic 'autotune' device. We can also quantise the procedure in the time domain using its 'update period' input. Material with quickly changing pitch or vibrato will require a shorter update period (which will demand more from the CPU). It has an input control for 'threshold of detection' which can be used to filter out and disregard pitch and amplitude tracking data beneath this limit. Pitch is capable of very good pitch and amplitude tracking results in real-time.</p>
<p>Esto hace que sea un poco m&aacute;s dif&iacute;cil de usar inicialmente (aunque muchos de sus par&aacute;metros de entrada son opcionales), pero algunas de sus opciones facilitan efectos bastante especializados. En primer lugar, emite su se&ntilde;al de seguimiento en formato oct. Esto podr&iacute;a resultar ser un formato &uacute;til, pero la conversi&oacute;n a otros formatos es f&aacute;cil de todos modos. Aparte de una serie de par&aacute;metros destinados a afinar la producci&oacute;n de una se&ntilde;al precisa que nos permite especificar el n&uacute;mero de octavas divisiones utilizadas en la cuantificaci&oacute;n de la salida. Por ejemplo, si le damos a este un valor de 12, hemos creado la base de un dispositivo crom&aacute;tico autotune simple. Tambi&eacute;n podemos cuantificar el procedimiento en el dominio de tiempo usando su entrada de per&iacute;odo de actualizaci&oacute;n. El material con cambio r&aacute;pido de tono o vibrato requerir&aacute; un per&iacute;odo de actualizaci&oacute;n m&aacute;s corto (que requerir&aacute; m&aacute;s de la CPU). Tiene un control de entrada para el umbral de detecci&oacute;n que puede usarse para filtrar y despreciar los datos de seguimiento de amplitud y tono por debajo de este l&iacute;mite. Pitch es capaz de muy buen pitch y amplitud de seguimiento de resultados en tiempo real.</p>
<p>pitchamdf uses the so-called 'Average Magnitude Difference Function' method. It is perhaps slightly more accurate than pitch as a general purpose pitch tracker but its CPU demand is higher.</p>
<p>Pitchamdf utiliza el denominado m&eacute;todo de Diferencia de Magnitud Promedio. Es tal vez un poco m&aacute;s preciso que el tono como un rastreador de paso de prop&oacute;sito general, pero su demanda de CPU es mayor.</p>
<p>pvspitch uses streaming FFT technology to track pitch. It takes an f-signal as input which will have to be created using the pvsanal opcode. At this step the choice of FFT size will have a bearing upon the performance of the pvspitch pitch tracker. Smaller FFT sizes will allow for faster tracking but with perhaps some inaccuracies, particularly with lower pitches whereas larger FFT sizes are likely to provide for more accurate pitch tracking at the expense of some time resolution. pvspitch tries to mimic certain functions of the human ear in how it tries to discern pitch. pvspitch works well in real-time but it does have a tendency to jump its output to the wrong octave &ndash; an octave too high &ndash; particularly when encountering vibrato.</p>
<p>Pvspitch utiliza la tecnolog&iacute;a FFT de transmisi&oacute;n para rastrear el tono. Se necesita una se&ntilde;al f como entrada que tendr&aacute; que ser creado usando el c&oacute;digo de operaci&oacute;n pvsanal. En este paso, la elecci&oacute;n del tama&ntilde;o de la FFT tendr&aacute; un efecto sobre el rendimiento del pvspitch pitch tracker. Los tama&ntilde;os FFT m&aacute;s peque&ntilde;os permitir&aacute;n un rastreo m&aacute;s r&aacute;pido, pero con quiz&aacute;s algunas imprecisiones, particularmente con niveles m&aacute;s bajos, mientras que tama&ntilde;os FFT m&aacute;s grandes son propensos a proporcionar un seguimiento de tono m&aacute;s preciso a expensas de alguna resoluci&oacute;n temporal. Pvspitch trata de imitar ciertas funciones del o&iacute;do humano en c&oacute;mo trata de discernir el tono. Pvspitch funciona bien en tiempo real, pero tiene una tendencia a saltar su salida a la octava equivocada - una octava demasiado alta - particularmente al encontrar vibrato.</p>
<p>&nbsp;</p>
<p>ptrack also makes uses of streaming FFT but takes an normal audio signal as input, performing the FFT analysis internally. We still have to provide a value for FFT size with the same considerations mentioned above. ptrack is based on an algorithm by Miller Puckette, the co-creator of MaxMSP and creator of PD. ptrack also works well in real-time but it does have a tendency to jump to erroneous pitch tracking values when pitch is changing quickly or when encountering vibrato. Median filtering (using the mediank opcode) and filtering of outlying values might improve the results.</p>
<p>Ptrack tambi&eacute;n hace uso de streaming FFT pero toma una se&ntilde;al de audio normal como entrada, realizando el an&aacute;lisis de FFT internamente. Todav&iacute;a tenemos que proporcionar un valor para el tama&ntilde;o FFT con las mismas consideraciones mencionadas anteriormente. Ptrack se basa en un algoritmo de Miller Puckette, el co-creador de MaxMSP y creador de PD. Ptrack tambi&eacute;n funciona bien en tiempo real, pero tiene una tendencia a saltar a valores err&oacute;neos de seguimiento de tono cuando el tono est&aacute; cambiando r&aacute;pidamente o cuando se encuentra con vibrato. El filtrado mediano (utilizando el opcode mediank) y el filtrado de valores perif&eacute;ricos podr&iacute;an mejorar los resultados.</p>
<p>plltrack uses a phase-locked loop algorithm in detecting pitch. plltrack is another efficient real-time option for pitch tracking. It has a tendency to gliss up and down from very low frequency values at the start and end of notes, i.e. when encountering silence. This effect can be minimised by increasing its 'feedback' parameter but this can also make pitch tracking unstable over sustained notes.</p>
<p>Plltrack utiliza un algoritmo de bucle de fase bloqueada en la detecci&oacute;n de tono. Plltrack es otra opci&oacute;n en tiempo real eficiente para el seguimiento del tono. Tiene una tendencia a deslizar hacia arriba y hacia abajo desde valores de frecuencia muy baja al comienzo y al final de las notas, es decir, cuando se encuentra con el silencio. Este efecto se puede minimizar aumentando su par&aacute;metro de realimentaci&oacute;n, pero esto tambi&eacute;n puede hacer que el seguimiento de tono sea inestable sobre notas sostenidas.</p>
<p>In conclusion, pitch is probably still the best choice as a general purpose pitch tracker, pitchamdf is also a good choice. pvspitch, ptrack and plltrack all work well in real-time but might demand additional processing to remove errors.</p>
<p>En conclusi&oacute;n, el tono es probablemente todav&iacute;a la mejor opci&oacute;n como un rastreador de pitch de prop&oacute;sito general, pitchamdf es tambi&eacute;n una buena opci&oacute;n. Pvspitch, ptrack y plltrack funcionan bien en tiempo real pero pueden requerir procesamiento adicional para eliminar errores.</p>
<p>pvscent and centroid are a little different to the other pitch trackers in that, rather than try to discern the fundemental of a harmonic tone, they assess what the centre of gravity of a spectrum is. An application for this is in the identification of different instruments playing the same note. Softer, darker instruments, such as the french horn, will be characterised by a lower centroid to that of more shrill instruments, such as the violin.</p>
<p>Pvscent y centroide son un poco diferentes a los otros pitch trackers en que, en lugar de tratar de discernir el fundemental de un tono arm&oacute;nico, que evaluar lo que el centro de gravedad de un espectro es. Una aplicaci&oacute;n para esto se encuentra en la identificaci&oacute;n de diferentes instrumentos tocando la misma nota. Instrumentos m&aacute;s suaves y oscuros, como el cuerno franc&eacute;s, se caracterizar&aacute;n por un centroide inferior al de instrumentos m&aacute;s agudos, como el viol&iacute;n.</p>
<p>Both opcodes use FFT. Centroid works directly with an audio signal input whereas pvscent requires an f-sig input. Centroid also features a trigger input which allows us to manually trigger it to update its output. In the following example we use centroid to detect individual drums sounds &ndash; bass drum, snare drum, cymbal &ndash; within a drum loop. We will use the dynamic amplitude trigger from earlier on in this chapter to detect when sound onsets are occurring and use this trigger to activate centroid and also then to trigger another instrument with a replacement sound.</p>
<p>Ambos opcodes utilizan FFT. Centroid trabaja directamente con una entrada de se&ntilde;al de audio, mientras que pvscent requiere una entrada f-sig. Centroid tambi&eacute;n cuenta con una entrada de disparo que nos permite activarla manualmente para actualizar su salida. En el siguiente ejemplo usamos el centroide para detectar sonidos de tambores individuales - bombo, caja, c&iacute;mbalo - dentro de un bucle de bater&iacute;a. Utilizaremos el disparador de amplitud din&aacute;mica desde el principio de este cap&iacute;tulo para detectar cu&aacute;ndo se producen los sonidos y utilizar este disparador para activar el centroide y tambi&eacute;n para activar otro instrumento con un sonido de reemplazo.</p>
<p>Each percussion instrument in the original drum loop will be replaced with a different sound: bass drums will be replaced with a kalimba/thumb piano sound, snare drums will be replaced by hand claps (a la TR-808), and cymbal sounds will be replaced with tambourine sounds. The drum loop used is beats.wav which can be found with the download of the Csound HTML manual (and within the Csound download itself). This loop is not ideal as some of the instruments coincide with one another &ndash; for example, the first consists of a bass drum and a snare drum played together. The 'beat replacer' will inevitably make a decision one way or the other but is not advanced enough to detect both instruments playing simultaneously. The critical stage is the series of if... elseifs... at the bottom of instrument 1 where decisions are made about instruments' identities according to what centroid band they fall into. The user can fine tune the boundary division values to modify the decision making process. centroid values are also printed to the terminal when onsets are detected which might assist in this fine tuning.</p>
<p>Cada instrumento de percusi&oacute;n en el bucle de bater&iacute;a original ser&aacute; reemplazado por un sonido diferente: los bajos ser&aacute;n reemplazados por un sonido de piano kalimba / pulgar, los tambores ser&aacute;n reemplazados por aplausos manuales (a la TR-808), y los sonidos del platillo ser&aacute;n Reemplazado con sonidos de pandereta. El bucle de percusi&oacute;n utilizado es beats.wav que se puede encontrar con la descarga del manual Csound HTML (y dentro de la descarga de Csound). Este bucle no es ideal ya que algunos de los instrumentos coinciden entre s&iacute; - por ejemplo, el primero consiste en un bombo y un tambor de trampa que se tocan juntos. El sustituto del golpe inevitablemente tomar&aacute; una decisi&oacute;n de una manera u otra, pero no est&aacute; lo suficientemente avanzado como para detectar ambos instrumentos tocando simult&aacute;neamente. La etapa cr&iacute;tica es la serie de if ... elseifs ... en la parte inferior del instrumento 1 donde se toman decisiones sobre las identidades de los instrumentos de acuerdo a la banda centr&oacute;ide en la que caen. El usuario puede afinar los valores de divisi&oacute;n de l&iacute;mites para modificar el proceso de toma de decisiones. Los valores de centroide tambi&eacute;n se imprimen en el terminal cuando se detectan encendidos que podr&iacute;an ayudar en esta afinaci&oacute;n fina.</p>
<p>&nbsp;</p>
<p><em><strong>EXAMPLE 05L04_Drum_Replacement.csd</strong></em></p>
<pre><em><strong></strong></em>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-dm0 -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

instr   1
 asig   diskin  "beats.wav",1

 iThreshold = 0.05
 iWait      = 0.1*sr
 kTimer     init iWait+1
 iSampTim =       0.02                ; time across which RMS change is measured
 kRms   rms     asig ,20
 kRmsPrev       delayk  kRms,iSampTim ; rms from earlier
 kChange =      kRms - kRmsPrev       ; change (+ve or -ve)

 if kTimer &gt; iWait then               ; prevent double triggerings
  ; generate a trigger
  kTrigger   =  kChange &gt; iThreshold ? 1 : 0
  ; if trigger is generated, reset timer
  kTimer  =   kTrigger == 1 ? 0 : kTimer
 else
  kTimer  +=  ksmps                   ; increment timer
  kTrigger = 0                        ; clear trigger
 endif

 ifftsize = 1024
 ; centroid triggered 0.02 after sound onset to avoid noisy attack
 kDelTrig delayk kTrigger,0.02
 kcent  centroid asig, kDelTrig, ifftsize  ; scan centroid
        printk2  kcent            ; print centroid values
 if kDelTrig==1 then
  if kcent&gt;0 &amp;&amp; kcent&lt;2500 then   ; first freq. band
   event "i","Cowbell",0,0.1
  elseif kcent&lt;8000 then          ; second freq. band
   event "i","Clap",0,0.1
  else                            ; third freq. band
   event "i","Tambourine",0,0.5
  endif
 endif
endin

instr   Cowbell
 kenv1  transeg 1,p3*0.3,-30,0.2, p3*0.7,-30,0.2
 kenv2  expon   1,p3,0.0005
 kenv   =       kenv1*kenv2
 ipw    =       0.5
 a1     vco2    0.65,562,2,0.5
 a2     vco2    0.65,845,2,0.5
 amix   =       a1+a2
 iLPF2  =       10000
 kcf    expseg  12000,0.07,iLPF2,1,iLPF2
 alpf   butlp   amix,kcf
 abpf   reson   amix, 845, 25
 amix   dcblock2        (abpf*0.06*kenv1)+(alpf*0.5)+(amix*0.9)
 amix   buthp   amix,700
 amix   =       amix*0.5*kenv
        out     amix
endin

instr   Clap
 if frac(p1)==0 then
  event_i       "i", p1+0.1, 0,     0.02
  event_i       "i", p1+0.1, 0.01,  0.02
  event_i       "i", p1+0.1, 0.02,  0.02
  event_i       "i", p1+0.1, 0.03,  2
 else
  kenv  transeg 1,p3,-25,0
  iamp  random  0.7,1
  anoise        dust2   kenv*iamp, 8000
  iBPF          =       1100
  ibw           =       2000
  iHPF          =       1000
  iLPF          =       1
  kcf   expseg  8000,0.07,1700,1,800,2,500,1,500
  asig  butlp   anoise,kcf*iLPF
  asig  buthp   asig,iHPF
  ares  reson   asig,iBPF,ibw,1
  asig  dcblock2        (asig*0.5)+ares
        out     asig
 endif
endin

instr   Tambourine
        asig    tambourine      0.3,0.01 ,32, 0.47, 0, 2300 , 5600, 8000
                out     asig    ;SEND AUDIO TO OUTPUTS
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

