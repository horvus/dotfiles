
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: D-Function-Tables / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter D. FUNCTION TABLES" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter D. FUNCTION TABLES" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/d-function-tables/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <p>Csound: FUNCTIONTABLES</p>
<h1>FUNCTION TABLES</h1>
<p><em>Note: This chapter was written before arrays had been introduced into Csound. Now the usage of arrays is in some situations preferable to using function tables. Have a look in chapter 03E to see how you can use arrays. </em></p>
<p><em>Nota: Este cap&iacute;tulo fue escrito antes de que las matrices se hubieran introducido en Csound. Ahora el uso de arrays es en algunas situaciones preferible a usar tablas de funciones. Echa un vistazo en el cap&iacute;tulo 03E para ver c&oacute;mo puedes usar matrices. </em></p>
<p>A function table is essentially the same as what other audio programming languages might call a buffer, a table, a list or an array. It is a place where data can be stored in an ordered way. Each function table has a size: how much data (in Csound, just numbers) it can store. Each value in the table can be accessed by an index, counting from 0 to size-1. For instance, if you have a function table with a size of 10, and the numbers [1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89] in it, this is the relation of value and index:</p>
<p>Una tabla de funciones es esencialmente la misma que lo que otros lenguajes de programaci&oacute;n de audio podr&iacute;an llamar un b&uacute;fer, una tabla, una lista o una matriz. Es un lugar donde los datos se pueden almacenar de una manera ordenada. Cada tabla de funciones tiene un tama&ntilde;o: cu&aacute;nto datos (en Csound, s&oacute;lo n&uacute;meros) puede almacenar. Cada valor en la tabla puede ser accedido por un &iacute;ndice, contando de 0 a tama&ntilde;o-1. Por ejemplo, si usted tiene una tabla de funciones con un tama&ntilde;o de 10, y los n&uacute;meros [1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89] en ella, esta es la relaci&oacute;n de valor e &iacute;ndice:</p>
<p><br />&nbsp;</p>
<table border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td>&nbsp;VALUE</td>
<td>&nbsp;1.1</td>
<td>&nbsp;2.2</td>
<td>&nbsp;3.3</td>
<td style="text-align: center;">&nbsp;5.5</td>
<td>&nbsp;8.8</td>
<td style="text-align: center;">&nbsp;13.13</td>
<td>&nbsp;21.21</td>
<td>&nbsp;34.34</td>
<td style="text-align: center;">&nbsp;55.55</td>
<td>&nbsp;89.89</td>
</tr>
<tr>
<td>&nbsp;INDEX</td>
<td>&nbsp;0</td>
<td>&nbsp;1</td>
<td>&nbsp;2</td>
<td>&nbsp;3</td>
<td>&nbsp;4</td>
<td>&nbsp;5</td>
<td>&nbsp;6</td>
<td>&nbsp;7</td>
<td>&nbsp;8</td>
<td>&nbsp;9</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>So, if you want to retrieve the value 13.13, you must point to the value stored under index 5.</p>
<p>Por lo tanto, si desea recuperar el valor 13.13, debe apuntar al valor almacenado en el &iacute;ndice 5.</p>
<p>The use of function tables is manifold. A function table can contain pitch values to which you may refer using the input of a MIDI keyboard. A function table can contain a model of a waveform which is read periodically by an oscillator. You can record live audio input in a function table, and then play it back. There are many more applications, all using the fast access (because function tables are stored in RAM) and flexible use of function tables.</p>
<p>El uso de tablas de funciones es m&uacute;ltiple. Una tabla de funciones puede contener valores de tono a los que puede referirse utilizando la entrada de un teclado MIDI. Una tabla de funciones puede contener un modelo de una forma de onda que es le&iacute;da peri&oacute;dicamente por un oscilador. Puede grabar la entrada de audio en vivo en una tabla de funciones y, a continuaci&oacute;n, reproducirla. Hay muchas m&aacute;s aplicaciones, todas usando el acceso r&aacute;pido (porque las tablas de funciones se almacenan en la RAM) y el uso flexible de las tablas de funciones.</p>
<h2>How to Generate a Function Table</h2>
<p>Each function table must be created before it can be used. Even if you want to write values later, you must first create an empty table, because you must initially reserve some space in memory for it.</p>
<p>Cada tabla de funciones se debe crear antes de que se pueda utilizar. Incluso si desea escribir valores m&aacute;s adelante, primero debe crear una tabla vac&iacute;a, ya que inicialmente debe reservar algo de espacio en la memoria para ello.</p>
<p>Each creation of a function table in Csound is performed by one of the GEN Routines. Each GEN Routine generates a function table in a particular way: GEN01 transfers audio samples from a soundfile into a table, GEN02 stores values we define explicitly one by one, GEN10 calculates a waveform using user-defined weightings of harmonically related sinusoids, GEN20 generates window functions typically used for granular synthesis, and so on. There is a good overview in the Csound Manual of all existing GEN Routines. Here we will explain their general use and provide some simple examples using commonly used GEN routines.</p>
<p>Cada creaci&oacute;n de una tabla de funciones en Csound la realiza una de las rutinas GEN. Cada GEN Routine genera una tabla de funciones de una manera particular: GEN01 transfiere muestras de audio de un archivo de sonido a una tabla, GEN02 almacena valores que definimos expl&iacute;citamente uno por uno, GEN10 calcula una forma de onda usando ponderaciones definidas por el usuario de sinusoides relacionados arm&oacute;nicamente GEN20 genera ventana Funciones normalmente utilizadas para la s&iacute;ntesis granular, y as&iacute; sucesivamente. Hay una buena visi&oacute;n general en el manual Csound de todas las rutinas GEN existentes. Aqu&iacute; explicaremos su uso general y proporcionaremos algunos ejemplos sencillos usando rutinas GEN usadas com&uacute;nmente.</p>
<h3>GEN02 and General Parameters for GEN Routines</h3>
<p>Let's start with our example described above and write the 10 numbers into a function table with 10 storage locations. For this task use of a GEN02 function table is required. A short description of GEN02 from the manual reads as follows:</p>
<p>Empecemos con nuestro ejemplo descrito anteriormente y escribimos los 10 n&uacute;meros en una tabla de funciones con 10 ubicaciones de almacenamiento. Para esta tarea se requiere el uso de una tabla de funciones GEN02. Una breve descripci&oacute;n de GEN02 del manual se lee de la siguiente manera:</p>
<pre>f # time size 2 v1 v2 v3 ...
</pre>
<p>This is the traditional way of creating a function table by use of an "f statement" or an "f score event" (in a manner similar to the use of "i score events" to call instrument instances). The input parameters after the "f" are as follows:</p>
<p>Esta es la forma tradicional de crear una tabla de funciones mediante el uso de una instrucci&oacute;n f o un evento de puntuaci&oacute;n f (de manera similar al uso de eventos de puntuaci&oacute;n i para llamar instancias de instrumento). Los par&aacute;metros de entrada despu&eacute;s de f son los siguientes:</p>
<ul>
<li><strong></strong>#: a number (as positive integer) for this function table; </li>
<li>#: Un n&uacute;mero (como entero positivo) para esta tabla de funciones; </li>
<li>time: at what time, in relation to the passage of the score, the function table is created (usually 0: from the beginning);</li>
<li>Tiempo: en qu&eacute; momento, en relaci&oacute;n con el paso de la partitura, se crea la tabla de funciones (usualmente 0: desde el principio); size: the size of the function table. A little care is required: in the early days of Csound only power-of-two sizes were possible for function tables (2, 4, 8, 16, ...); nowadays almost all GEN Routines accepts other sizes, but these non-power-of-two sizes must be declared as negative numbers!</li>
<li>Size: el tama&ntilde;o de la tabla de funciones. Un poco de cuidado es necesario: en los primeros d&iacute;as de Csound s&oacute;lo poder de dos tama&ntilde;os fueron posibles para las tablas de funci&oacute;n (2, 4, 8, 16, ...); Hoy en d&iacute;a casi todas las rutinas GEN aceptan otros tama&ntilde;os, pero estos tama&ntilde;os sin poder de dos deben ser declarados como n&uacute;meros negativos. 2: the number of the GEN Routine which is used to generate the table, and here is another important point which must be borne in mind: by default, Csound normalizes the table values. This means that the maximum is scaled to +1 if positive, and to -1 if negative. All other values in the table are then scaled by the same factor that was required to scale the maximum to +1 or -1. To prevent Csound from normalizing, a negative number can be given as GEN number (in this example, the GEN routine number will be given as -2 instead of 2).</li>
<li>2: el n&uacute;mero de la rutina GEN que se utiliza para generar la tabla, y aqu&iacute; es otro punto importante que debe tenerse en cuenta: por defecto, Csound normaliza los valores de la tabla. Esto significa que el m&aacute;ximo es escalado a 1 si es positivo, ya -1 si es negativo. Todos los dem&aacute;s valores de la tabla se escalan a continuaci&oacute;n por el mismo factor que se requiri&oacute; para escalar el m&aacute;ximo a 1 o -1. Para evitar que Csound se normalice, se puede dar un n&uacute;mero negativo como n&uacute;mero GEN (en este ejemplo, el n&uacute;mero de rutina GEN se dar&aacute; como -2 en lugar de 2).</li>
<li><strong></strong>v1 v2 v3 ...: the values which are written into the function table. </li>
<li>V1 v2 v3 ...: los valores que se escriben en la tabla de funciones.</li>
</ul>
<p>The example below demonstrates how the values [1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89] can be stored in a function table using an f-statement in the score. Two versions are created: an unnormalised version (table number 1) and an normalised version (table number 2). The difference in their contents will be demonstrated.</p>
<p>El ejemplo siguiente demuestra c&oacute;mo los valores [1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89] se pueden almacenar en una tabla de funciones utilizando una sentencia f en la partitura. Se crean dos versiones: una versi&oacute;n anormal (tabla n&uacute;mero 1) y una versi&oacute;n normalizada (tabla n&uacute;mero 2). Se demostrar&aacute; la diferencia en su contenido.</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D01_Table_norm_notNorm.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
  instr 1 ;prints the values of table 1 or 2
          prints    "%nFunction Table %d:%n", p4
indx      init      0
loop:
ival      table     indx, p4
          prints    "Index %d = %f%n", indx, ival
          loop_lt   indx, 1, 10, loop
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 -10 -2 1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89; not normalized
f 2 0 -10 2 1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89; normalized
i 1 0 0 1; prints function table 1
i 1 0 0 2; prints function table 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>Instrument 1 simply reads and prints (to the terminal) the values of the table. Notice the difference in values read, whether the table is normalized (positive GEN number) or not normalized (negative GEN number).</p>
<p>El instrumento 1 simplemente lee e imprime (al terminal) los valores de la tabla. Observe la diferencia en los valores le&iacute;dos, si la tabla est&aacute; normalizada (n&uacute;mero GEN positivo) o no normalizada (n&uacute;mero GEN negativo).</p>
<p>Using the ftgen opcode is a more modern way of creating a function table, which is generally preferable to the old way of writing an f-statement in the score.1 The syntax is explained below:</p>
<p>El uso del c&oacute;digo de operaci&oacute;n de ftgen es una forma m&aacute;s moderna de crear una tabla de funciones, que generalmente es preferible a la antigua forma de escribir una declaraci&oacute;n f en la partitura.1 La sintaxis se explica a continuaci&oacute;n:</p>
<p>giVar ftgen ifn, itime, isize, igen, iarg1 [, iarg2 [, ...]]</p>
<ul>
<li><strong></strong>giVar: a variable name. Each function is stored in an i-variable. Usually you want to have access to it from every instrument, so a gi-variable (global initialization variable) is given. </li>
<li>GiVar: un nombre de variable. Cada funci&oacute;n se almacena en una variable i. Por lo general, desea tener acceso a ella desde cada instrumento, por lo que una gi-variable (variable de inicializaci&oacute;n global) se da.</li>
<li><strong>i</strong>fn: a number for the function table. If you type in 0, you give Csound the job to choose a number, which is mostly preferable.</li>
<li>ifn: un n&uacute;mero para la tabla de funciones. Si escribe 0, le da a Csound el trabajo para elegir un n&uacute;mero, lo cual es preferible.</li>
</ul>
<p>The other parameters (size, GEN number, individual arguments) are the same as in the f-statement in the score. As this GEN call is now a part of the orchestra, each argument is separated from the next by a comma (not by a space or tab like in the score).</p>
<p>Los otros par&aacute;metros (tama&ntilde;o, n&uacute;mero GEN, argumentos individuales) son los mismos que en la declaraci&oacute;n f de la partitura. Como esta llamada GEN es ahora una parte de la orquesta, cada argumento est&aacute; separado de la siguiente por una coma (no por un espacio o tabulaci&oacute;n como en la partitura).</p>
<p>So this is the same example as above, but now with the function tables being generated in the orchestra header:</p>
<p>As&iacute; que este es el mismo ejemplo que el anterior, pero ahora con las tablas de funciones que se generan en el encabezado de la orquesta:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D02_Table_ftgen.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giFt1 ftgen 1, 0, -10, -2, 1.1, 2.2, 3.3, 5.5, 8.8, 13.13, 21.21, 34.34, 55.55, 89.89
giFt2 ftgen 2, 0, -10, 2, 1.1, 2.2, 3.3, 5.5, 8.8, 13.13, 21.21, 34.34, 55.55, 89.89

  instr 1; prints the values of table 1 or 2
          prints    "%nFunction Table %d:%n", p4
indx      init      0
loop:
ival      table     indx, p4
          prints    "Index %d = %f%n", indx, ival
          loop_lt   indx, 1, 10, loop
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0 1; prints function table 1
i 1 0 0 2; prints function table 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>GEN01: Importing a Soundfile</h3>
<p>GEN01 is used for importing soundfiles stored on disk into the computer's RAM, ready for for use by a number of Csound's opcodes in the orchestra. A typical ftgen statement for this import might be the following:</p>
<p>GEN01 se utiliza para importar archivos de sonido almacenados en el disco en la RAM de los ordenadores, listos para ser utilizados por varios opcodes Csounds en la orquesta. Una sentencia t&iacute;pica de ftgen para esta importaci&oacute;n podr&iacute;a ser la siguiente:</p>
<p>varname ifn itime isize igen Sfilnam iskip iformat ichn</p>
<pre>giFile    ftgen     0,  0,    0,    1,   "myfile.wav", 0,    0,      0
</pre>
<ul>
<li>varname, ifn, itime: These arguments have the same meaning as explained above in reference to GEN02. Note that on this occasion the function table number (ifn) has been defined using a zero. This means that Csound will automatically assign a unique function table number. This number will also be held by the variable giFile which we will normally use to reference the function table anyway so its actual value will not be important to us. If you are interested you can print the value of giFile (ifn) out. If no other tables are defined, it will be 101 and subsequent tables, also using automatically assigned table numbers, will follow accordingly: 102, 103 etc.</li>
</ul>
<p>Varname, ifn, itime: Estos argumentos tienen el mismo significado que se ha explicado anteriormente con referencia a GEN02. Tenga en cuenta que en esta ocasi&oacute;n el n&uacute;mero de la tabla de funciones (ifn) se ha definido utilizando un cero. Esto significa que Csound asignar&aacute; autom&aacute;ticamente un n&uacute;mero de tabla de funciones &uacute;nico. Este n&uacute;mero tambi&eacute;n se llevar&aacute; a cabo por la variable giFile que utilizaremos normalmente para hacer referencia a la tabla de funciones de todos modos por lo que su valor real no ser&aacute; importante para nosotros. Si est&aacute; interesado, puede imprimir el valor de giFile (ifn). Si no se definen otras tablas, ser&aacute; 101 y las tablas subsiguientes, tambi&eacute;n usando n&uacute;meros de tabla autom&aacute;ticamente asignados, seguir&aacute;n en consecuencia: 102, 103, etc.</p>
<p>&nbsp;</p>
<ul>
<li>isize: Usually you won't know the length of your soundfile in samples, and want to have a table length which includes exactly all the samples. This is done by setting isize=0. (Note that some opcodes may need a power-of-two table. In this case you can not use this option, but must calculate the next larger power-of-two value as size for the function table.)</li>
<li>Isize: Normalmente no sabr&aacute;s la longitud de tu archivo de sonido en muestras, y quieres tener una longitud de tabla que incluya exactamente todas las muestras. Esto se hace estableciendo isize = 0. (Tenga en cuenta que algunos opcodes pueden necesitar una tabla power-of-two.En este caso, no puede utilizar esta opci&oacute;n, sino que debe calcular el siguiente valor m&aacute;s grande de power-of-two como tama&ntilde;o para la tabla de funciones.)</li>
<li></li>
<li>igen: As explained in the previous subchapter, this is always the place for indicating the number of the GEN Routine which must be used. As always, a positive number means normalizing, which is often convenient for audio samples.</li>
<li>Igen: Como se explica en el subcap&iacute;tulo anterior, este es siempre el lugar para indicar el n&uacute;mero de la rutina GEN que se debe utilizar. Como siempre, un n&uacute;mero positivo significa la normalizaci&oacute;n, que es a menudo conveniente para las muestras de audio.</li>
<li></li>
<li>Sfilnam: The name of the soundfile in double quotes. Similar to other audio programming languages, Csound recognizes just the name if your .csd and the soundfile are in the same folder. Otherwise, give the full path. (You can also include the folder via the "SSDIR" variable, or add the folder via the "--env:NAME+=VALUE" option.) </li>
<li>Sfilnam: El nombre del archivo de sonido entre comillas dobles. Similar a otros lenguajes de programaci&oacute;n de audio, Csound reconoce s&oacute;lo el nombre si su .csd y el archivo de sonido est&aacute;n en la misma carpeta. De lo contrario, d&eacute; el camino completo. (Tambi&eacute;n puede incluir la carpeta a trav&eacute;s de la variable SSDIR o agregar la carpeta a trav&eacute;s de la opci&oacute;n --env: NAME = VALUE).</li>
<li></li>
<li>iskip: The time in seconds you want to skip at the beginning of the soundfile. 0 means reading from the beginning of the file.</li>
<li>Iskip: El tiempo en segundos que desea omitir al principio del archivo de sonido. 0 significa lectura desde el principio del archivo.</li>
<li></li>
<li><span class="term"><strong>iformat: The format of the amplitude samples in the soundfile, e.g. 16 bit, 24 bit etc. Usually providing 0 here is sufficient, in which case Csound will read the sample format form the soundfile header. </strong></span></li>
<li><br />Iformat: El formato de las muestras de amplitud en el archivo de sonido, p. 16 bits, 24 bits, etc. Por lo general, proporcionar 0 aqu&iacute; es suficiente, en cuyo caso Csound leer&aacute; el formato de muestra del encabezado de archivo de sonido.</li>
<li></li>
<li>ichn: 1 = read the first channel of the soundfile into the table, 2 = read the second channel, etc. 0 means that all channels are read. Note that only certain opcodes are able to properly make use of multichannel audio stored in function tables.</li>
<li>Ichn: 1 = leer el primer canal del archivo de sonido en la tabla, 2 = leer el segundo canal, etc. 0 significa que todos los canales se leen. Tenga en cuenta que s&oacute;lo algunos opcodes pueden utilizar correctamente el audio multicanal almacenado en las tablas de funciones.</li>
<li></li>
</ul>
<p>The following example loads a short sample into RAM via a function table and then plays it. You can download the sample here (or replace it with one of your own). Copy the text below, save it to the same location as the "fox.wav" soundfile (or add the folder via the "--env:NAME+=VALUE" option),2 and it should work. Reading the function table here is done using the poscil3 opcode which can deal with non-power-of-two tables.</p>
<p>El ejemplo siguiente carga una muestra corta en la RAM a trav&eacute;s de una tabla de funciones y luego la reproduce. Puede descargar el ejemplo aqu&iacute; (o reemplazarlo por uno propio). Copie el texto a continuaci&oacute;n, gu&aacute;rdelo en la misma ubicaci&oacute;n que el archivo de sonido fox.wav (o agregue la carpeta a trav&eacute;s de la opci&oacute;n --env: NAME = VALUE), 2 y deber&iacute;a funcionar. La lectura de la tabla de funciones se realiza utilizando el opcode poscil3 que puede ocuparse de tablas que no sean de potencia de dos.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D03_Sample_to_table.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSample  ftgen     0, 0, 0, 1, "fox.wav", 0, 0, 1

  instr 1
itablen   =         ftlen(giSample) ;length of the table
idur      =         itablen / sr ;duration
aSamp     poscil3   .5, 1/idur, giSample
          outs      aSamp, aSamp
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2.757
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>GEN10: Creating a Waveform</h3>
<p>The third example for generating a function table covers a classic case: building a function table which stores one cycle of a waveform. This waveform will then be read by an oscillator to produce a sound.</p>
<p>El tercer ejemplo para generar una tabla de funciones cubre un caso cl&aacute;sico: construir una tabla de funciones que almacena un ciclo de una forma de onda. Esta forma de onda ser&aacute; entonces le&iacute;da por un oscilador para producir un sonido.</p>
<p>&nbsp;</p>
<p>There are many GEN Routines which can be used to achieve this. The simplest one is GEN10. It produces a waveform by adding sine waves which have the "harmonic" frequency relationship 1 : 2 : 3 : 4 ... After the usual arguments for function table number, start, size and gen routine number, which are the first four arguments in ftgen for all GEN Routines, with GEN10 you must specify the relative strengths of the harmonics. So, if you just provide one argument, you will end up with a sine wave (1st harmonic). The next argument is the strength of the 2nd harmonic, then the 3rd, and so on. In this way, you can build approximations of the standard harmonic waveforms by the addition of sinusoids. This is done in the next example by instruments 1-5. Instrument 6 uses the sine wavetable twice: for generating both the sound and the envelope.</p>
<p>Hay muchas rutinas GEN que se pueden utilizar para lograr esto. El m&aacute;s simple es GEN10. Produce una forma de onda mediante la adici&oacute;n de ondas sinusoidales que tienen la relaci&oacute;n de frecuencia arm&oacute;nica 1: 2: 3: 4 ... Despu&eacute;s de los argumentos usuales para el n&uacute;mero de tabla de funciones, el inicio, el tama&ntilde;o y el n&uacute;mero de rutina gen, que son los primeros cuatro argumentos en ftgen para Todas las rutinas GEN, con GEN10 debe especificar las fuerzas relativas de los arm&oacute;nicos. Por lo tanto, si usted acaba de proporcionar un argumento, usted terminar&aacute; con una onda senoidal (1 &ordf; arm&oacute;nica). El siguiente argumento es la fuerza del 2do arm&oacute;nico, entonces el 3ro, y as&iacute; sucesivamente. De esta manera, puede construir aproximaciones de las formas de onda arm&oacute;nicas est&aacute;ndar mediante la adici&oacute;n de sinusoides. Esto se hace en el siguiente ejemplo con los instrumentos 1-5. El instrumento 6 utiliza la tabla de ondas sinusoidales dos veces: para generar tanto el sonido como el envolvente.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D04_Standard_waveforms_with_GEN10.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
giSaw     ftgen     0, 0, 2^10, 10, 1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9
giSquare  ftgen     0, 0, 2^10, 10, 1, 0, 1/3, 0, 1/5, 0, 1/7, 0, 1/9
giTri     ftgen     0, 0, 2^10, 10, 1, 0, -1/9, 0, 1/25, 0, -1/49, 0, 1/81
giImp     ftgen     0, 0, 2^10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1

  instr 1 ;plays the sine wavetable
aSine     poscil    .2, 400, giSine
aEnv      linen     aSine, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 2 ;plays the saw wavetable
aSaw      poscil    .2, 400, giSaw
aEnv      linen     aSaw, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 3 ;plays the square wavetable
aSqu      poscil    .2, 400, giSquare
aEnv      linen     aSqu, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 4 ;plays the triangular wavetable
aTri      poscil    .2, 400, giTri
aEnv      linen     aTri, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 5 ;plays the impulse wavetable
aImp      poscil    .2, 400, giImp
aEnv      linen     aImp, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 6 ;plays a sine and uses the first half of its shape as envelope
aEnv      poscil    .2, 1/6, giSine
aSine     poscil    aEnv, 400, giSine
          outs      aSine, aSine
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 2 4 3
i 3 8 3
i 4 12 3
i 5 16 3
i 6 20 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>How to Write Values to a Function Table</h2>
<p>As we have seen, GEN Routines generate function tables, and by doing this, they write values into them according to various methods, but in certain cases you might first want to create an empty table, and then write the values into it later or you might want to alter the default values held in a function table. The following section demonstrates how to do this.</p>
<p>Como hemos visto, las rutinas GEN generan tablas de funciones y, al hacerlo, escriben valores en ellas de acuerdo con varios m&eacute;todos, pero en ciertos casos, puede que primero desee crear una tabla vac&iacute;a y luego escribir los valores en ella m&aacute;s tarde o bien Puede querer alterar los valores predeterminados mantenidos en una tabla de funciones. La siguiente secci&oacute;n muestra c&oacute;mo hacerlo.</p>
<p>&nbsp;</p>
<p>To be precise, it is not actually correct to talk about an "empty table". If Csound creates an "empty" table, in fact it writes zeros to the indices which are not specified. Perhaps the easiest method of creating an "empty" table for 100 values is shown below:</p>
<p>Para ser exactos, no es correcto hablar de una mesa vac&iacute;a. Si Csound crea una tabla vac&iacute;a, de hecho escribe zeros en los &iacute;ndices que no se especifican. Tal vez el m&eacute;todo m&aacute;s f&aacute;cil de crear una tabla vac&iacute;a para 100 valores se muestra a continuaci&oacute;n:</p>
<p>&nbsp;</p>
<pre>giEmpty   ftgen     0, 0, -100, 2, 0
</pre>
<p>The simplest to use opcode that writes values to existing function tables during a note's performance is tablew and its i-time equivalent is tableiw. Note that you may have problems with some features if your table is not a power-of-two size. In this case, you can also use tabw / tabw_i, but they don't have the offset- and the wraparound-feature. As usual, you must differentiate if your signal (variable) is i-rate, k-rate or a-rate. The usage is simple and differs just in the class of values you want to write to the table (i-, k- or a-variables):</p>
<p>El m&aacute;s sencillo de usar opcode que escribe valores a tablas de funciones existentes durante un rendimiento de notas es tablew y su equivalente en tiempo-i es tableiw. Tenga en cuenta que puede tener problemas con algunas caracter&iacute;sticas si su tabla no es un tama&ntilde;o de dos. En este caso, tambi&eacute;n puede usar tabw / tabw_i, pero no tienen el offset y el wraparound. Como de costumbre, debe diferenciar si su se&ntilde;al (variable) es i-rate, k-rate o a-rate. El uso es simple y difiere s&oacute;lo en la clase de valores que desea escribir en la tabla (i-, k- o a-variables):</p>
<p>&nbsp;</p>
<pre>          tableiw   isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]
          tablew    ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]
&nbsp;         tablew    asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]
</pre>
<ul>
<li>isig, ksig, asig is the value (variable) you want to write into a specified location of the table;</li>
<li>Isig, ksig, asig es el valor (variable) que desea escribir en una ubicaci&oacute;n especificada de la tabla;</li>
<li></li>
<li>indx, kndx, andx is the location (index) where you will write the value;</li>
<li>Indx, kndx, andx es la ubicaci&oacute;n (&iacute;ndice) donde se escribir&aacute; el valor;</li>
<li></li>
<li>ifn is the function table you want to write to;</li>
<li>Ifn es la tabla de funciones a la que desea escribir;</li>
<li></li>
<li>ixmode gives the choice to write by raw indices (counting from 0 to size-1), or by a normalized writing mode in which the start and end of each table are always referred as 0 and 1 (not depending on the length of the table). The default is ixmode=0 which means the raw index mode. A value not equal to zero for ixmode changes to the normalized index mode.</li>
<li>Ixmode da la opci&oacute;n de escribir por &iacute;ndices sin procesar (contando de 0 a tama&ntilde;o-1), o por un modo de escritura normalizado en el que el inicio y el final de cada tabla se denominan siempre 0 y 1 (no dependiendo de la longitud de la tabla ). El valor predeterminado es ixmode = 0, que significa el modo de &iacute;ndice sin procesar. Un valor no igual a cero para ixmode cambia al modo de &iacute;ndice normalizado.</li>
</ul>
<p>ixoff (default=0) gives an index offset. So, if indx=0 and ixoff=5, you will write at index 5</p>
<p>Ixoff (default = 0) da una compensaci&oacute;n de &iacute;ndice. Por lo tanto, si indx = 0 y ixoff = 5, escribir&aacute; en el &iacute;ndice 5</p>
<p>&nbsp;</p>
<ul>
<li>.</li>
<li>iwgmode tells what you want to do if your index is larger than the size of the table. If iwgmode=0 (default), any index larger than possible is written at the last possible index. If iwgmode=1, the indices are wrapped around. For instance, if your table size is 8, and your index is 10, in the wraparound mode the value will be written at index 2.</li>
<li>Iwgmode indica lo que quieres hacer si tu &iacute;ndice es mayor que el tama&ntilde;o de la tabla. Si iwgmode = 0 (valor predeterminado), cualquier &iacute;ndice mayor que el posible se escribe en el &uacute;ltimo &iacute;ndice posible. Si iwgmode = 1, los &iacute;ndices se envuelven alrededor. Por ejemplo, si su tama&ntilde;o de tabla es 8 y su &iacute;ndice es 10, en el modo envolvente el valor se escribir&aacute; en el &iacute;ndice 2.</li>
<li></li>
</ul>
<p>Here are some examples for i-, k- and a-rate values.</p>
<p>Aqu&iacute; hay algunos ejemplos de valores de i, k y a.</p>
<p>&nbsp;</p>
<h3>i-Rate Example</h3>
<p>The following example calculates the first 12 values of a Fibonacci series and writes them to a table. An empty table has first been created in the header (filled with zeros), then instrument 1 calculates the values in an i-time loop and writes them to the table using tableiw. Instrument 2 simply prints all the values in a list to the terminal.</p>
<p>El ejemplo siguiente calcula los primeros 12 valores de una serie de Fibonacci y los escribe en una tabla. En primer lugar se ha creado una tabla vac&iacute;a en el encabezado (llenado con ceros), entonces el instrumento 1 calcula los valores en un bucle i-time y los escribe en la tabla usando tableiw. El instrumento 2 simplemente imprime todos los valores de una lista al terminal.</p>
<p>&nbsp;</p>
<p id="alexbreak">&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D05_Write_Fibo_to_table.csd</strong></em>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giFt      ftgen     0, 0, -12, -2, 0

  instr 1; calculates first 12 fibonacci values and writes them to giFt
istart    =         1
inext     =         2
indx      =         0
loop:
          tableiw   istart, indx, giFt ;writes istart to table
istartold =         istart ;keep previous value of istart
istart    =         inext ;reset istart for next loop
inext     =         istartold + inext ;reset inext for next loop
          loop_lt   indx, 1, 12, loop
  endin

  instr 2; prints the values of the table
          prints    "%nContent of Function Table:%n"
indx      init      0
loop:
ival      table     indx, giFt
          prints    "Index %d = %f%n", indx, ival
          loop_lt   indx, 1, ftlen(giFt), loop
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h3>k-Rate Example</h3>
<p>The next example writes a k-signal continuously into a table. This can be used to record any kind of user input, for instance by MIDI or widgets. It can also be used to record random movements of k-signals, like here:</p>
<p>El siguiente ejemplo escribe una se&ntilde;al k continuamente en una tabla. Esto se puede utilizar para grabar cualquier tipo de entrada del usuario, por ejemplo, MIDI o widgets. Tambi&eacute;n se puede utilizar para registrar movimientos aleatorios de se&ntilde;ales k, como aqu&iacute;:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D06_Record_ksig_to_table.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giFt      ftgen     0, 0, -5*kr, 2, 0; size for 5 seconds of recording
giWave    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1; waveform for oscillator
          seed      0

; - recording of a random frequency movement for 5 seconds, and playing it
  instr 1
kFreq     randomi   400, 1000, 1 ;random frequency
aSnd      poscil    .2, kFreq, giWave ;play it
          outs      aSnd, aSnd
;;record the k-signal
          prints    "RECORDING!%n"
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     linseg    0, 5, ftlen(giFt)
 ;write the k-signal
          tablew    kFreq, kindx, giFt
  endin

  instr 2; read the values of the table and play it again
;;read the k-signal
          prints    "PLAYING!%n"
 ;create a reading pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     linseg    0, 5, ftlen(giFt)
 ;read the k-signal
kFreq     table     kindx, giFt
aSnd      oscil3    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 6 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>As you see, this typical case of writing k-values to a table requires a changing value for the index, otherwise tablew will continually overwrite at the same table location. This changing value can be created using the line or linseg opcodes - as was done here - or by using a phasor. A phasor moves continuously from 0 to 1 at a user-defined frequency. For example, if you want a phasor to move from 0 to 1 in 5 seconds, you must set the frequency to 1/5. Upon reaching 1, the phasor will wrap-around to zero and begin again. Note that phasor can also be given a negative frequency in which case it moves in reverse from 1 to zero then wrapping around to 1. By setting the ixmode argument of tablew to 1, you can use the phasor output directly as writing pointer. Below is an alternative version of instrument 1 from the previous example, this time using phasor to generate the index values:</p>
<p>Como se ve, este caso t&iacute;pico de escribir k-valores en una tabla requiere un cambio de valor para el &iacute;ndice, de lo contrario tablew continuamente sobrescribir&aacute; en la misma ubicaci&oacute;n de la tabla. Este valor cambiante se puede crear usando los opcodes de l&iacute;nea o linseg - como se hizo aqu&iacute; - o usando un fasor. Un fasor se mueve continuamente de 0 a 1 a una frecuencia definida por el usuario. Por ejemplo, si desea que un fasor se mueva de 0 a 1 en 5 segundos, debe establecer la frecuencia en 1/5. Al llegar a 1, el fasor se envolver&aacute; a cero y comenzar&aacute; de nuevo. Tenga en cuenta que tambi&eacute;n se puede asignar una frecuencia negativa al fasor, en cuyo caso se mueve en sentido inverso de 1 a cero y luego se envuelve en 1. Al establecer el argumento ixmode de tablew en 1, puede utilizar la salida del fasor directamente como puntero de escritura. A continuaci&oacute;n se muestra una versi&oacute;n alternativa del instrumento 1 del ejemplo anterior, esta vez usando fasor para generar los valores de &iacute;ndice:</p>
<p>&nbsp;</p>
<pre>instr 1; recording of a random frequency movement for 5 seconds, and playing it
kFreq     randomi   400, 1000, 1; random frequency
aSnd      oscil3    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
;;record the k-signal with a phasor as index
          prints    "RECORDING!%n"
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     phasor    1/5
 ;write the k-signal
          tablew    kFreq, kindx, giFt, 1
endin
</pre>
<h3>a-Rate Example</h3>
<p>Recording an audio signal is quite similar to recording a control signal. You just need an a-signal to provide input values and also an index that changes at a-rate. The next example first records a randomly generated audio signal and then plays it back. It then records the live audio input for 5 seconds and subsequently plays it back.</p>
<p>La grabaci&oacute;n de una se&ntilde;al de audio es bastante similar a la grabaci&oacute;n de una se&ntilde;al de control. S&oacute;lo necesita una se&ntilde;al-a para proporcionar valores de entrada y tambi&eacute;n un &iacute;ndice que cambia a una velocidad. El siguiente ejemplo registra primero una se&ntilde;al de audio generada aleatoriamente y luego la reproduce. A continuaci&oacute;n, graba la entrada de audio en directo durante 5 segundos y posteriormente la reproduce.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D07_Record_audio_to_table.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giFt      ftgen     0, 0, -5*sr, 2, 0; size for 5 seconds of recording audio
          seed      0

  instr 1 ;generating a band filtered noise for 5 seconds, and recording it
aNois     rand      .2
kCfreq    randomi   200, 2000, 3; random center frequency
aFilt     butbp     aNois, kCfreq, kCfreq/10; filtered noise
aBal      balance   aFilt, aNois, 1; balance amplitude
          outs      aBal, aBal
;;record the audiosignal with a phasor as index
          prints    "RECORDING FILTERED NOISE!%n"
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    aBal, aindx, giFt, 1
  endin

  instr 2 ;read the values of the table and play it
          prints    "PLAYING FILTERED NOISE!%n"
aindx     phasor    1/5
aSnd      table3    aindx, giFt, 1
          outs      aSnd, aSnd
  endin

  instr 3 ;record live input
ktim      timeinsts ; playing time of the instrument in seconds
          prints    "PLEASE GIVE YOUR LIVE INPUT AFTER THE BEEP!%n"
kBeepEnv  linseg    0, 1, 0, .01, 1, .5, 1, .01, 0
aBeep     oscils    .2, 600, 0
          outs      aBeep*kBeepEnv, aBeep*kBeepEnv
;;record the audiosignal after 2 seconds
 if ktim &gt; 2 then
ain       inch      1
          printks   "RECORDING LIVE INPUT!%n", 10
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    ain, aindx, giFt, 1
 endif
  endin

  instr 4 ;read the values from the table and play it
          prints    "PLAYING LIVE INPUT!%n"
aindx     phasor    1/5
aSnd      table3    aindx, giFt, 1
          outs      aSnd, aSnd
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5  ; record 5 seconds of generated audio to a table
i 2 6 5  ; play back the recording of generated audio
i 3 12 7 ; record 5 seconds of live audio to a table
i 4 20 5 ; play back the recording of live audio
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>How to Retrieve Values from a Function Table</h2>
<p>There are two methods of reading table values. You can either use the table / tab opcodes, which are universally usable, but need an index; or you can use an oscillator for reading a table at k-rate or a-rate.</p>
<p>Hay dos m&eacute;todos de lectura de valores de tabla. Puede utilizar los opcodes table / tab, que son universalmente utilizables, pero necesitan un &iacute;ndice; O puede utilizar un oscilador para leer una tabla en k-rate o a-rate.</p>
<p>&nbsp;</p>
<h3>The table Opcode</h3>
<p>The table opcode is quite similar in syntax to the tableiw/tablew opcodes (which are explained above). It is simply its counterpart for reading values from a function table instead of writing them. Its output can be either an i-, k- or a-rate signal and the value type of the output automatically selects either the a- k- or a-rate version of the opcode. The first input is an index at the appropriate rate (i-index for i-output, k-index for k-output, a-index for a-output). The other arguments are as explained above for tableiw/tablew:</p>
<p>El opcode de tabla es bastante similar en sintaxis a los opcodes tableiw / tablew (que se explican anteriormente). Es simplemente su contraparte para leer valores de una tabla de funciones en lugar de escribirlas. Su salida puede ser una se&ntilde;al i-, k- o a-rate y el tipo de valor de la salida selecciona autom&aacute;ticamente la versi&oacute;n ak o a-rate del c&oacute;digo de operaci&oacute;n. La primera entrada es un &iacute;ndice a la velocidad apropiada (i-index para i-output, k-index para k-output, a-index para a-output). Los otros argumentos son como se explic&oacute; anteriormente para tableiw / tablew:</p>
<p>ires table indx, ifn [, ixmode] [, ixoff] [, iwrap]</p>
<pre>kres      table    kndx, ifn [, ixmode] [, ixoff] [, iwrap]
ares      table    andx, ifn [, ixmode] [, ixoff] [, iwrap]
</pre>
<p>As table reading often requires interpolation between the table values - for instance if you read k- or a-values faster or slower than they have been written in the table - Csound offers two descendants of table for interpolation: tablei interpolates linearly, whilst table3 performs cubic interpolation (which is generally preferable but is computationally slightly more expensive) and when CPU cycles are no object, tablexkt can be used for ultimate interpolating quality.3</p>
<p>Como la lectura de la tabla requiere a menudo la interpolaci&oacute;n entre los valores de la tabla - por ejemplo si usted lee los valores de k o de a m&aacute;s r&aacute;pidamente o m&aacute;s lentamente que se han escrito en la tabla - Csound ofrece dos descendientes de la tabla para la interpolaci&oacute;n: tablei interpola linear, mientras que table3 realiza Interpolaci&oacute;n c&uacute;bica (que generalmente es preferible pero computacionalmente un poco m&aacute;s cara) y cuando los ciclos de la CPU no son un objeto, tablexkt puede usarse para la m&aacute;xima calidad de interpolaci&oacute;n.</p>
<p>&nbsp;</p>
<p>Another variant is the tab_i / tab opcode which misses some features but may be preferable in some situations. If you have any problems in reading non-power-of-two tables, give them a try. They should also be faster than the table (and variants thereof) opcode, but you must take care: they include fewer built-in protection measures than table, tablei and table3 and if they are given index values that exceed the table size Csound will stop and report a performance error. Examples of the use of the table opcodes can be found in the earlier examples in the How-To-Write-Values... section.</p>
<p>Otra variante es el opcode tab_i / tab que falla algunas caracter&iacute;sticas pero puede ser preferible en algunas situaciones. Si tiene alg&uacute;n problema en la lectura de tablas de no poder de dos, int&eacute;ntelo. Tambi&eacute;n deben ser m&aacute;s r&aacute;pidos que el c&oacute;digo de operaciones de la tabla (y sus variantes), pero hay que tener cuidado: incluyen menos medidas de protecci&oacute;n incorporadas que table, tablei y table3 y si se dan valores de &iacute;ndice que exceden el tama&ntilde;o de la tabla Csound se detendr&aacute; Y reportar un error de rendimiento. Ejemplos del uso de los opcodes de tabla se pueden encontrar en los ejemplos anteriores en la secci&oacute;n How-To-Write-Values ....</p>
<p>&nbsp;</p>
<h3>Oscillators</h3>
<p>It is normal to read tables that contain a single cycle of an audio waveform using an oscillator but you can actually read any table using an oscillator, either at a- or at k-rate. The advantage is that you needn't create an index signal. You can simply specify the frequency of the oscillator (the opcode creates the required index internally based on the asked for frequency).</p>
<p>Es normal leer tablas que contienen un solo ciclo de una forma de onda de audio usando un oscilador, pero en realidad se puede leer cualquier tabla usando un oscilador, ya sea a-o en k-rate. La ventaja es que no necesita crear una se&ntilde;al de &iacute;ndice. Simplemente puede especificar la frecuencia del oscilador (el c&oacute;digo de operaci&oacute;n crea el &iacute;ndice requerido internamente basado en la frecuencia solicitada).</p>
<p>You should bear in mind that many of the oscillators in Csound will work only with power-of-two table sizes. The poscil/poscil3 opcodes do not have this restriction and offer a high precision, because they work with floating point indices, so in general it is recommended to use them. Below is an example that demonstrates both reading a k-rate and an a-rate signal from a buffer with poscil3 (an oscillator with a cubic interpolation):</p>
<p>Debe tener en cuenta que muchos de los osciladores en Csound funcionar&aacute; s&oacute;lo con tama&ntilde;os de mesa de dos tama&ntilde;os. Los opcodes poscil / poscil3 no tienen esta restricci&oacute;n y ofrecen una alta precisi&oacute;n, ya que trabajan con &iacute;ndices de coma flotante, por lo que en general se recomienda su uso. A continuaci&oacute;n se muestra un ejemplo que demuestra tanto la lectura de una k-velocidad y una se&ntilde;al a-tasa de un buffer con poscil3 (un oscilador con una interpolaci&oacute;n c&uacute;bica):</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D08_RecPlay_ak_signals.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
; -- size for 5 seconds of recording control data
giControl ftgen     0, 0, -5*kr, 2, 0
; -- size for 5 seconds of recording audio data
giAudio   ftgen     0, 0, -5*sr, 2, 0
giWave    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1; waveform for oscillator
          seed      0

; -- ;recording of a random frequency movement for 5 seconds, and playing it
  instr 1
kFreq     randomi   400, 1000, 1; random frequency
aSnd      poscil    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
;;record the k-signal with a phasor as index
          prints    "RECORDING RANDOM CONTROL SIGNAL!%n"
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     phasor    1/5
 ;write the k-signal
          tablew    kFreq, kindx, giControl, 1
  endin

  instr 2; read the values of the table and play it with poscil
          prints    "PLAYING CONTROL SIGNAL!%n"
kFreq     poscil    1, 1/5, giControl
aSnd      poscil    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
  endin

  instr 3; record live input
ktim      timeinsts ; playing time of the instrument in seconds
          prints    "PLEASE GIVE YOUR LIVE INPUT AFTER THE BEEP!%n"
kBeepEnv  linseg    0, 1, 0, .01, 1, .5, 1, .01, 0
aBeep     oscils    .2, 600, 0
          outs      aBeep*kBeepEnv, aBeep*kBeepEnv
;;record the audiosignal after 2 seconds
 if ktim &gt; 2 then
ain       inch      1
          printks   "RECORDING LIVE INPUT!%n", 10
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    ain, aindx, giAudio, 1
 endif
  endin

  instr 4; read the values from the table and play it with poscil
          prints    "PLAYING LIVE INPUT!%n"
aSnd      poscil    .5, 1/5, giAudio
          outs      aSnd, aSnd
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 6 5
i 3 12 7
i 4 20 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Saving the Contents of a Function Table to a File</h2>
<p>A function table exists only as long as you run the Csound instance which has created it. If Csound terminates, all the data is lost. If you want to save the data for later use, you must write them to a file. There are several cases, depending firstly on whether you write at i-time or at k-time and secondly on what kind of file you want to write to.</p>
<p>Una tabla de funciones s&oacute;lo existe mientras ejecute la instancia de Csound que la ha creado. Si Csound termina, todos los datos se pierden. Si desea guardar los datos para su uso posterior, debe escribirlos en un archivo. Hay varios casos, dependiendo en primer lugar de si se escribe en i-time o en k-time y en segundo lugar en qu&eacute; tipo de archivo que desea escribir.</p>
<p>&nbsp;</p>
<h3>Writing a File in Csound's ftsave Format at i-Time or k-Time</h3>
<p>Any function table in Csound can be easily written to a file using the ftsave (i-time) or ftsavek (k-time) opcode. Their use is very simple. The first argument specifies the filename (in double quotes), the second argument selects between a text format (non zero) or a binary format (zero) output. Finally you just provide the number of the function table(s) to save.</p>
<p>Cualquier tabla de funciones en Csound se puede escribir f&aacute;cilmente en un archivo usando el opcode ftsave (i-time) o ftsavek (k-time). Su uso es muy simple. El primer argumento especifica el nombre de archivo (entre comillas dobles), el segundo argumento selecciona entre un formato de texto (no cero) o un formato binario (cero). Por &uacute;ltimo, s&oacute;lo proporcione el n&uacute;mero de la (s) tabla (s) de funciones a guardar.</p>
<p>&nbsp;</p>
<p><br />With the following example, you should end up with two textfiles in the same folder as your .csd: "i-time_save.txt" saves function table 1 (a sine wave) at i-time; "k-time_save.txt" saves function table 2 (a linear increment produced during the performance) at k-time.</p>
<p>Con el siguiente ejemplo, debe terminar con dos archivos de texto en la misma carpeta que su .csd: i-time_save.txt guarda la tabla de funciones 1 (una onda senoidal) en i-time; K-time_save.txt guarda la tabla de funciones 2 (un incremento lineal producido durante la ejecuci&oacute;n) en k-tiempo.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D09_ftsave.csd</strong></em></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giWave    ftgen     1, 0, 2^7, 10, 1; sine with 128 points
giControl ftgen     2, 0, -kr, 2, 0; size for 1 second of recording control data
          seed      0

  instr 1; saving giWave at i-time
          ftsave    "i-time_save.txt", 1, 1
  endin

  instr 2; recording of a line transition between 0 and 1 for one second
kline     linseg    0, 1, 1
          tabw      kline, kline, giControl, 1
  endin

  instr 3; saving giWave at k-time
          ftsave    "k-time_save.txt", 1, 2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 1
i 3 1 .1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The counterpart to ftsave/ftsavek are the ftload/ftloadk opcodes. You can use them to load the saved files into function tables.</p>
<p>La contrapartida de ftsave / ftsavek son los opcodes ftload / ftloadk. Puede utilizarlos para cargar los archivos guardados en tablas de funciones.</p>
<p>&nbsp;</p>
<h3>Writing a Soundfile from a Recorded Function Table</h3>
<p>If you have recorded your live-input to a buffer, you may want to save your buffer as a soundfile. There is no opcode in Csound which does that, but it can be done by using a k-rate loop and the fout opcode. This is shown in the next example in instrument 2. First instrument 1 records your live input. Then instrument 2 creates a soundfile "testwrite.wav" containing this audio in the same folder as your .csd. This is done at the first k-cycle of instrument 2, by repeatedly reading the table values and writing them as an audio signal to disk. After this is done, the instrument is turned off by executing the turnoff statement.</p>
<p>Si ha grabado su entrada en directo en un b&uacute;fer, puede guardar su b&uacute;fer como un archivo de sonido. No hay c&oacute;digo de operaci&oacute;n en Csound que lo haga, pero se puede hacer usando un bucle k-rate y el opcode fout. Esto se muestra en el siguiente ejemplo en el instrumento 2. El primer instrumento 1 registra su entrada en vivo. Luego el instrumento 2 crea un archivo de sonido testwrite.wav que contiene este audio en la misma carpeta que su .csd. Esto se hace en el primer ciclo k del instrumento 2, leyendo repetidamente los valores de la tabla y escribi&eacute;ndolos como una se&ntilde;al de audio en el disco. Una vez hecho esto, el instrumento se apaga ejecutando la instrucci&oacute;n de apagado.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03D10_Table_to_soundfile.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
; --  size for 5 seconds of recording audio data
giAudio   ftgen     0, 0, -5*sr, 2, 0

  instr 1 ;record live input
ktim      timeinsts ; playing time of the instrument in seconds
          prints    "PLEASE GIVE YOUR LIVE INPUT AFTER THE BEEP!%n"
kBeepEnv  linseg    0, 1, 0, .01, 1, .5, 1, .01, 0
aBeep     oscils    .2, 600, 0
          outs      aBeep*kBeepEnv, aBeep*kBeepEnv
;;record the audiosignal after 2 seconds
 if ktim &gt; 2 then
ain       inch      1
          printks   "RECORDING LIVE INPUT!%n", 10
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    ain, aindx, giAudio, 1
 endif
  endin

  instr 2; write the giAudio table to a soundfile
Soutname  =         "testwrite.wav"; name of the output file
iformat   =         14; write as 16 bit wav file
itablen   =         ftlen(giAudio); length of the table in samples

kcnt      init      0; set the counter to 0 at start
loop:
kcnt      =         kcnt+ksmps; next value (e.g. 10 if ksmps=10)
andx      interp    kcnt-1; calculate audio index (e.g. from 0 to 9)
asig      tab       andx, giAudio; read the table values as audio signal
          fout      Soutname, iformat, asig; write asig to a file
 if kcnt &lt;= itablen-ksmps kgoto loop; go back as long there is something to do
          turnoff   ; terminate the instrument
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7
i 2 7 .1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>This code can also be used in the form of a User Defined Opcode. It can be found here.</p>
<p>Este c&oacute;digo tambi&eacute;n puede utilizarse en forma de un c&oacute;digo de usuario definido por el usuario. Se puede encontrar aqu&iacute;.</p>
<p>Other GEN Routine Highlights</p>
<p>GEN05, GEN07, GEN25, GEN27 and GEN16 are useful for creating envelopes. GEN07 and GEN27 create functions table in the manner of the linseg opcode - with GEN07 the user defines segment duration whereas in GEN27 the user defines the absolute time for each breakpoint from the beginning of the envelope. GEN05 and GEN25 operate similarly to GEN07 and GEN27 except that envelope segments are exponential in shape. GEN16 also create an envelope in breakpoint fashion but it allows the user to specify the curvature of each segment individually (concave - straight - convex).</p>
<p><a href="http://www.csounds.com/manual/html/GEN17.html">GEN05, GEN07, GEN25, GEN27 y GEN16 son &uacute;tiles para crear sobres. GEN07 y GEN27 crean la tabla de funciones en la forma del opcode linseg - con GEN07 el usuario define la duraci&oacute;n del segmento mientras que en GEN27 el usuario define el tiempo absoluto para cada punto de interrupci&oacute;n desde el principio del sobre. GEN05 y GEN25 funcionan de forma similar a GEN07 y GEN27 excepto que los segmentos de envolvente son exponenciales en forma. GEN16 tambi&eacute;n crea un sobre en forma de punto de ruptura pero permite al usuario especificar la curvatura de cada segmento individualmente (c&oacute;ncavo - recto - convexo). </a></p>
<p><a href="http://www.csounds.com/manual/html/GEN17.html">GEN17, GEN41 and GEN42 are used the generate histogram-type functions which may prove useful in algorithmic composition and work with probabilities. </a></p>
<p>GEN17, GEN41 y GEN42 se utilizan las funciones generadoras de tipo histograma que pueden resultar &uacute;tiles en la composici&oacute;n algor&iacute;tmica y trabajar con probabilidades.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/GEN09.html">GEN09 and GEN19 are developments of GEN10 and are useful in additive synthesis. </a></p>
<p>GEN09 y GEN19 son desarrollos de GEN10 y son &uacute;tiles en s&iacute;ntesis aditiva.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/GEN11.html">GEN11 is a GEN routine version of the gbuzz opcode and as it is a fixed waveform (unlike gbuzz) it can be a useful and efficient sound source in subtractive synthesis. </a></p>
<p>GEN11 es una versi&oacute;n de rutina GEN del c&oacute;digo de operaci&oacute;n gbuzz y como es una forma de onda fija (a diferencia de gbuzz) puede ser una fuente de sonido &uacute;til y eficiente en s&iacute;ntesis sustractiva.</p>
<p>&nbsp;</p>
<h2>GEN08</h2>
<pre>f # time size 8 a n1 b n2 c n3 d ...</pre>
<p>GEN08 creates a curved function that forms the smoothest possible line between a sequence of user defined break-points. This GEN routine can be useful for the creation of window functions for use as envelope shapes or in granular synthesis. In forming a smooth curve, GEN08 may create apexes that extend well above or below any of the defined values. For this reason GEN08 is mostly used with post-normalisation turned on, i.e. a minus sign is not added to the GEN number when the function table is defined. Here are some examples of GEN08 tables:</p>
<p>GEN08 crea una funci&oacute;n curvada que forma la l&iacute;nea m&aacute;s lisa posible entre una secuencia de puntos de ruptura definidos por el usuario. Esta rutina GEN puede ser &uacute;til para la creaci&oacute;n de funciones de ventana para su uso como formas de envolvente o en s&iacute;ntesis granular. Al formar una curva suave, GEN08 puede crear &aacute;pices que se extienden bien por encima o por debajo de cualquiera de los valores definidos. Por esta raz&oacute;n GEN08 se utiliza principalmente con post-normalizaci&oacute;n activada, es decir, un signo menos no se a&ntilde;ade al n&uacute;mero GEN cuando se define la tabla de funciones. Estos son algunos ejemplos de tablas GEN08:</p>
<p>&nbsp;</p>
<p><img src="static/GEN08_1.png" alt="" />&nbsp;</p>
<pre>f 1 0 1024 8 0 1 1 1023 0
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN08_2.png" alt="" /></p>
<pre>f 2 0 1024 8 0 97 1 170 0.583 757 0
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN08_3.png" alt="" /></p>
<pre>f 3 0 1024 8 0 1 0.145 166 0.724 857 0
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN08_4.png" alt="" />&nbsp;</p>
<pre>f 4 0 1024 8 0 1 0.079 96 0.645 927 0</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>GEN16</h2>
<pre>f # time size 16 val1 dur1 type1 val2 [dur2 type2 val3 ... typeX valN]
</pre>
<p>GEN16 allows the creation of envelope functions using a sequence of user defined breakpoints. Additionally for each segment of the envelope we can define a curvature. The nature of the curvature &ndash; concave or convex &ndash; will also depend upon the direction of the segment: rising or falling. For example, positive curvature values will result in concave curves in rising segments and convex curves in falling segments. The opposite applies if the curvature value is negative. Below are some examples of GEN16 function tables:</p>
<p>GEN16 permite la creaci&oacute;n de funciones de envolvente utilizando una secuencia de puntos de interrupci&oacute;n definidos por el usuario. Adem&aacute;s, para cada segmento del sobre podemos definir una curvatura. La naturaleza de la curvatura - c&oacute;ncava o convexa - tambi&eacute;n depender&aacute; de la direcci&oacute;n del segmento: subiendo o bajando. Por ejemplo, los valores de curvatura positiva dar&aacute;n lugar a curvas c&oacute;ncavas en segmentos ascendentes y curvas convexas en segmentos descendentes. Lo contrario se aplica si el valor de curvatura es negativo. A continuaci&oacute;n se presentan algunos ejemplos de tablas de funciones GEN16:</p>
<p>&nbsp;</p>
<p><img src="static/GEN16_1.png" alt="" /></p>
<pre>f 1 0 1024 16 0 512 20 1 512 20 0</pre>
<p>&nbsp;</p>
<p><img src="static/GEN16_2.png" alt="" /></p>
<pre>f 2 0 1024 16 0 512 4 1 512 4 0
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN16_3.png" alt="" />&nbsp;</p>
<pre>f 3 0 1024 16 0 512 0 1 512 0 0
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN16_4.png" alt="" />&nbsp;</p>
<pre>f 4 0 1024 16 0 512 -4 1 512 -4 0
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN16_5.png" alt="" />&nbsp;</p>
<pre>f 5 0 1024 16 0 512 -20 1 512 -20 0
</pre>
<p>&nbsp;</p>
<h2>GEN19</h2>
<pre>f # time size&nbsp; 19&nbsp; pna&nbsp;&nbsp; stra&nbsp; phsa&nbsp; dcoa&nbsp; pnb strb&nbsp; phsb&nbsp; dcob&nbsp; ...
</pre>
<p>GEN19 follows on from GEN10 and GEN09 in terms of complexity and control options. It shares the basic concept of generating a harmonic waveform from stacked sinusoids but in addition to control over the strength of each partial (GEN10) and the partial number and phase (GEN09) it offers control over the DC offset of each partial. In addition to the creation of waveforms for use by audio oscillators other applications might be the creation of functions for LFOs and window functions for envelopes in granular synthesis. Below are some examples of GEN19:</p>
<p>GEN19 sigue a GEN10 y GEN09 en t&eacute;rminos de complejidad y opciones de control. Comparte el concepto b&aacute;sico de generar una forma de onda arm&oacute;nica a partir de sinusoides apilados, pero adem&aacute;s de controlar la fuerza de cada parte (GEN10) y el n&uacute;mero parcial y fase (GEN09) ofrece control sobre el offset DC de cada parcial. Adem&aacute;s de la creaci&oacute;n de formas de onda para uso de osciladores de audio, otras aplicaciones podr&iacute;an ser la creaci&oacute;n de funciones para LFOs y funciones de ventana para sobres en s&iacute;ntesis granular. A continuaci&oacute;n se presentan algunos ejemplos de GEN19:</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="static/GEN19_1.png" alt="" /></p>
<pre>f 1 0 1024 19 1 1 0 0 20 0.1 0 0</pre>
<p>&nbsp;</p>
<p><img src="static/GEN19_2.png" alt="" />&nbsp;</p>
<pre>f 2 0 1024 -19 0.5 1 180 1
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>GEN30</h2>
<pre><strong>f</strong> # time size  30  src  minh maxh [ref_sr] [interp]</pre>
<p>GEN30 uses FFT to create a band-limited version of a source waveform without band-limiting. We can create a sawtooth waveform by drawing one explicitly using GEN07 by used as an audio waveform this will create problems as it contains frequencies beyond the Nyquist frequency therefore will cause aliasing, particularly when higher notes are played. GEN30 can analyse this waveform and create a new one with a user defined lowest and highest partial. If we know what note we are going to play we can predict what the highest partial below the Nyquist frequency will be. For a given frequency, freq, the maximum number of harmonics that can be represented without aliasing can be derived using sr / (2 * freq). Here are some examples of GEN30 function tables (the first table is actually a GEN07 generated sawtooth, the second two are GEN30 band-limited versions of the first):</p>
<p>GEN30 utiliza FFT para crear una versi&oacute;n limitada de banda de una forma de onda de fuente sin l&iacute;mite de banda. Podemos crear una forma de onda de diente de sierra dibujando uno expl&iacute;citamente utilizando GEN07 por utilizado como una forma de onda de audio esto crear&aacute; problemas ya que contiene frecuencias m&aacute;s all&aacute; de la frecuencia Nyquist por lo tanto, causar&aacute; aliasing, sobre todo cuando se tocan notas m&aacute;s altas. GEN30 puede analizar esta forma de onda y crear una nueva con un parcial m&aacute;s bajo y m&aacute;s alto definido por el usuario. Si sabemos qu&eacute; nota vamos a tocar, podemos predecir cu&aacute;l ser&aacute; la parte m&aacute;s alta por debajo de la frecuencia de Nyquist. Para una frecuencia dada, freq, el n&uacute;mero m&aacute;ximo de arm&oacute;nicos que se pueden representar sin aliasing se puede derivar usando sr / (2 * freq). Aqu&iacute; hay algunos ejemplos de tablas de funciones GEN30 (la primera tabla es en realidad un GENO7 generado en dientes de sierra, el segundo dos son GEN30 bandas limitadas versiones de la primera):</p>
<p>&nbsp;</p>
<p><img src="static/GEN30_1.png" alt="" />&nbsp;</p>
<pre>&nbsp;f 1 0 1024 7 1 1024 -1</pre>
<p>&nbsp;</p>
<p>&nbsp;<img src="static/GEN30_2.png" alt="" /></p>
<pre>f 2 0 1024 30 1 1 20
</pre>
<p>&nbsp;</p>
<p><img src="static/GEN30_3.png" alt="" />&nbsp;</p>
<pre>f 3 0 1024 30 1 2 20</pre>
<h2>Related Opcodes</h2>
<p>ftgen: Creates a function table in the orchestra using any GEN Routine.</p>
<p><a href="http://www.csounds.com/manual/html/table.html">Ftgen: Crea una tabla de funciones en la orquesta usando cualquier rutina GEN. </a></p>
<p><a href="http://www.csounds.com/manual/html/table.html">table / tablei / table3: Read values from a function table at any rate, either by direct indexing (table), or by linear (tablei) or cubic (table3) interpolation. These opcodes provide many options and are safe because of boundary check, but you may have problems with non-power-of-two tables. </a></p>
<p>Table / tablei / table3: Lea los valores de una tabla de funciones en cualquier caso, ya sea por indexaci&oacute;n directa (tabla), o por interpolaci&oacute;n lineal (tablei) o c&uacute;bica (tabla3). Estos opcodes ofrecen muchas opciones y son seguros debido a la comprobaci&oacute;n de l&iacute;mites, pero es posible que tenga problemas con tablas que no sean de potencia de dos.</p>
<p>&nbsp;</p>
<p>tab_i / tab: Read values from a function table at i-rate (tab_i), k-rate or a-rate (tab). Offer no interpolation and less options than the table opcodes, but they work also for non-power-of-two tables. They do not provide a boundary check, which makes them fast but also give the user the resposability not reading any value off the table boundaries.</p>
<p>tableiw / tablew: Write values to a function table at i-rate (tableiw), k-rate and a-rate (tablew). These opcodes provide many options and are safe because of boundary check, but you may have problems with non-power-of-two tables.</p>
<p>tabw_i / tabw: Write values to a function table at i-rate (tabw_i), k-rate or a-rate (tabw). Offer less options than the tableiw/tablew opcodes, but work also for non-power-of-two tables. They do not provide a boundary check, which makes them fast but also give the user the resposability not writing any value off the table boundaries.</p>
<p>Tab_i / tab: Leer los valores de una tabla de funciones en i-rate (tab_i), k-rate o a-rate (tab). No ofrecen interpolaci&oacute;n y menos opciones que los opcodes de tabla, pero tambi&eacute;n funcionan para tablas que no son de potencia de dos. No proporcionan una comprobaci&oacute;n de l&iacute;mites, lo que los hace r&aacute;pidos, pero tambi&eacute;n dan al usuario la resposabilidad de no leer ning&uacute;n valor fuera de los l&iacute;mites de la tabla.</p>
<p>Tableiw / tablew: Escribe valores en una tabla de funciones en i-rate (tableiw), k-rate y a-rate (tablew). Estos opcodes ofrecen muchas opciones y son seguros debido a la comprobaci&oacute;n de l&iacute;mites, pero es posible que tenga problemas con tablas que no sean de potencia de dos.</p>
<p>Tabw_i / tabw: Escribe valores en una tabla de funciones en i-rate (tabw_i), k-rate o a-rate (tabw). Ofrecen menos opciones que los opcodes tableiw / tablew, pero tambi&eacute;n trabajan para tablas que no sean de potencia de dos. No proporcionan una comprobaci&oacute;n de l&iacute;mites, lo que los hace r&aacute;pidos, sino que tambi&eacute;n le dan al usuario la responsabilidad de no escribir ning&uacute;n valor fuera de los l&iacute;mites de la tabla.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/poscil.html">poscil / poscil3: Precise oscillators for reading function tables at k- or a-rate, with linear (poscil) or cubic (poscil3) interpolation. They support also non-power-of-two tables, so it's usually recommended to use them instead of the older oscili/oscil3 opcodes. Poscil has also a-rate input for amplitude and frequency, while poscil3 has just k-rate input. </a></p>
<p>Poscil / poscil3: Osciladores precisos para leer las tablas de funciones en k o a-tasa, con interpolaci&oacute;n lineal (poscil) o c&uacute;bica (poscil3). Tambi&eacute;n admiten tablas que no son de potencia de dos, por lo que usualmente se recomienda usarlas en lugar de las viejas opcodes oscili / oscil3. Poscil tambi&eacute;n tiene una entrada de frecuencia para la amplitud y la frecuencia, mientras que poscil3 tiene s&oacute;lo k-tasa de entrada.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/oscili.html">oscili / oscil3: The standard oscillators in Csound for reading function tables at k- or a-rate, with linear (oscili) or cubic (oscil3) interpolation. They support all rates for the amplitude and frequency input, but are restricted to power-of-two tables. Particularily for long tables and low frequencies they are not as precise as the poscil/poscil3 oscillators. </a></p>
<p>Oscili / oscil3: Los osciladores est&aacute;ndar en Csound para leer las tablas de funci&oacute;n en k o a-tasa, con interpolaci&oacute;n lineal (oscili) o c&uacute;bica (oscil3). Apoyan todas las velocidades para la entrada de amplitud y frecuencia, pero se limitan a las tablas power-of-two. Particularmente para tablas largas y frecuencias bajas no son tan precisas como los poscil / poscil3 osciladores.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/ftsave.html">ftsave / ftsavek: Save a function table as a file, at i-time (ftsave) or k-time (ftsavek). This can be a text file or a binary file, but not a soundfile. If you want to save a soundfile, use the User Defined Opcode TableToSF. </a></p>
<p>Ftsave / ftsavek: Guarda una tabla de funciones como un archivo, en i-time (ftsave) o k-time (ftsavek). Esto puede ser un archivo de texto o un archivo binario, pero no un archivo de sonido. Si desea guardar un archivo de sonido, utilice el Opcode definido por el usuario TableToSF.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/ftload.html">ftload / ftloadk: Load a function table which has been written by ftsave/ftsavek. </a></p>
<p>Ftload / ftloadk: Carga una tabla de funciones que ha sido escrita por ftsave / ftsavek.</p>
<p>&nbsp;</p>
<p><a href="http://www.csounds.com/manual/html/line.html">line / linseg / phasor: Can be used to create index values which are needed to read/write k- or a-signals with the table/tablew or tab/tabw opcodes. </a></p>
<p>Line / linseg / fasor: Puede usarse para crear valores de &iacute;ndice que son necesarios para leer / escribir k-o-se&ntilde;ales con los c&oacute;digos de tabla / tablew o tab / tabw.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<ol id="InsertNote_NoteList">
<li id="InsertNoteID_6">ftgen is preferred mainly because you can refer to the function table by a variable name and must not deal with constant tables numbers. This will enhance the portability of orchestras and better facilitate the combining of multiple orchestras. It can also enhance the readability of an orchestra if a function table is located in the code nearer the instrument that uses it.<span id="InsertNoteID_6_LinkBacks"><sup><a href="d-function-tables/d-function-tables#InsertNoteID_6_marker7">^</a></sup></span></li>
<li id="InsertNoteID_24">If your .csd file is, for instance, in the directory /home/jh/csound, and your sound file in the directory /home/jh/samples, you should add this inside the &lt;CsOptions&gt; tag:
<p style="-qt-block-indent: 0; text-indent: 0px; -qt-user-state: 0; margin: 0px;">--env:SSDIR+=/home/jh/samples. This means: 'Look also in /home/jh/sample as Sound Sample Directory (SSDIR)'</p>
<span id="InsertNoteID_24_LinkBacks"><sup><a href="d-function-tables/d-function-tables#InsertNoteID_24_marker25">^</a></sup></span></li>
<li id="InsertNoteID_8">For a general introduction about interpolation, see for instance <a href="http://en.wikipedia.org/wiki/Interpolation">http://en.wikipedia.org/wiki/Interpolation</a><span id="InsertNoteID_8_LinkBacks"><sup><a href="d-function-tables/d-function-tables#InsertNoteID_8_marker9">^</a></sup></span></li>
</ol>
<p>varname, ifn, itime: These arguments have the same meaning as explained above in reference to GEN02. Note that on this occasion the function table number (ifn) has been defined using a zero. This means that Csound will automatically assign a unique function table number. This number will also be held by the variable giFile which we will normally use to reference the function table anyway so its actual value will not be important to us. If you are interested you can print the value of giFile (ifn) out. If no other tables are defined, it will be 101 and subsequent tables, also using automatically assigned table numbers, will follow accordingly: 102, 103 etc.</p>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

