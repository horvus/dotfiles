
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">
<meta property="og:site_name" content="FLOSS Manuals"/><meta name="description" content="Free Manuals for Freedom"/>

<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: F-Live-Events / CSOUND Español</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND Español" href="/feeds/rss/book/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND Español" href="/feeds/atom/book/csound-espanol/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter F. LIVE EVENTS" href="/feeds/rss/chapter/csound-espanol/csound-espanol/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter F. LIVE EVENTS" href="/feeds/atom/chapter/csound-espanol/csound-espanol/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logotext"><a href="http://write.flossmanuals.net/">FLOSS Manuals</a> </div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound-espanol/_draft/_v/1.0/f-live-events/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND Español</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCCIÓN</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/preface/">PREFACIO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/how-to-use-this-manual/">CÓMO USAR ESTE MANUAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/on-this-release/">ACERCA DE ESTE LANZAMIENTO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/credits/">CRÉDITOS</a></li>
    
   
    
      <li><b>01 CUESTIONES BÁSICAS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-digital-audio/">A. AUDIO DIGITAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-pitch-and-frequency/">B. ALTURA Y FRECUENCIA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-intensities/">C. INTENSIDADES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-random/">D. ALEATORIEDAD</a></li>
    
   
    
      <li><b>02 INICIO RÁPIDO</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-make-csound-run/">A. CORRIENDO CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-syntax/">B. SINTÁXIS DE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURACIÓN MIDI</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-live-audio/">D. AUDIO EN VIVO</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-rendering-to-file/">E. SALIDA A UN ARCHIVO</a></li>
    
   
    
      <li><b>03 EL LENGUAJE DE CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-initialization-and-performance-pass/">A. PASADAS DE INICIALIZACIÓN Y EJECUCIÓN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound-espanol/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <h1>LIVE EVENTS</h1>
<p>The basic concept of Csound from the early days of the program is still valid and useful because it is a musically familiar one: you create a set of instruments and instruct them to play at various times. These calls of instrument instances, and their execution, are called "instrument events".</p>
<p>El concepto b&aacute;sico de Csound desde los primeros d&iacute;as del programa sigue siendo v&aacute;lido y &uacute;til porque es musicalmente familiar: se crea un conjunto de instrumentos y se les instruye a jugar en diferentes momentos. Estos llamados de instancias instrumentales, y su ejecuci&oacute;n, se llaman eventos instrumentales.</p>
<p>&nbsp;</p>
<p>Whenever any Csound code is executed, it has to be compiled first. Since Csound6, you can change the code of any running Csound instance, and recompile it on the fly. There are basically two opcodes for this "live coding": compileorc re-compiles any existing orc file, whereas compilestr compiles any string. At the end of this chapter, we will present some simple examples for both methods, followed by a description how to re-compile code on the fly in CsoundQt.</p>
<p>Cada vez que se ejecuta un c&oacute;digo Csound, primero se debe compilar. Desde Csound6, puede cambiar el c&oacute;digo de cualquier instancia de Csound en ejecuci&oacute;n, y volver a compilarlo sobre la marcha. Existen b&aacute;sicamente dos opcodes para esta codificaci&oacute;n en vivo: compileorc vuelve a compilar cualquier archivo orc existente, mientras compilestr compila cualquier cadena. Al final de este cap&iacute;tulo, presentaremos algunos ejemplos sencillos para ambos m&eacute;todos, seguidos de una descripci&oacute;n de c&oacute;mo volver a compilar el c&oacute;digo al vuelo en CsoundQt.</p>
<p>&nbsp;</p>
<p>The scheme of instruments and events can be instigated in a number of ways. In the classical approach you think of an "orchestra" with a number of musicians playing from a "score", but you can also trigger instruments using any kind of live input: from MIDI, from OSC, from the command line, from a GUI (such as Csound's FLTK widgets or CsoundQt's widgets), from the API (also used in CsoundQt's Live Event Sheet). Or you can create a kind of "master instrument", which is always on, and triggers other instruments using opcodes designed for this task, perhaps under certain conditions: if the live audio input from a singer has been detected to have a base frequency greater than 1043 Hz, then start an instrument which plays a soundfile of broken glass...</p>
<p>El esquema de instrumentos y eventos puede ser instigado de varias maneras. En el enfoque cl&aacute;sico se piensa en una orquesta con un n&uacute;mero de m&uacute;sicos que juegan a partir de una partitura, pero tambi&eacute;n se puede activar instrumentos con cualquier tipo de entrada en vivo: desde MIDI, desde OSC, desde la l&iacute;nea de comandos, desde una GUI (como Csounds Widgets FLTK o widgets CsoundQts), desde la API (tambi&eacute;n utilizada en la hoja de eventos en vivo de CsoundQts). O puede crear un tipo de instrumento maestro, que est&aacute; siempre encendido, y dispara otros instrumentos usando opcodes dise&ntilde;ados para esta tarea, tal vez bajo ciertas condiciones: si se ha detectado que la entrada de audio en vivo de un cantante tiene una frecuencia base superior a 1043 Hz, a continuaci&oacute;n, iniciar un instrumento que reproduce un soundfile de vidrio roto ...</p>
<h2>Order of Execution Revisited</h2>
<p>Whatever you do in Csound with instrument events, you must bear in mind the order of execution that has been explained in the first chapter of this section about the Initialization and Performance Pass: instruments are executed one by one, both in the initialization pass and in each control cycle, and the order is determined by the instrument number.</p>
<p>Sea lo que sea que hagas en Csound con eventos de instrumentos, debes tener en cuenta el orden de ejecuci&oacute;n que se ha explicado en el primer cap&iacute;tulo de esta secci&oacute;n sobre el paso de inicializaci&oacute;n y rendimiento: los instrumentos se ejecutan uno por uno, tanto en el paso de inicializaci&oacute;n como en Cada ciclo de control, y el orden se determina por el n&uacute;mero del instrumento. </p>
<p>&nbsp;</p>
<p>It is worth to have a closer look to what is happening exactly in time if you trigger an instrument from inside another instrument. The first example shows the result when instrument 2 triggers instrument 1 and instrument 3 at init-time.</p>
<p>Vale la pena tener una mirada m&aacute;s cercana a lo que est&aacute; sucediendo exactamente en el tiempo si se dispara un instrumento desde dentro de otro instrumento. El primer ejemplo muestra el resultado cuando el instrumento 2 activa el instrumento 1 y el instrumento 3 a init-time.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F01_OrderOfExc_event_i.csd</strong></em>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441

instr 1
kCycle timek
prints "Instrument 1 is here at initialization.\n"
printks "Instrument 1: kCycle = %d\n", 0, kCycle
endin

instr 2
kCycle timek
prints "  Instrument 2 is here at initialization.\n"
printks "  Instrument 2: kCycle = %d\n", 0, kCycle
event_i "i", 3, 0, .02
event_i "i", 1, 0, .02
endin

instr 3
kCycle timek
prints "    Instrument 3 is here at initialization.\n"
printks "    Instrument 3: kCycle = %d\n", 0, kCycle
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 2 0 .02
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>This is the output: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">&nbsp; Instrument 2 is here at initialization. <br />&nbsp;&nbsp;&nbsp; Instrument 3 is here at initialization. <br />Instrument 1 is here at initialization. <br />Instrument 1: kCycle = 1 <br />&nbsp; Instrument 2: kCycle = 1 <br />&nbsp;&nbsp;&nbsp; Instrument 3: kCycle = 1 <br />Instrument 1: kCycle = 2 <br />&nbsp; Instrument 2: kCycle = 2 <br />&nbsp;&nbsp;&nbsp; Instrument 3: kCycle = 2 </span></p>
<p>Instrument 2 is the first one to initialize, because it is the only one which is called by the score. Then instrument 3 is initialized, because it is called first by instrument 2. The last one is instrument 1. All this is done before the actual performance begins. In the performance itself, starting from the first control cycle, all instruments are executed by their order.</p>
<p>El Instrumento 2 es el primero en inicializar, porque es el &uacute;nico que es llamado por la partitura. Entonces se inicializa el instrumento 3, porque es llamado primero por el instrumento 2. El &uacute;ltimo es el instrumento 1. Todo esto se hace antes de que empiece el funcionamiento real. En el propio funcionamiento, a partir del primer ciclo de control, todos los instrumentos se ejecutan por su orden.</p>
<p>&nbsp;</p>
<p>Let us compare now what is happening when instrument 2 calls instrument 1 and 3 during the performance (= at k-time):</p>
<p>Comparemos ahora lo que est&aacute; sucediendo cuando el instrumento 2 llama al instrumento 1 y 3 durante el desempe&ntilde;o (= en k-tiempo):</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F02_OrderOfExc_event_k.csd</strong></em>&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441
0dbfs = 1
nchnls = 1

instr 1
kCycle timek
prints "Instrument 1 is here at initialization.\n"
printks "Instrument 1: kCycle = %d\n", 0, kCycle
endin

instr 2
kCycle timek
prints "  Instrument 2 is here at initialization.\n"
printks "  Instrument 2: kCycle = %d\n", 0, kCycle
 if kCycle == 1 then
event "i", 3, 0, .02
event "i", 1, 0, .02
 endif
printks "  Instrument 2: still in kCycle = %d\n", 0, kCycle
endin

instr 3
kCycle timek
prints "    Instrument 3 is here at initialization.\n"
printks "    Instrument 3: kCycle = %d\n", 0, kCycle
endin

instr 4
kCycle timek
prints "      Instrument 4 is here at initialization.\n"
printks "      Instrument 4: kCycle = %d\n", 0, kCycle
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 4 0 .02
i 2 0 .02
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>This is the output: <br /><span style="font-family: 'courier new', courier, monospace; font-size: small;">&nbsp; Instrument 2 is here at initialization. <br />&nbsp; &nbsp; &nbsp; Instrument 4 is here at initialization. <br />&nbsp; Instrument 2: kCycle = 1 <br />&nbsp; Instrument 2: still in kCycle = 1 <br />&nbsp; &nbsp; &nbsp; Instrument 4: kCycle = 1 <br />&nbsp;&nbsp;&nbsp; Instrument 3 is here at initialization. <br />Instrument 1 is here at initialization. <br />Instrument 1: kCycle = 2 <br />&nbsp; Instrument 2: kCycle = 2 <br />&nbsp; Instrument 2: still in kCycle = 2 <br />&nbsp;&nbsp;&nbsp; Instrument 3: kCycle = 2 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instrument 4: kCycle = 2 </span></p>
<p>Instrument 2 starts with its init-pass, and then instrument 4 is initialized. As you see, the reverse order of the scorelines has no effect; the instruments which start at the same time are executed in ascending order, depending on their numbers.</p>
<p>El instrumento 2 comienza con su init-pass y luego se inicializa el instrumento 4. Como puede ver, el orden inverso de los resultados no tiene ning&uacute;n efecto; Los instrumentos que comienzan al mismo tiempo se ejecutan en orden ascendente, dependiendo de sus n&uacute;meros.</p>
<p>&nbsp;</p>
<p>In this first cycle, instrument 2 calls instrument 3 and 1. As you see by the output of instrument 4, the whole control cycle is finished first, before instrument 3 and 1 (in this order) are initialized.1 These both instruments start their performance in cycle number two, where they find themselves in the usual order: instrument 1 before instrument 2, then instrument 3 before instrument 4.</p>
<p>En este primer ciclo, el instrumento 2 llama a los instrumentos 3 y 1. Como se ve por la salida del instrumento 4, todo el ciclo de control se termina primero, antes de que se inicialicen los instrumentos 3 y 1 (en este orden). Rendimiento en el ciclo n&uacute;mero dos, donde se encuentran en el orden habitual: instrumento 1 antes instrumento 2, luego instrumento 3 antes instrumento 4.</p>
<p>Usually you will not need to know all of this with such precise timing. But in case you experience any problems, a clearer awareness of the process may help.</p>
<p>Por lo general, no necesitar&aacute; saber todo esto con un calendario tan preciso. Pero en caso de que experimente alg&uacute;n problema, una conciencia m&aacute;s clara del proceso puede ayudar.</p>
<p>&nbsp;</p>
<p>Instrument Events From The Score</p>
<p>This is the classical way of triggering instrument events: you write a list in the score section of a .csd file. Each line which begins with an "i", is an instrument event. As this is very simple, and examples can be found easily, let us focus instead on some additional features which can be useful when you work in this way. Documentation for these features can be found in the Score Statements section of the Canonical Csound Reference Manual. Here are some examples:</p>
<p>Esta es la forma cl&aacute;sica de activar eventos de instrumentos: escribe una lista en la secci&oacute;n de puntuaci&oacute;n de un archivo .csd. Cada l&iacute;nea que comienza con un i, es un evento de instrumento. Como esto es muy simple, y los ejemplos se pueden encontrar f&aacute;cilmente, nos centramos en cambio en algunas caracter&iacute;sticas adicionales que pueden ser &uacute;tiles cuando se trabaja de esta manera. La documentaci&oacute;n de estas caracter&iacute;sticas se puede encontrar en la secci&oacute;n \Documentation for these features can be found in the Score Statements section of the Canonical Csound Reference Manual.Here are some examples:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F03_Score_tricks.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giWav     ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kFadout   init      1
krel      release   ;returns "1" if last k-cycle
 if krel == 1 &amp;&amp; p3 &lt; 0 then ;if so, and negative p3:
          xtratim   .5       ;give 0.5 extra seconds
kFadout   linseg    1, .5, 0 ;and make fade out
 endif
kEnv      linseg    0, .01, p4, abs(p3)-.1, p4, .09, 0; normal fade out
aSig      poscil    kEnv*kFadout, p5, giWav
          outs      aSig, aSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
t 0 120                      ;set tempo to 120 beats per minute
i    1    0    1    .2   400 ;play instr 1 for one second
i    1    2   -10   .5   500 ;play instr 1 indefinetely (negative p3)
i   -1    5    0             ;turn it off (negative p1)
; -- turn on instance 1 of instr 1 one sec after the previous start
i    1.1  ^+1  -10  .2   600
i    1.2  ^+2  -10  .2   700 ;another instance of instr 1
i   -1.2  ^+2  0             ;turn off 1.2
; -- turn off 1.1 (dot = same as the same p-field above)
i   -1.1  ^+1  .
s                            ;end of a section, so time begins from new at zero
i    1    1    1    .2   800
r 5                          ;repeats the following line (until the next "s")
i    1   .25  .25   .2   900
s
v 2                          ;lets time be double as long
i    1    0    2    .2   1000
i    1    1    1    .2   1100
s
v 0.5                        ;lets time be half as long
i    1    0    2    .2   1200
i    1    1    1    .2   1300
s                            ;time is normal now again
i    1    0    2    .2   1000
i    1    1    1    .2   900
s
; -- make a score loop (4 times) with the variable "LOOP"
{4 LOOP
i    1    [0 + 4 * $LOOP.]    3    .2   [1200 - $LOOP. * 100]
i    1    [1 + 4 * $LOOP.]    2    .    [1200 - $LOOP. * 200]
i    1    [2 + 4 * $LOOP.]    1    .    [1200 - $LOOP. * 300]
}
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Triggering an instrument with an indefinite duration by setting p3 to any negative value, and stopping it by a negative p1 value, can be an important feature for live events. If you turn instruments off in this way you may have to add a fade out segment. One method of doing this is shown in the instrument above with a combination of the release and the xtratim opcodes. Also note that you can start and stop certain instances of an instrument with a floating point number as p1.</p>
<p>Disparar un instrumento con una duraci&oacute;n indefinida ajustando p3 a cualquier valor negativo, y detenerlo por un valor p1 negativo, puede ser una caracter&iacute;stica importante para eventos en vivo. Si apaga los instrumentos de esta manera puede que tenga que agregar un segmento de fundido. Un m&eacute;todo para hacer esto se muestra en el instrumento anterior con una combinaci&oacute;n de los c&oacute;digos de liberaci&oacute;n y el xtratim. Tambi&eacute;n tenga en cuenta que puede iniciar y detener ciertas instancias de un instrumento con un n&uacute;mero de punto flotante como p1.</p>
<p>Using MIDI Note-On Events</p>
<p>Csound has a particular feature which makes it very simple to trigger instrument events from a MIDI keyboard. Each MIDI Note-On event can trigger an instrument, and the related Note-Off event of the same key stops the related instrument instance. This is explained more in detail in the chapter Triggering Instrument Instances in the MIDI section of this manual. Here, just a small example is shown. Simply connect your MIDI keyboard and it should work.</p>
<p>Csound tiene una caracter&iacute;stica particular que hace que sea muy sencillo disparar eventos de instrumentos desde un teclado MIDI. Cada evento MIDI Note-On puede activar un instrumento, y el evento Note-Off relacionado de la misma tecla detiene la instancia del instrumento relacionado. Esto se explica m&aacute;s detalladamente en el cap&iacute;tulo Triggering Instrument Instances en la secci&oacute;n MIDI de este manual. Aqu&iacute;, s&oacute;lo un peque&ntilde;o ejemplo se muestra. Simplemente conecte su teclado MIDI y deber&iacute;a funcionar.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F04_Midi_triggered_events.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-Ma -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          massign   0, 1; assigns all midi channels to instr 1

  instr 1
iFreq     cpsmidi   ;gets frequency of a pressed key
iAmp      ampmidi   8 ;gets amplitude and scales 0-8
iRatio    random    .9, 1.1 ;ratio randomly between 0.9 and 1.1
aTone     foscili   .1, iFreq, 1, iRatio/5, iAmp+1, giSine ;fm
aEnv      linenr    aTone, 0, .01, .01 ; avoiding clicks at the note-end
          outs      aEnv, aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000; play for 10 hours
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Using Widgets</h2>
<p>If you want to trigger an instrument event in realtime with a Graphical User Interface, it is usually a "Button" widget which will do this job. We will see here a simple example; first implemented using Csound's FLTK widgets, and then using CsoundQt's widgets.</p>
<p>Si desea activar un evento de instrumento en tiempo real con una interfaz gr&aacute;fica de usuario, normalmente es un widget de bot&oacute;n que realizar&aacute; este trabajo. Veremos aqu&iacute; un ejemplo simple; Primero implementado utilizando widgets Csounds FLTK, y luego utilizando widgets CsoundQts.</p>
<p>&nbsp;</p>
<p>FLTK Button</p>
<p>This is a very simple example demonstrating how to trigger an instrument using an FLTK button. A more extended example can be found here.</p>
<p>Este es un ejemplo muy simple que demuestra c&oacute;mo activar un instrumento usando un bot&oacute;n FLTK. Un ejemplo m&aacute;s extenso se puede encontrar aqu&iacute;.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F05_FLTK_triggered_events.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

      ; -- create a FLTK panel --
          FLpanel   "Trigger By FLTK Button", 300, 100, 100, 100
      ; -- trigger instr 1 (equivalent to the score line "i 1 0 1")k1, ih1   FLbutton  "Push me!", 0, 0, 1, 150, 40, 10, 25, 0, 1, 0, 1
      ; -- trigger instr 2
k2, ih2   FLbutton  "Quit", 0, 0, 1, 80, 40, 200, 25, 0, 2, 0, 1
          FLpanelEnd; end of the FLTK panel section
          FLrun     ; run FLTK
          seed      0; random seed different each time

  instr 1
idur      random    .5, 3; recalculate instrument duration
p3        =         idur; reset instrument duration
ioct      random    8, 11; random values between 8th and 11th octave
idb       random    -18, -6; random values between -6 and -18 dB
aSig      poscil    ampdb(idb), cpsoct(ioct)
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

instr 2
          exitnow
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>Note that in this example the duration of an instrument event is recalculated when the instrument is initialised. This is done using the statement "p3 = i...". This can be a useful technique if you want the duration that an instrument plays for to be different each time it is called. In this example duration is the result of a random function'. The duration defined by the FLTK button will be overwritten by any other calculation within the instrument itself at i-time.</p>
<p>Tenga en cuenta que en este ejemplo la duraci&oacute;n de un evento de instrumento se recalcula cuando se inicializa el instrumento. Esto se hace usando la instrucci&oacute;n p3 = i .... Esta puede ser una t&eacute;cnica &uacute;til si desea que la duraci&oacute;n que un instrumento juega para ser diferente cada vez que se llama. En este ejemplo la duraci&oacute;n es el resultado de una funci&oacute;n aleatoria. La duraci&oacute;n definida por el bot&oacute;n FLTK se sobrescribir&aacute; por cualquier otro c&aacute;lculo dentro del propio instrumento en i-time.</p>
<p>&nbsp;</p>
<p>CsoundQt Button</p>
<p>In CsoundQt, a button can be created easily from the submenu in a widget panel:</p>
<p>En CsoundQt, se puede crear f&aacute;cilmente un bot&oacute;n desde el submen&uacute; en un panel de widgets:</p>
<p>&nbsp;</p>
<p><img src="/csound/_v/1.0/http://en.flossmanuals.net/floss/pub/Csound/" alt="" width="0" height="0" /><img style="display: block; margin-left: auto; margin-right: auto;" title="qcbutton1" src="static/Csound-Picts-03_CsLanguage-qcbutton1-en.png" alt="qcbutton1" width="373" height="520" />&nbsp;</p>
<p>In the Properties Dialog of the button widget, make sure you have selected "event" as Type. Insert a Channel name, and at the bottom type in the event you want to trigger - as you would if writing a line in the score.</p>
<p>En el cuadro de di&aacute;logo Propiedades del widget de bot&oacute;n, aseg&uacute;rese de haber seleccionado el evento como Tipo. Inserte un nombre de canal y, en la parte inferior, escriba el evento que desee activar, como si escribiera una l&iacute;nea en la partitura.</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="qcbutton3" src="static/Csound-Picts-03_CsLanguage-qcbutton3-en.png" alt="qcbutton3" width="542" height="326" /></p>
<p>In your Csound code, you need nothing more than the instrument you want to trigger:</p>
<p>En su c&oacute;digo Csound, no necesita nada m&aacute;s que el instrumento que desea activar:</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="qcbutton4" src="static/Csound-Picts-03_CsLanguage-qcbutton4-en.png" alt="qcbutton4" width="549" height="364" />&nbsp;</p>
<p>For more information about CsoundQt, read the CsoundQt chapter in the 'Frontends' section of this manual.</p>
<p>Para obtener m&aacute;s informaci&oacute;n acerca de CsoundQt, lea el cap&iacute;tulo CsoundQt en la secci&oacute;n de Frontends de este manual.</p>
<p>&nbsp;</p>
<p>Using A Realtime Score</p>
<h3>Command Line With The -L stdin Option</h3>
<p>If you use any .csd with the option "-L stdin" (and the -odac option for realtime output), you can type any score line in realtime (sorry, this does not work for Windows). For instance, save this .csd anywhere and run it from the command line:</p>
<p>Si utiliza cualquier .csd con la opci&oacute;n -L stdin (y la opci&oacute;n -odac para la salida en tiempo real), puede escribir cualquier l&iacute;nea de puntuaci&oacute;n en tiempo real (lo siento, esto no funciona para Windows). Por ejemplo, guarde este .csd en cualquier lugar y ejec&uacute;telo desde la l&iacute;nea de comandos:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F06_Commandline_rt_events.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-L stdin -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1
idur      random    .5, 3; calculate instrument duration
p3        =         idur; reset instrument duration
ioct      random    8, 11; random values between 8th and 11th octave
idb       random    -18, -6; random values between -6 and -18 dB
aSig      oscils    ampdb(idb), cpsoct(ioct), 0
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>If you run it by typing and returning a command line like this ...</p>
<p>Si lo ejecuta escribiendo y devolviendo una l&iacute;nea de comandos como esta ...</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="cmdline" src="static/Csound-Picts-03_CsLanguage-cmdline-en.png" alt="cmdline" width="640" height="74" /></p>
<p>... you should get a prompt at the end of the Csound messages:</p>
<p>... debe recibir un mensaje al final de los mensajes Csound:</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="_L1" src="static/Csound-Picts-03_CsLanguage-_L1-en.png" alt="_L1" width="632" height="444" />&nbsp;</p>
<p>If you now type the line "i 1 0 1" and press return, you should hear that instrument 1 has been executed. After three times your messages may look like this:</p>
<p>Si ahora escribe la l&iacute;nea i 1 0 1 y pulsa return, deber&iacute;a escuchar que el instrumento 1 ha sido ejecutado. Despu&eacute;s de tres veces sus mensajes pueden verse as&iacute;:</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="_L2" src="static/Csound-Picts-03_CsLanguage-_L2-en.png" alt="_L2" width="509" height="448" />&nbsp;</p>
<h3>CsoundQt's Live Event Sheet</h3>
<p>In general, this is the method that CsoundQt uses and it is made available to the user in a flexible environment called the Live Event Sheet. Have a look in the CsoundQt frontend to see more of the possibilities of "firing" live instrument events using the Live Event Sheet.2</p>
<p>En general, este es el m&eacute;todo que utiliza CsoundQt y se pone a disposici&oacute;n del usuario en un entorno flexible denominado Live Event Sheet. Echa un vistazo en el frontend de CsoundQt para ver m&aacute;s de las posibilidades de disparar eventos de instrumentos en vivo usando la Live Event Sheet.2</p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="qcs_lesheet" src="static/Csound-Picts-03_CsLanguage-qcs_lesheet-en.png" alt="qcs_lesheet" width="740" height="483" />&nbsp;</p>
<h2>By Conditions</h2>
<p>We have discussed first the classical method of triggering instrument events from the score section of a .csd file, then we went on to look at different methods of triggering real time events using MIDI, by using widgets, and by using score lines inserted live. We will now look at the Csound orchestra itself and to some methods by which an instrument can internally trigger another instrument. The pattern of triggering could be governed by conditionals, or by different kinds of loops. As this "master" instrument can itself be triggered by a realtime event, you have unlimited options available for combining the different methods.</p>
<p>Hemos discutido primero el m&eacute;todo cl&aacute;sico de desencadenar eventos de instrumentos de la secci&oacute;n de puntuaci&oacute;n de un archivo .csd, luego pasamos a mirar diferentes m&eacute;todos de desencadenar eventos en tiempo real usando MIDI, usando widgets y usando l&iacute;neas de puntuaci&oacute;n insertadas en vivo. Ahora examinaremos la propia orquesta de Csound y algunos m&eacute;todos mediante los cuales un instrumento puede activar internamente otro instrumento. El patr&oacute;n de activaci&oacute;n podr&iacute;a ser gobernado por condicionales, o por diferentes tipos de bucles. Como este instrumento maestro puede ser activado por un evento en tiempo real, tiene opciones ilimitadas disponibles para combinar los diferentes m&eacute;todos.</p>
<p>&nbsp;</p>
<p>Let's start with conditionals. If we have a realtime input, we may want to define a threshold, and trigger an event</p>
<p>Comencemos con condicionales. Si tenemos una entrada en tiempo real, es posible que desee definir un umbral, y desencadenar un evento</p>
<p>if we cross the threshold from below to above;</p>
<p>Si cruzamos el umbral de abajo hacia arriba;</p>
<p>if we cross the threshold from above to below.</p>
<p>Si cruzamos el umbral de arriba a abajo.</p>
<p>In Csound, this could be implemented using an orchestra of three instruments. The first instrument is the master instrument. It receives the input signal and investigates whether that signal is crossing the threshold and if it does whether it is crossing from low to high or from high to low. If it crosses the threshold from low ot high the second instrument is triggered, if it crosses from high to low the third instrument is triggered.</p>
<p>En Csound, esto podr&iacute;a ser implementado usando una orquesta de tres instrumentos. El primer instrumento es el instrumento maestro. Recibe la se&ntilde;al de entrada e investiga si esa se&ntilde;al est&aacute; cruzando el umbral y si lo hace si est&aacute; cruzando de baja a alta o de alta a baja. Si cruza el umbral desde el punto m&aacute;s bajo o el segundo instrumento se dispara, si cruza de alto a bajo, se dispara el tercer instrumento.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F07_Event_by_condition.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1; master instrument
ichoose   =         p4; 1 = real time audio, 2 = random amplitude movement
ithresh   =         -12; threshold in dB
kstat     init      1; 1 = under the threshold, 2 = over the threshold
;;CHOOSE INPUT SIGNAL
 if ichoose == 1 then
ain       inch      1
 else
kdB       randomi   -18, -6, 1
ain       pinkish   ampdb(kdB)
 endif
;;MEASURE AMPLITUDE AND TRIGGER SUBINSTRUMENTS IF THRESHOLD IS CROSSED
afoll     follow    ain, .1; measure mean amplitude each 1/10 second
kfoll     downsamp  afoll
 if kstat == 1 &amp;&amp; dbamp(kfoll) &gt; ithresh then; transition down-&gt;up
          event     "i", 2, 0, 1; call instr 2
          printks   "Amplitude = %.3f dB%n", 0, dbamp(kfoll)
kstat     =         2; change status to "up"
 elseif kstat == 2 &amp;&amp; dbamp(kfoll) &lt; ithresh then; transition up-&gt;down
          event     "i", 3, 0, 1; call instr 3
          printks   "Amplitude = %.3f dB%n", 0, dbamp(kfoll)
kstat     =         1; change status to "down"
 endif
  endin

  instr 2; triggered if threshold has been crossed from down to up
asig      poscil    .2, 500
aenv      transeg   1, p3, -10, 0
          outs      asig*aenv, asig*aenv
  endin

  instr 3; triggered if threshold has been crossed from up to down
asig      poscil    .2, 400
aenv      transeg   1, p3, -10, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000 2 ;change p4 to "1" for live input
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Using i-Rate Loops For Calculating A Pool Of Instrument Events</h2>
<p>You can perform a number of calculations at init-time which lead to a list of instrument events. In this way you are producing a score, but inside an instrument. The score events are then executed later.</p>
<p>Puede realizar una serie de c&aacute;lculos a init-time que llevan a una lista de eventos de instrumentos. De esta manera usted est&aacute; produciendo una puntuaci&oacute;n, pero dentro de un instrumento. Los eventos de puntuaci&oacute;n se ejecutan posteriormente.</p>
<p>&nbsp;</p>
<p>Using this opportunity we can introduce the scoreline / scoreline_i opcode. It is quite similar to the event / event_i opcode but has two major benefits:</p>
<p>Utilizando esta oportunidad, podemos introducir el c&oacute;digo de operaci&oacute;n scoreline / scoreline_i. Es muy similar al evento / event_i opcode, pero tiene dos grandes beneficios:</p>
<p>&nbsp;</p>
<p>You can write more than one scoreline by using "{{" at the beginning and "}}" at the end.</p>
<p>Puede escribir m&aacute;s de un marcador utilizando {{al principio y}} al final.</p>
<p>&nbsp;</p>
<p>You can send a string to the subinstrument (which is not possible with the event opcode).</p>
<p>Puede enviar una cadena al subinstrumento (lo cual no es posible con el opcode de evento).</p>
<p>&nbsp;</p>
<p>Let's look at a simple example for executing score events from an instrument using the scoreline opcode:</p>
<p>Veamos un ejemplo sencillo para ejecutar eventos de puntuaci&oacute;n desde un instrumento usando el c&oacute;digo de operaci&oacute;n de scoreline:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F08_Generate_event_pool.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1 ;master instrument with event pool
          scoreline_i {{i 2 0 2 7.09
                        i 2 2 2 8.04
                        i 2 4 2 8.03
                        i 2 6 1 8.04}}
  endin

  instr 2 ;plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>With good right, you might say: "OK, that's nice, but I can also write scorelines in the score itself!" That's right, but the advantage with the scoreline_i method is that you can render the score events in an instrument, and then send them out to one or more instruments to execute them. This can be done with the sprintf opcode, which produces the string for scoreline in an i-time loop (see the chapter about control structures).</p>
<p>Con la buena derecha, usted puede ser que diga: &iexcl;OK, eso es agradable, pero puedo tambi&eacute;n escribir los scorelines en la cuenta s&iacute; mismo! Eso es correcto, pero la ventaja con el m&eacute;todo scoreline_i es que puedes renderizar los eventos de puntuaci&oacute;n en un instrumento y luego enviarlos a uno o m&aacute;s instrumentos para ejecutarlos. Esto se puede hacer con el c&oacute;digo de operaci&oacute;n sprintf, que produce la cadena para el scoreline en un bucle i-time (ver el cap&iacute;tulo sobre estructuras de control).</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F09_Events_sprintf.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giPch     ftgen     0, 0, 4, -2, 7.09, 8.04, 8.03, 8.04
          seed      0; random seed different each time

  instr 1 ; master instrument with event pool
itimes    =         7 ;number of events to produce
icnt      =         0 ;counter
istart    =         0
Slines    =         ""
loop:               ;start of the i-time loop
idur      random    1, 2.9999 ;duration of each note:
idur      =         int(idur) ;either 1 or 2
itabndx   random    0, 3.9999 ;index for the giPch table:
itabndx   =         int(itabndx) ;0-3
ipch      table     itabndx, giPch ;random pitch value from the table
Sline     sprintf   "i 2 %d %d %.2f\n", istart, idur, ipch ;new scoreline
Slines    strcat    Slines, Sline ;append to previous scorelines
istart    =         istart + idur ;recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop ;end of the i-time loop
          puts      Slines, 1 ;print the scorelines
          scoreline_i Slines ;execute them
iend      =         istart + idur ;calculate the total duration
p3        =         iend ;set p3 to the sum of all durations
          print     p3 ;print it
  endin

  instr 2 ;plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1 ;p3 is automatically set to the total duration
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>In this example, seven events have been rendered in an i-time loop in instrument 1. The result is stored in the string variable Slines. This string is given at i-time to scoreline_i, which executes them then one by one according to their starting times (p2), durations (p3) and other parameters.</p>
<p>En este ejemplo, se han representado siete eventos en un bucle i-time del instrumento 1. El resultado se almacena en la variable de cadena Slines. Esta cadena se da en i-time a scoreline_i, que los ejecuta uno a uno de acuerdo a sus tiempos de inicio (p2), duraciones (p3) y otros par&aacute;metros.</p>
<p>&nbsp;</p>
<p>Instead of collecting all score lines in a single string, you can also execute them inside the i-time loop. Also in this way all the single score lines are added to Csound's event pool. The next example shows an alternative version of the previous one by adding the instrument events one by one in the i-time loop, either with event_i (instr 1) or with scoreline_i (instr 2):</p>
<p>En lugar de recoger todas las l&iacute;neas de puntuaci&oacute;n en una sola cadena, tambi&eacute;n puede ejecutarlas dentro del bucle i-time. Tambi&eacute;n de esta manera todas las l&iacute;neas de puntuaci&oacute;n individuales se agregan al grupo de eventos Csounds. El siguiente ejemplo muestra una versi&oacute;n alternativa de la anterior agregando los eventos del instrumento uno por uno en el bucle i-time, ya sea con event_i (instr 1) o con scoreline_i (instr 2):</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F10_Events_collected.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giPch     ftgen     0, 0, 4, -2, 7.09, 8.04, 8.03, 8.04
          seed      0; random seed different each time

  instr 1; master instrument with event_i
itimes    =         7; number of events to produce
icnt      =         0; counter
istart    =         0
loop:               ;start of the i-time loop
idur      random    1, 2.9999; duration of each note:
idur      =         int(idur); either 1 or 2
itabndx   random    0, 3.9999; index for the giPch table:
itabndx   =         int(itabndx); 0-3
ipch      table     itabndx, giPch; random pitch value from the table
          event_i   "i", 3, istart, idur, ipch; new instrument event
istart    =         istart + idur; recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop; end of the i-time loop
iend      =         istart + idur; calculate the total duration
p3        =         iend; set p3 to the sum of all durations
          print     p3; print it
  endin

  instr 2; master instrument with scoreline_i
itimes    =         7; number of events to produce
icnt      =         0; counter
istart    =         0
loop:               ;start of the i-time loop
idur      random    1, 2.9999; duration of each note:
idur      =         int(idur); either 1 or 2
itabndx   random    0, 3.9999; index for the giPch table:
itabndx   =         int(itabndx); 0-3
ipch      table     itabndx, giPch; random pitch value from the table
Sline     sprintf   "i 3 %d %d %.2f", istart, idur, ipch; new scoreline
          scoreline_i Sline; execute it
          puts      Sline, 1; print it
istart    =         istart + idur; recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop; end of the i-time loop
iend      =         istart + idur; calculate the total duration
p3        =         iend; set p3 to the sum of all durations
          print     p3; print it
  endin

  instr 3; plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
i 2 14 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Using Time Loops</h2>
<p>As discussed above in the chapter about control structures, a time loop can be built in Csound either with the timout opcode or with the metro opcode. There were also simple examples for triggering instrument events using both methods. Here, a more complex example is given: A master instrument performs a time loop (choose either instr 1 for the timout method or instr 2 for the metro method) and triggers once in a loop a subinstrument. The subinstrument itself (instr 10) performs an i-time loop and triggers several instances of a sub-subinstrument (instr 100). Each instance performs a partial with an independent envelope for a bell-like additive synthesis.</p>
<p>Como se analiz&oacute; anteriormente en el cap&iacute;tulo sobre estructuras de control, se puede construir un bucle de tiempo en Csound con el c&oacute;digo de operaci&oacute;n de temporizaci&oacute;n o con el opcode de metro. Tambi&eacute;n hubo ejemplos sencillos para desencadenar eventos de instrumentos utilizando ambos m&eacute;todos. Aqu&iacute; se presenta un ejemplo m&aacute;s complejo: Un instrumento maestro realiza un bucle de tiempo (elija instr 1 para el m&eacute;todo timout o instr 2 para el m&eacute;todo metro) y desencadena una vez en un bucle un subinstrumento. El propio subinstrumento (instr 10) realiza un bucle i-time y activa varias instancias de un subinstrumento (instr 100). Cada instancia realiza una partici&oacute;n con una envolvente independiente para una s&iacute;ntesis de aditivo similar a una campana.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F11_Events_time_loop.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0

  instr 1; time loop with timout. events are triggered by event_i (i-rate)
loop:
idurloop  random    1, 4; duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
idurins   random    1, 5; duration of the triggered instrument
          event_i   "i", 10, 0, idurins; triggers instrument 10
  endin

  instr 2; time loop with metro. events are triggered by event (k-rate)
kfreq     init      1; give a start value for the trigger frequency
kTrig     metro     kfreq
 if kTrig == 1 then ;if trigger impulse:
kdur      random    1, 5; random duration for instr 10
          event     "i", 10, 0, kdur; call instr 10
kfreq     random    .25, 1; set new value for trigger frequency
 endif
  endin

  instr 10; triggers 8-13 partials
inumparts random    8, 14
inumparts =         int(inumparts); 8-13 as integer
ibasoct   random    5, 10; base pitch in octave values
ibasfreq  =         cpsoct(ibasoct)
ipan      random    .2, .8; random panning between left (0) and right (1)
icnt      =         0; counter
loop:
          event_i   "i", 100, 0, p3, ibasfreq, icnt+1, inumparts, ipan
          loop_lt   icnt, 1, inumparts, loop
  endin

  instr 100; plays one partial
ibasfreq  =         p4; base frequency of sound mixture
ipartnum  =         p5; which partial is this (1 - N)
inumparts =         p6; total number of partials
ipan      =         p7; panning
ifreqgen  =         ibasfreq * ipartnum; general frequency of this partial
ifreqdev  random    -10, 10; frequency deviation between -10% and +10%
; -- real frequency regarding deviation
ifreq     =         ifreqgen + (ifreqdev*ifreqgen)/100
ixtratim  random    0, p3; calculate additional time for this partial
p3        =         p3 + ixtratim; new duration of this partial
imaxamp   =         1/inumparts; maximum amplitude
idbdev    random    -6, 0; random deviation in dB for this partial
iamp      =   imaxamp * ampdb(idbdev-ipartnum); higher partials are softer
ipandev   random    -.1, .1; panning deviation
ipan      =         ipan + ipandev
aEnv      transeg   0, .005, 0, iamp, p3-.005, -10, 0
aSine     poscil    aEnv, ifreq
aL, aR    pan2      aSine, ipan
          outs      aL, aR
          prints    "ibasfreq = %d, ipartial = %d, ifreq = %d%n",\
                     ibasfreq, ipartnum, ifreq
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 300 ;try this, or the next line (or both)
;i 2 0 300
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Which Opcode Should I Use?&nbsp;</h2>
<p>Csound users are often confused about the variety of opcodes available to trigger instrument events. Should I use event, scoreline, schedule or schedkwhen? Should I use event or event_i?</p>
<p>Los usuarios de Csound suelen confundirse acerca de la variedad de opcodes disponibles para activar eventos de instrumentos. &iquest;Debo usar evento, scoreline, schedule o schedkwhen? &iquest;Debo usar event o event_i?</p>
<p>&nbsp;</p>
<p>Let us start with the latter, which actually leads to the general question about "i-rate" and "k-rate" opcodes.3 In short: Using event_i (the i-rate version) will only trigger an event once, when the instrument in which this opcode works is initiated. Using event (the k-rate version) will trigger an event potentially again and again, as long as the instrument runs, in each control cycle. This is a very simple example:</p>
<p>Empezaremos por este &uacute;ltimo, que en realidad conduce a la pregunta general sobre los opcodes de tasa i y k-rate.3 En resumen: el uso de event_i (la versi&oacute;n i-rate) s&oacute;lo activar&aacute; un evento una vez, cuando el instrumento en el que Opcode funciona. El uso de evento (la versi&oacute;n k-rate) activar&aacute; un evento potencialmente una y otra vez, mientras el instrumento funcione, en cada ciclo de control. Este es un ejemplo muy simple:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F12_event_i_vs_event.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr=44100
ksmps = 32

;set counters for the instances of Called_i and Called_k
giInstCi init 1
giInstCk init 1

instr Call_i
;call another instrument at i-rate
event_i "i", "Called_i", 0, 1
endin

instr Call_k
;call another instrument at k-rate
event "i", "Called_k", 0, 1
endin

instr Called_i
;report that instrument starts and which instance
prints "Instance #%d of Called_i is starting!\n", giInstCi
;increment number of instance for next instance
giInstCi += 1
endin

instr Called_k
;report that instrument starts and which instance
prints "  Instance #%d of Called_k is starting!\n", giInstCk
;increment number of instance for next instance
giInstCk += 1
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;run "Call_i" for one second
i "Call_i" 0 1
;run "Call_k" for 1/100 seconds
i "Call_k" 0 0.01
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Although instrument "Call_i" runs for one second, the call to instrument "Called_i" is only performed once, because it is done with event_i: at initialization only. But instrument "Call_k" calls one instance of "Called_k" in each control cycle; so for the duration of 0.01 seconds of running instrument "Call_k", fourteen instances of instrument "Called_k" are being started.4 So this is the output:</p>
<p>Aunque el instrumento Call_i se ejecuta durante un segundo, la llamada al instrumento Called_i s&oacute;lo se realiza una vez, porque se realiza con event_i: s&oacute;lo en la inicializaci&oacute;n. Sin embargo, el instrumento Call_k llama a una instancia de Called_k en cada ciclo de control; Por lo que durante la duraci&oacute;n de 0,01 segundos de ejecuci&oacute;n del instrumento Call_k, se est&aacute;n iniciando catorce instancias del instrumento Called_k. As&iacute; que esta es la salida:</p>
<p>&nbsp;</p>
<p><span style="font-size: small;"><span style="font-family: 'courier new', courier, monospace;">Instance #1 of Called_i is starting! </span></span></p>
<p><span style="font-size: small;"><span style="font-family: 'courier new', courier, monospace;">&nbsp; Instance #1 of Called_k is starting! <br />&nbsp; Instance #2 of Called_k is starting! <br />&nbsp; Instance #3 of Called_k is starting! <br />&nbsp; Instance #4 of Called_k is starting! <br />&nbsp; Instance #5 of Called_k is starting! <br />&nbsp; Instance #6 of Called_k is starting! <br />&nbsp; Instance #7 of Called_k is starting! <br />&nbsp; Instance #8 of Called_k is starting! <br />&nbsp; Instance #9 of Called_k is starting! <br />&nbsp; Instance #10 of Called_k is starting! <br />&nbsp; Instance #11 of Called_k is starting! <br />&nbsp; Instance #12 of Called_k is starting! <br />&nbsp; Instance #13 of Called_k is starting! <br />&nbsp; Instance #14 of Called_k is starting!</span></span></p>
<p>So the first (and probably most important) decision in asking "which opcode should I use", is the answer to the question: "Do I need an i-rate or a k-rate opcode?"</p>
<p>As&iacute; que la primera (y probablemente la m&aacute;s importante) decisi&oacute;n al preguntar qu&eacute; opcode debo usar, es la respuesta a la pregunta: &iquest;Necesito un c&oacute;digo de operaci&oacute;n i-rate o k-rate?</p>
<p>&nbsp;</p>
<p>i-rate Versions: schedule, event_i, scoreline_i</p>
<p>If you need an i-rate opcode to trigger an instrument event, schedule is the most basic choice. You use it actually exactly the same as writing any score event; just separting the parameter fields by commas rather by spaces:</p>
<p>Si necesita un opcode i-rate para activar un evento de instrumento, el programa es la opci&oacute;n m&aacute;s b&aacute;sica. Usted lo utiliza en realidad exactamente lo mismo que escribir cualquier evento de puntuaci&oacute;n; S&oacute;lo separar los campos de par&aacute;metro por comas m&aacute;s bien por espacios:</p>
<p>&nbsp;</p>
<p><strong>schedule</strong> iInstrNum (or "InstrName"), iStart, iDur [, ip4] [, ip5] [...]</p>
<p>event_i is very similar:</p>
<p>event_i es muy similar:</p>
<p>&nbsp;</p>
<p><strong>event_i</strong> "i", iInstrNum (or "InstrName"), iStart, iDur [, ip4] [, ip5] [...]</p>
<p>The only difference between schedule and event_i is this: schedule can only trigger instruments, whereas event_i can also trigger "f" events (= build function tables).</p>
<p>&nbsp;</p>
<p>La &uacute;nica diferencia entre schedule y event_i es la siguiente: schedule s&oacute;lo puede activar instrumentos, mientras que event_i tambi&eacute;n puede desencadenar f events (= build function tables).</p>
<p>Both, schedule and event_i have a restriction: they are not able to send strings in the parameter fields p4, p5, ... So, if you execute this code ...</p>
<p>Ambos, schedule y event_i tienen una restricci&oacute;n: no son capaces de enviar cadenas en los campos de par&aacute;metros p4, p5, ... Por lo tanto, si ejecuta este c&oacute;digo ...</p>
<p>&nbsp;</p>
<p>schedule "bla", 0, 1, "blu"</p>
<p>... you will get this error message in the console:</p>
<p>... obtendr&aacute; este mensaje de error en la consola:</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: small;"><span style="font-family: 'courier new', courier, monospace;">ERROR:&nbsp; Unable to find opcode entry for 'schedule' with matching argument types: </span></span></p>
<p><span style="font-size: small;"><span style="font-family: 'courier new', courier, monospace;">Found: (null) schedule SccS</span></span></p>
<p>scoreline_i is designed to make this possible. It takes one or more lines of score statements which follow the same conventions as if written in the score section itself.5 If you enclose the line(s) by {{ and }}, you can include as many strings in it as you wish:</p>
<p>Scoreline_i est&aacute; dise&ntilde;ado para hacer esto posible. Requiere una o m&aacute;s l&iacute;neas de partituras que siguen las mismas convenciones que si estuvieran escritas en la secci&oacute;n de puntuaci&oacute;n misma.5 Si encierra la l&iacute;nea (s) por {{y}}, puede incluir tantas cuerdas como desee :</p>
<p>&nbsp;</p>
<p>scoreline_i {{</p>
<pre>              i "bla" 0 1 "blu" "sound"
              i "bla" 1 1 "brown" "earth"
            }}
</pre>
<h3>k-rate versions: event, scoreline, schedkwhen</h3>
<p>If you need a k-rate opcode to trigger an instrument event, event is the basic choice. Its syntax is very similar to event_i, but as described above, it works at k-rate and you can also change all its arguments at k-rate:</p>
<p>Si necesita un opcode k-rate para activar un evento de instrumento, el evento es la opci&oacute;n b&aacute;sica. Su sintaxis es muy similar a event_i, pero como se describi&oacute; anteriormente, funciona a k-rate y tambi&eacute;n puede cambiar todos sus argumentos en k-rate:</p>
<p>&nbsp;</p>
<p><strong>event</strong> "i", kInstrNum (or "InstrName"), kStart, kDur [, kp4] [, kp5] [...]</p>
<p>Usually, you will not want to trigger another instrument each control cycle, but based on certain conditions. A very common case is a "ticking" periodic signal, whichs ticks are being used as trigger impulses. The typical code snippel using a metro and the event opcode would be:</p>
<p>Por lo general, no querr&aacute; activar otro instrumento en cada ciclo de control, sino en funci&oacute;n de ciertas condiciones. Un caso muy com&uacute;n es una se&ntilde;al peri&oacute;dica de tictac, cuyas garrapatas se utilizan como impulsos de disparo. El t&iacute;pico c&oacute;digo snippel usando un metro y el opcode de evento ser&iacute;a:</p>
<p>&nbsp;</p>
<p>kTrigger metro 1 ;"ticks" once a second</p>
<pre>if kTrigger == 1 then ;if it ticks
  event "i", "my_instr", 0, 1 ;call the instrument
endif
</pre>
<p>In other words: This code would only use one control-cycle per second to call my_instr, and would do nothing in the other control cycles. The schedkwhen opcode simplifies such typical use cases, and adds some other useful arguments. This is the syntax:</p>
<p>En otras palabras: Este c&oacute;digo s&oacute;lo usar&iacute;a un ciclo de control por segundo para llamar a my_instr, y no har&iacute;a nada en los otros ciclos de control. El c&oacute;digo de operaci&oacute;n schedkwhen simplifica estos casos de uso t&iacute;picos y a&ntilde;ade algunos otros argumentos &uacute;tiles. Esta es la sintaxis:</p>
<p>&nbsp;</p>
<p><strong>schedkwhen</strong> kTrigger, kMinTim, kMaxNum, kInsrNum (or "InstrName"), kStart, kDur [, kp4] [, kp5] [...]</p>
<p>The kMinTim parameter specifies the time which has to be spent between two subsequent calls of the subinstrument. This is often quite useful as you may want to state: "Do not call the next instance of the subinstrument unless 0.1 seconds have been passed." If you set this parameter to zero, there will be no time limit for calling the subinstrument.</p>
<p>El par&aacute;metro kMinTim especifica el tiempo que debe pasar entre dos llamadas subsiguientes del subinstrumento. Esto es a menudo bastante &uacute;til, ya que es posible que desee declarar: No llame a la siguiente instancia del subinstrumento a menos que se hayan pasado 0,1 segundos. Si establece este par&aacute;metro en cero, no habr&aacute; l&iacute;mite de tiempo para llamar al subinstrumento.</p>
<p>&nbsp;</p>
<p>The kMaxNum parameter specifies the maximum number of instances which run simultaneously. Say, kMaxNum = 2 and there are indeed two instances of the subinstrument running, no other instance will be initiated. if you set this parameter to zero, there will be no limit for calling new instances.</p>
<p>El par&aacute;metro kMaxNum especifica el n&uacute;mero m&aacute;ximo de instancias que se ejecutan simult&aacute;neamente. Digamos, kMaxNum = 2 y de hecho hay dos instancias del subinstrumento en ejecuci&oacute;n, ninguna otra instancia se iniciar&aacute;. Si establece este par&aacute;metro en cero, no habr&aacute; l&iacute;mite para llamar a nuevas instancias.</p>
<p>&nbsp;</p>
<p>So, with schedkwhen, we can write the above code snippet in two lines instead of four:</p>
<p>Por lo tanto, con schedkwhen, podemos escribir el fragmento de c&oacute;digo anterior en dos l&iacute;neas en lugar de cuatro:</p>
<p>&nbsp;</p>
<p>kTrigger metro 1 ;"ticks" once a second</p>
<pre>schedkwhen kTrigger, 0, 0, "my_instr", 0, 1</pre>
<p>Only, you cannot pass strings as p-fields via schedkwhen (and event). So, very much similar as described above for i-rate opcodes, scoreline fills this gap. Usually we will use it with a condition, as we did for the event opcode:</p>
<p>S&oacute;lo, no puede pasar cadenas como campos p a trav&eacute;s de schedkwhen (y event). Por lo tanto, muy similar a la descrita anteriormente para opcodes de tasa i, el scoreline llena esta brecha. Por lo general lo usaremos con una condici&oacute;n, como lo hicimos con el c&oacute;digo de operaci&oacute;n del evento:</p>
<p>&nbsp;</p>
<p>kTrigger metro 1 ;"ticks" once a second</p>
<pre>if kTrigger == 1 then
  ;if it ticks, call two instruments and pass strings as p-fields
  scoreline {{
              i "bla" 0 1 "blu" "sound"
              i "bla" 1 1 "brown" "earth"
            }}
endif</pre>
<h2>Recompilation</h2>
<p>As it has been mentioned at the start of this chapter, since Csound6 you can re-compile any code in an already running Csound instance. Let us first see some simple examples for the general use, and then a more practical approach in CsoundQt.</p>
<p>Como se ha mencionado al comienzo de este cap&iacute;tulo, desde Csound6 puede volver a compilar cualquier c&oacute;digo en una instancia de Csound ya en ejecuci&oacute;n. Veamos primero algunos ejemplos simples para el uso general, y luego un enfoque m&aacute;s pr&aacute;ctico en CsoundQt.</p>
<p>&nbsp;</p>
<p>compileorc / compilestr</p>
<p>The opcode compileorc refers to a definition of instruments which has been saved as an .orc ("orchestra") file. To see how it works, save this text in a simple text (ASCII) format as "to_recompile.orc":</p>
<p>El opcode compileorc se refiere a una definici&oacute;n de instrumentos que se ha guardado como un archivo .orc (orquesta). Para ver c&oacute;mo funciona, guarde este texto en un formato de texto simple (ASCII) como to_recompile.orc:</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>instr 1</p>
<pre>iAmp = .2
iFreq = 465
aSig oscils iAmp, iFreq, 0
outs aSig, aSig
endin
</pre>
<p>Then save this csd in the same directory:</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F13_compileorc.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac -d -L stdin -Ma
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 2
ksmps = 32
0dbfs = 1

massign 0, 9999

instr 9999
ires compileorc "to_recompile.orc"
print ires ; 0 if compiled successfully
event_i "i", 1, 0, 3 ;send event
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 9999 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p><span style="font-family: 'courier new', courier, monospace; font-size: small;">If you run this csd in the terminal, you should hear a three seconds beep, and the output should be like this: </span></p>
<p><span style="font-family: 'courier new', courier, monospace; font-size: small;">Si ejecuta este csd en el terminal, debe escuchar un pitido de tres segundos, y la salida debe ser as&iacute;: </span></p>
<p><span style="font-family: 'courier new', courier, monospace; font-size: small;">SECTION 1: <br />new alloc for instr 9999: <br />instr 9999:&nbsp; ires = 0.000 <br />new alloc for instr 1: <br />B&nbsp; 0.000 ..&nbsp; 1.000 T&nbsp; 1.000 TT&nbsp; 1.000 M:&nbsp; 0.20000&nbsp; 0.20000 <br />B&nbsp; 1.000 ..&nbsp; 3.000 T&nbsp; 3.000 TT&nbsp; 3.000 M:&nbsp; 0.20000&nbsp; 0.20000 <br />Score finished in csoundPerform(). <br />inactive allocs returned to freespace <br />end of score.&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; overall amps:&nbsp; 0.20000&nbsp; 0.20000 <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; overall samples out of range:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 <br />0 errors in performance</span></p>
<p>Having understood this, it is easy to do the next step. Remove (or comment out) the score line "i 9999 0 1" so that the score is empty. If you start the csd now, Csound will run indefinitely. Now call instr 9999 by typing "i 9999 0 1" in the terminal window (if the option -L stdin works for your setup), or by pressing any MIDI key (if you have connected a keyboard). You should hear the same beep as before. But as the recompile.csd keeps running, you can change now the to_recompile.orc instrument. Try, for instance, another value for kFreq. Whenever this is done (do not forget to save the file) and you call again instr 9999 in recompile.csd, the new version of this instrument is compiled and then called immediately.</p>
<p>Habiendo entendido esto, es f&aacute;cil hacer el siguiente paso. Quitar (o comentar) la l&iacute;nea de puntuaci&oacute;n i 9999 0 1 para que la partitura est&eacute; vac&iacute;a. Si inicia el csd ahora, Csound se ejecutar&aacute; indefinidamente. Ahora llame al ins 9999 escribiendo i 9999 0 1 en la ventana de terminal (si la opci&oacute;n -L stdin funciona para su configuraci&oacute;n), o presionando cualquier tecla MIDI (si ha conectado un teclado). Usted debe escuchar el mismo pitido que antes. Pero a medida que el recompile.csd sigue funcionando, puede cambiar ahora el instrumento to_recompile.orc. Pruebe, por ejemplo, otro valor para kFreq. Siempre que esto se haga (no olvide guardar el archivo) y vuelve a llamar a instr 9999 en recompile.csd, la nueva versi&oacute;n de este instrumento se compila y luego se llama inmediatamente.</p>
<p>&nbsp;</p>
<p>The other possibility to recompile code by using an opcode is compilestr. It will compile any instrument definition which is contained in a string. As this will be a string with several lines, you will usually use the '{{' delimiter for the start and '}}' for the end of the string. This is a basic example:</p>
<p>La otra posibilidad de recompilar c&oacute;digo mediante un opcode es compilestr. Compilar&aacute; cualquier definici&oacute;n de instrumento que est&eacute; contenida en una cadena. Como esta ser&aacute; una cadena con varias l&iacute;neas, normalmente usas el {{delimitador para el inicio y} para el final de la cadena. Este es un ejemplo b&aacute;sico:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F14_compilestr.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 1
ksmps = 32
0dbfs = 1

instr 1

 ;will fail because of wrong code
ires compilestr {{
instr 2
a1 oscilb p4, p5, 0
out a1
endin
}}
print ires ; returns -1 because not successfull

 ;will compile ...
ires compilestr {{
instr 2
a1 oscils p4, p5, 0
out a1
endin
}}
print ires ; ... and returns 0

 ;call the new instrument
 ;(note that the overall performance is extended)
scoreline_i "i 2 0 3 .2 415"

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>As you see, instrument 2 is defined inside instrument 1, and compiled via compilestr. in case you can change this string in real-time (for instance in receiving it via OSC), you can add any new definition of instruments on the fly. But much more elegant is to use the related method of the Csound API, as CsoundQt does.</p>
<p>Como usted ve, el instrumento 2 se define dentro del instrumento 1, y se compila v&iacute;a compilestr. En caso de que pueda cambiar esta cadena en tiempo real (por ejemplo al recibirla a trav&eacute;s de OSC), puede agregar cualquier nueva definici&oacute;n de instrumentos sobre la marcha. Pero mucho m&aacute;s elegante es utilizar el m&eacute;todo relacionado de la API Csound, como lo hace CsoundQt.</p>
<p>&nbsp;</p>
<p>Re-Compilation in CsoundQt</p>
<p>(The following description is only valid if you have CsoundQt with PythonQt support. If so, your CsoundQt application should be called CsoundQt-d-py-cs6 or similar. If the "-py" is missing, you will probably not have PythonQt support.)</p>
<p>(La siguiente descripci&oacute;n s&oacute;lo es v&aacute;lida si tienes CsoundQt con soporte para PythonQt.) Si es as&iacute;, tu aplicaci&oacute;n CsoundQt deber&iacute;a llamarse CsoundQt-d-py-cs6 o similar.</p>
<p>&nbsp;</p>
<p>To see how easy it is to re-compile code of a running Csound instance, load this csd in CsoundQt:</p>
<p>Para ver lo f&aacute;cil que es volver a compilar c&oacute;digo de una instancia de Csound en ejecuci&oacute;n, cargue este csd en CsoundQt:</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 03F15_Recompile_in_CsoundQt.csd</strong></em>&nbsp;&nbsp;&nbsp;</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 1
ksmps = 32
0dbfs = 1

instr 1
a1 poscil .2, 500
out a1
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
r 1000
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The r-statement repeats the call to instr 1 for 1000 times. Now change the frequency of 500 in instr 1 to say 800. You will hear no change, because this has not been compiled yet. But when you now select the instrument definition (including the instr ... endin) and then choose Edit -&gt; Evaluate selection, you will hear that in the next call of instrument 1 the frequency has changed. (Instead of selecting code and evaluation the selection, you can also place the cursor inside an instrument and then choose Edit -&gt; Evaluate section.)</p>
<p>La instrucci&oacute;n r repite la llamada a instr 1 por 1000 veces. Ahora cambia la frecuencia de 500 en instr 1 para decir 800. No escuchar&aacute;s ning&uacute;n cambio, porque a&uacute;n no se ha compilado. Pero cuando ahora seleccione la definici&oacute;n del instrumento (incluyendo la instrucci&oacute;n ... endin) y luego elija Edit - Evaluate selection, oir&aacute; que en la siguiente llamada del instrumento 1 la frecuencia ha cambiado. (En lugar de seleccionar el c&oacute;digo y evaluar la selecci&oacute;n, tambi&eacute;n puede colocar el cursor dentro de un instrumento y luego seleccionar la secci&oacute;n Editar - Evaluar).</p>
<p>You can also insert new instrument definitions, and then call it with CsoundQt's Live event sheet. You even need not save it - instead you can save several results of your live coding without stopping Csound. Have fun ...</p>
<p>Tambi&eacute;n puede insertar nuevas definiciones de instrumento y, a continuaci&oacute;n, llamarla con la hoja de eventos CsoundQts Live. Incluso no es necesario guardarlo - en su lugar puede guardar varios resultados de su codificaci&oacute;n en vivo sin detener Csound. Que te diviertas ...</p>
<p>&nbsp;</p>
<p><br />&nbsp;</p>
<p>&nbsp;</p>
<h2>Links And Related Opcodes</h2>
<h3>Links</h3>
<p>A great collection of interactive examples with FLTK widgets by Iain McCurdy can be found here. See particularily the "Realtime Score Generation" section. Recently, the collection has been ported to QuteCsound by Ren&eacute; Jopi, and is part of QuteCsound's example menu.</p>
<p>Una gran colecci&oacute;n de ejemplos interactivos con widgets FLTK de Iain McCurdy se puede encontrar aqu&iacute;. Vea en particular la secci&oacute;n Generaci&oacute;n de Puntajes en Tiempo Real. Recientemente, la colecci&oacute;n ha sido portada a QuteCsound por Ren&eacute; Jopi, y es parte del men&uacute; de ejemplo de QuteCsounds.</p>
<p>&nbsp;</p>
<p>An extended example for calculating score events at i-time can be found in the Re-Generation of Stockhausen's "Studie II" by Joachim Heintz (also included in the QuteCsound Examples menu).</p>
<p>Un ejemplo extendido para calcular los eventos de puntuaci&oacute;n en i-time se puede encontrar en la Re-Generaci&oacute;n de Stockhausens Studie II de Joachim Heintz (tambi&eacute;n incluido en el men&uacute; QuteCsound Ejemplos).</p>
<p>&nbsp;</p>
<p>Related Opcodes</p>
<p><a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> / <a href="http://www.csounds.com/manual/html/event.html">event</a>: Generate an instrument event at i-time (event_i) or at k-time (event). Easy to use, but you cannot send a string to the subinstrument.</p>
<p><a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a> / <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a>: Generate an instrument at i-time (scoreline_i) or at k-time (scoreline). Like event_i/event, but you can send to more than one instrument but unlike event_i/event you can send strings. On the other hand, you must usually preformat your scoreline-string using sprintf.</p>
<p><a href="http://www.csounds.com/manual/html/sprintf.html">sprintf</a> / <a href="http://www.csounds.com/manual/html/sprintfk.html">sprintfk</a>: Generate a formatted string at i-time (sprintf) or k-time (sprintfk), and store it as a string-variable.</p>
<p><a href="http://www.csounds.com/manual/html/CommandFlags.html">-+max_str_len=10000</a>: Option in the "CsOptions" tag of a .csd file which extend the maximum string length to 9999 characters.</p>
<p><a href="http://www.csounds.com/manual/html/massign.html">massign</a>: Assigns the incoming MIDI events to a particular instrument. It is also possible to prevent any assigment by this opcode.</p>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a> / <a href="http://www.csounds.com/manual/html/ampmidi.html">ampmidi</a>: Returns the frequency / velocity of a pressed MIDI key.</p>
<p><a href="http://www.csounds.com/manual/html/release.html">release</a>: Returns "1" if the last k-cycle of an instrument has begun.</p>
<p><a href="http://www.csounds.com/manual/html/xtratim.html">xtratim</a>: Adds an additional time to the duration (p3) of an instrument.</p>
<p><a href="http://www.csounds.com/manual/html/turnoff.html">turnoff</a> / <a href="http://www.csounds.com/manual/html/turnoff2.html">turnoff2</a>: Turns an instrument off; either by the instrument itself (turnoff), or from another instrument and with several options (turnoff2).</p>
<p><a href="http://www.csounds.com/manual/html/i.html">-p3 / -p</a><span class="Apple-style-span" style="text-decoration: underline;">1</span>: A negative duration (p3) turns an instrument on "indefinitely"; a negative instrument number (p1) turns this instrument off. See the examples at the beginning of this chapter.</p>
<p><a href="http://www.csounds.com/manual/html/CommandFlags.html">-L stdin</a>: Option in the "CsOptions" tag of a .csd file which lets you type in realtime score events.</p>
<p><a href="http://www.csounds.com/manual/html/timout.html">timout</a>: Allows you to perform time loops at i-time with reinitalization passes.</p>
<p><a href="http://www.csounds.com/manual/html/metro.html">metro</a>: Outputs momentary 1s with a definable (and variable) frequency. Can be used to perform a time loop at k-rate.</p>
<p><a href="http://www.csounds.com/manual/html/follow.html">follow</a>: Envelope follower.</p>
<ol id="InsertNote_NoteList">
<li id="InsertNoteID_26">This has been described incorrectly in the first two issues of this manual.<span id="InsertNoteID_26_LinkBacks"><sup><a href="f-live-events/e-triggering-instrument-events#InsertNoteID_26_marker27">^</a></sup></span></li>
<li id="InsertNoteID_28">There are also some video tutorials: http://www.youtube.com/watch?v=O9WU7DzdUmE http://www.youtube.com/watch?v=Hs3eO7o349k http://www.youtube.com/watch?v=yUMzp6556Kw<span id="InsertNoteID_28_LinkBacks"><sup><a href="f-live-events/e-triggering-instrument-events#InsertNoteID_28_marker29">^</a></sup></span></li>
<li id="InsertNoteID_15">See chapter 03A about Initialization and Performance Pass for a detailed discussion.<span id="InsertNoteID_15_LinkBacks"><sup><a href="f-live-events/e-triggering-instrument-events#InsertNoteID_15_marker16">^</a></sup></span></li>
<li id="InsertNoteID_17">As for a sample rate of 44100 Hz (sr=44100) and a control period od 32 samples (ksmps=32), we have 1378 control periods in one second. So 0.01 seconds will perform 14 control cycles.<span id="InsertNoteID_17_LinkBacks"><sup><a href="f-live-events/e-triggering-instrument-events#InsertNoteID_17_marker18">^</a></sup></span></li>
<li id="InsertNoteID_22">This means that score parameter fields are separated by spaces, not by commas.<span id="InsertNoteID_22_LinkBacks"><sup><a href="f-live-events/e-triggering-instrument-events#InsertNoteID_22_marker23">^</a></sup></span></li>
</ol>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

